<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git commit 规范和 如何在 commit 里使用 emoji</title>
    <link href="/index.php/archives/20210905/"/>
    <url>/index.php/archives/20210905/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是桃翁，今天给大家带来的是关于 git commit 那些事儿，希望大家喜欢。</p><p>对于规范 git commit message 我是分成了两种类型去看待。</p><ul><li><p>对于通用库、开源项目这类多人维护，而且极大可能别人会来看这份代码的，一定要规范，特别是对于开源项目，往往会要列 Change Log，规范好 commit 节省自己整理 log 的时间，也方便了用户。</p></li><li><p>对于业务代码，特别是那种一个人维护的，其实不搞问题也不大，因为极小可能会有人来看你的 commit message。但是我依然还是建议规范一下，不然一旦后面想去看就会花费很多的力气，毕竟规范一下也不麻烦。</p></li></ul><p>通过本篇文章你讲了解到三部分内容：</p><ol><li>了解 git commit 规范</li><li>学到用工具 Commitizen 来规范 commit</li><li>学到如何在 commit message 里加上好看的 emoji</li></ol><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>现在主流的 commit message 规范就是 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular 团队所用的准则</a>，继而衍生了 <a href="https://link.zhihu.com/?target=https://conventionalcommits.org/">Conventional Commits specification</a>. 很多工具也是基于此规范。</p><p>每次提交，Commit message 都包括三个部分：header，body 和 footer，其中 header 有一个特殊的格式，包括了 type、scope、subject。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>): <span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 header 是必选的，但是 header 里的 scope 是可选的，另外提交的 message 长度不要超过 100 个字符，太长了不易阅读。</p><p><strong>对于我个人来说，我觉得只要把 header 部分规范其实基本能满足绝大部分需要了，强制去规范 body 和 footer 对于团队的同学来说简直是折磨，所以我这里仅介绍 header 的几部分</strong></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 指明 git commit 的类别，应该使用以下类型</p><ul><li>『feat』: 新增功能</li><li>『fix』: 修复 bug</li><li>『docs』: 仅仅修改了文档，比如 README, CHANGELOG等等</li><li>『test』: 增加/修改测试用例，包括单元测试、集成测试等</li><li>『style』: 修改了空行、缩进格式、引用包排序等等（不改变代码逻辑）</li><li>『perf』: 优化相关内容，比如提升性能、体验、算法等</li><li>『refactor』: 代码重构，「没有新功能或者bug修复」</li><li>『chore』: 改变构建流程、或者增加依赖库、工具等</li><li>『revert』: 回滚到上一个版本</li><li>『merge』: 代码合并</li></ul><blockquote><p>这里面有些 angular 团队没有，自己可以自行增减</p></blockquote><h3 id="scope（可选）"><a href="#scope（可选）" class="headerlink" title="scope（可选）"></a><strong>scope（可选）</strong></h3><p>scope用于说明 commit 影响的范围，根据不同项目有不同层次描述。若没有特殊规定，也可以描述影响的哪些功能等。</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a><strong>subject</strong></h3><p>subject 是 commit 目的的简短描述，不超过50/80个字符，一般 git 提交的时候会有颜色提示。</p><ul><li>若英文用不惯，那么推荐使用中文</li><li>若是开源代码，一律推荐统一英文，英文不行可以翻译软件用起来</li><li>若是开源代码，可以再附加对应的issue地址</li><li>结尾不加标点符号</li></ul><h2 id="工具：Commitizen"><a href="#工具：Commitizen" class="headerlink" title="工具：Commitizen"></a>工具：Commitizen</h2><p>Commitizen是一个撰写合格 Commit message 的工具,（详细说明<a href="https://github.com/commitizen/cz-cli">见 github 地址</a>），用于代替 git commit 指令，而 cz-conventional-changelog 适配器提供 conventional-changelog 标准（约定式提交标准）。基于不同需求，也可以使用不同适配器。</p><p><strong>1. 全局安装 commitizen cz-conventional-changelog</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g commitizen cz-conventional-changelog<br></code></pre></td></tr></table></figure><p><strong>2. git cz 取代 git commit</strong></p><p>安装完毕后，可直接使用 git cz 来取代 git commit。</p><p><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308510363184.jpg"></p><p>可以看到当你 cz 之后，下面有很多的 type 让你选择，这就省掉了每次你去想应该用哪种 type，非常方便。</p><blockquote><p>全局模式下，需要 <code>~/.czrc</code> 配置文件, 为commitizen 指定 Adapter, 如果你不需要生成 Change Log 可以不用去处理。</p></blockquote><p>只要用了 Commitizen ，就很方便的就规范的大家的 message 。</p><h2 id="在-commit-message-里用-emoji"><a href="#在-commit-message-里用-emoji" class="headerlink" title="在 commit message 里用 emoji"></a>在 commit message 里用 emoji</h2><p>在 git commit 上使用 emoji 提供了一种简单的方法，仅通过查看所使用的表情符号来确定提交的目的或意图, 得提交记录非常好理解，阅读体验非常棒。</p><p><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308316508371.jpg"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>git commit 时直接在注释中写入表情符号的代码部分即可完成表情 emoji 的提交。</p><p><strong>举个栗子：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;:tada: init commit&#x27;</span><br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;added image to repo :art:&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果你用 Commitizen，可能不太好把 emoji 放在最前面，因为咱们操作的空间，就在 git cz 后第三次交互提示，也就是在输入 header 的 subject 的时候填入，如果是这样，可以选择把表情放到最后。 </p></blockquote><p>效果展示：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308323105662.jpg"></p><p>如果你们团队是一个喜欢用 emoji 的团队，其实可以不用遵循上面的一节的规范，因为 emoji 已经可以表达出 header 的 type 的作用了，直接在 emoji 后面加描述即可。</p><h3 id="emoji-表情库"><a href="#emoji-表情库" class="headerlink" title="emoji 表情库"></a>emoji 表情库</h3><table><thead><tr><th align="left">emoji</th><th align="left">emoji 代码</th><th align="left">commit 说明</th></tr></thead><tbody><tr><td align="left">:tada: (庆祝)</td><td align="left"><code>:tada:</code></td><td align="left">初次提交</td></tr><tr><td align="left">:new: (全新)</td><td align="left"><code>:new:</code></td><td align="left">引入新功能</td></tr><tr><td align="left">:bookmark: (书签)</td><td align="left"><code>:bookmark:</code></td><td align="left">发行/版本标签</td></tr><tr><td align="left">:bug: (bug)</td><td align="left"><code>:bug:</code></td><td align="left">修复 bug</td></tr><tr><td align="left">:ambulance: (急救车)</td><td align="left"><code>:ambulance:</code></td><td align="left">重要补丁</td></tr><tr><td align="left">:globe_with_meridians: (地球)</td><td align="left"><code>:globe_with_meridians:</code></td><td align="left">国际化与本地化</td></tr><tr><td align="left">:lipstick: (口红)</td><td align="left"><code>:lipstick:</code></td><td align="left">更新 UI 和样式文件</td></tr><tr><td align="left">:clapper: (场记板)</td><td align="left"><code>:clapper:</code></td><td align="left">更新演示/示例</td></tr><tr><td align="left">:rotating_light: (警车灯)</td><td align="left"><code>:rotating_light:</code></td><td align="left">移除 linter 警告</td></tr><tr><td align="left">:wrench: (扳手)</td><td align="left"><code>:wrench:</code></td><td align="left">修改配置文件</td></tr><tr><td align="left">:heavy_plus_sign: (加号)</td><td align="left"><code>:heavy_plus_sign:</code></td><td align="left">增加一个依赖</td></tr><tr><td align="left">:heavy_minus_sign: (减号)</td><td align="left"><code>:heavy_minus_sign:</code></td><td align="left">减少一个依赖</td></tr><tr><td align="left">:arrow_up: (上升箭头)</td><td align="left"><code>:arrow_up:</code></td><td align="left">升级依赖</td></tr><tr><td align="left">:arrow_down: (下降箭头)</td><td align="left"><code>:arrow_down:</code></td><td align="left">降级依赖</td></tr><tr><td align="left">:zap: (闪电)<br>:racehorse: (赛马)</td><td align="left"><code>:zap:</code><br><code>:racehorse:</code></td><td align="left">提升性能</td></tr><tr><td align="left">:chart_with_upwards_trend: (上升趋势图)</td><td align="left"><code>:chart_with_upwards_trend:</code></td><td align="left">添加分析或跟踪代码</td></tr><tr><td align="left">:rocket: (火箭)</td><td align="left"><code>:rocket:</code></td><td align="left">部署功能</td></tr><tr><td align="left">:white_check_mark: (白色复选框)</td><td align="left"><code>:white_check_mark:</code></td><td align="left">增加测试</td></tr><tr><td align="left">:memo: (备忘录)<br>:book: (书)</td><td align="left"><code>:memo:</code><br><code>:book:</code></td><td align="left">撰写文档</td></tr><tr><td align="left">:hammer: (锤子)</td><td align="left"><code>:hammer:</code></td><td align="left">重大重构</td></tr><tr><td align="left">:art: (调色板)</td><td align="left"><code>:art:</code></td><td align="left">改进代码结构/代码格式</td></tr><tr><td align="left">:fire: (火焰)</td><td align="left"><code>:fire:</code></td><td align="left">移除代码或文件</td></tr><tr><td align="left">:pencil2: (铅笔)</td><td align="left"><code>:pencil2:</code></td><td align="left">修复 typo</td></tr><tr><td align="left">:construction: (施工)</td><td align="left"><code>:construction:</code></td><td align="left">工作进行中</td></tr><tr><td align="left">:wastebasket: (垃圾桶)</td><td align="left"><code>:wastebasket:</code></td><td align="left">废弃或删除</td></tr><tr><td align="left">:wheelchair: (轮椅)</td><td align="left"><code>:wheelchair:</code></td><td align="left">可访问性</td></tr><tr><td align="left">:construction_worker: (工人)</td><td align="left"><code>:construction_worker:</code></td><td align="left">添加 CI 构建系统</td></tr><tr><td align="left">:green_heart: (绿心)</td><td align="left"><code>:green_heart:</code></td><td align="left">修复 CI 构建问题</td></tr><tr><td align="left">:lock: (锁)</td><td align="left"><code>:lock:</code></td><td align="left">修复安全问题</td></tr><tr><td align="left">:whale: (鲸鱼)</td><td align="left"><code>:whale:</code></td><td align="left">Docker 相关工作</td></tr><tr><td align="left">:apple: (苹果)</td><td align="left"><code>:apple:</code></td><td align="left">修复 macOS 下的问题</td></tr><tr><td align="left">:penguin: (企鹅)</td><td align="left"><code>:penguin:</code></td><td align="left">修复 Linux 下的问题</td></tr><tr><td align="left">:checkered_flag: (旗帜)</td><td align="left"><code>:checkered_flag:</code></td><td align="left">修复 Windows 下的问题</td></tr><tr><td align="left">:twisted_rightwards_arrows: (交叉箭头)</td><td align="left"><code>:twisted_rightwards_arrows:</code></td><td align="left">分支合并</td></tr></tbody></table><h3 id="如何在命令行中显示-emoji"><a href="#如何在命令行中显示-emoji" class="headerlink" title="如何在命令行中显示 emoji"></a>如何在命令行中显示 emoji</h3><p>默认情况下，在命令行中并不会显示出 emoji, 仅显示 emoji 代码。不过可以使用 emojify 使得在命令行也可显示 emoji, 它是一个 shell 脚本，安装与使用都很简单，在<a href="https://github.com/mrowa44/emojify">这里</a> 查看更详细的如何安装与使用。</p><h4 id="安装-emojify"><a href="#安装-emojify" class="headerlink" title="安装 emojify"></a>安装 emojify</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo sh -c <span class="hljs-string">&quot;curl https://raw.githubusercontent.com/mrowa44/emojify/master/emojify -o /usr/local/bin/emojify &amp;&amp; chmod +x /usr/local/bin/emojify&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用-emojify"><a href="#使用-emojify" class="headerlink" title="使用 emojify"></a>使用 emojify</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ emojify <span class="hljs-string">&quot;Hey, I just :raising_hand: you, and this is :scream: , but here&#x27;s my :calling: , so :telephone_receiver: me, maybe?&quot;</span><br></code></pre></td></tr></table></figure><p>显示效果：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308498280794.jpg"></p><p>在使用 git bash 的时候，设置替换日志中的表情符号代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --oneline --color | emojify | less -r<br></code></pre></td></tr></table></figure><p>或者设置git log命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> gitlog=<span class="hljs-string">&#x27;git log --oneline --color | emojify | less -r&#x27;</span><br><br>$ gitlog <br></code></pre></td></tr></table></figure><p>效果如下：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308499434082.jpg"></p><p><strong>是不是很好玩，快去试试吧！</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hooj0.github.io/git-emoji-guide/">git-emoji-guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/29764863">git commit 时使用 Emoji ?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>img 和 picture 的区别和使用场景</title>
    <link href="/index.php/archives/341/"/>
    <url>/index.php/archives/341/</url>
    
    <content type="html"><![CDATA[<h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img">img</a> 是 HTML4 时就有的标签， 至今仍然是在网页中嵌入图片的最常用的方式。 与 <code>&lt;span&gt;</code>, <code>&lt;em&gt;</code> 等标签一样属于行内标签 （准确地说属于 <a href="https://html.spec.whatwg.org/#phrasing-content">Phrasing Content</a>）。下面是一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;favicon72.png&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;MDN logo&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;favicon144.png 2x&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>img 其实也可以控制在高清屏幕采用哪个图片，适合用在移动端</p><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;/media/cc0-images/surfer-240-200.jpg&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 800px)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/media/cc0-images/painted-hand-298-332.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要决定加载哪个URL，<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent">user agent</a> 检查每个 <code>&lt;source&gt;</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-srcset"><code>srcset</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-media"><code>media</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-type"><code>type</code></a> 属性，来选择最匹配页面当前布局、显示设备特征等的兼容图像。</p><p>picture 就可以方便的控制在某种媒体类型，加载哪个图片。感觉比较适合做响应式用。</p><p>相比 <code>img</code> 标签，<code>picture</code> 提供了更丰富的响应式资源选择方式；</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture">picture</a> 是 HTML5 中定义新标签， 其中可以定义若干个 <code>&lt;source&gt;</code>，浏览器会匹配 <code>&lt;source&gt;</code> 的 <code>type</code>, <code>media</code>, <code>srcset</code> 等属性， 来找到最适合当前布局、<a href="https://harttle.land/2016/04/21/viewport.html">视口宽度</a>、<em>设备像素密度</em> 的一个去下载。 为了向下兼容不识别 <code>&lt;picture&gt;</code> 和 <code>&lt;source&gt;</code> 的浏览器，<code>&lt;picture&gt;</code> 中还可以写一个 <code>&lt;img&gt;</code> 作为 fallback。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;harttle-land-avatar.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 750px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;harttle-land-banner.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;a banner for harttle.land&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="图片如何做响应式"><a href="#图片如何做响应式" class="headerlink" title="图片如何做响应式"></a>图片如何做响应式</h2><h3 id="响应式：基于视口宽度"><a href="#响应式：基于视口宽度" class="headerlink" title="响应式：基于视口宽度"></a>响应式：基于视口宽度</h3><p><a href="https://en.wikipedia.org/wiki/Responsive_web_design">响应式设计</a> 是一种 Web 页面设计方式， 使得不同 <a href="https://harttle.land/2016/04/21/viewport.html">视口宽度</a> 和 <em>设备像素密度</em> 下内容都可以很好地展示，都可以保证可用性和用户满足。</p><p>提到响应式多数开发者都会想到 CSS 媒体查询，但 HTML5 中还定义了元素属性的媒体查询。 这使得可以通过媒体查询来根据元素渲染宽度 <em>选择资源</em> 和 <em>图片占位</em>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> </span><br><span class="hljs-tag">     <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-200.png 200w, avatar-400.png 400w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 600px) 200px, 50vw&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器会根据 <code>sizes</code> 的媒体查询来决定渲染大小；此后根据实际的渲染大小来决定选择哪个资源。 比如屏幕宽度为 <code>500px</code>，那么就会调整图片大小为 <code>200px</code>， 然后选择 <code>srcset</code> 中最匹配这个大小的 <code>avatar-200.png</code> 去下载。</p><h3 id="响应式：基于设备像素比"><a href="#响应式：基于设备像素比" class="headerlink" title="响应式：基于设备像素比"></a>响应式：基于设备像素比</h3><p>支持 HTML5 的浏览器中还可以基于 <em>设备像素比</em> 来选择资源。 在刚出现 Retina 屏幕时有些网页图片展现模糊， 就是因为在高像素密度（比如 2 倍设备像素比）的屏幕上仍然显示 1 倍大小的图片。 <code>&lt;img&gt;</code> 元素的 src 和 srcset 属性都支持 x 描述符来提供不同大小的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar-1.0.png&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-1.5.png 1.5x, avatar-2.0.png 2x&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用户代理可以根据用户屏幕像素密度、缩放级别，甚至用户的网络条件选择任何一个给出的资源。 这里同时给出 <code>src</code> 也是为了向后兼容。</p><h3 id="响应式：基于媒体查询"><a href="#响应式：基于媒体查询" class="headerlink" title="响应式：基于媒体查询"></a>响应式：基于媒体查询</h3><p>上文提到在 <code>&lt;img&gt;</code> 元素的 <code>sizes</code> 中可以写媒体查询来计算宽高。 <code>&lt;picture&gt;</code> 中也可以通过媒体查询来选择 <code>&lt;source&gt;</code> 可以给不同的设备大小下载不同的图片。 区别在于 <strong>基于视口宽度</strong> 的资源选择侧重于对不同大小的屏幕选择宽度适合的，同样内容的图片。 <strong>基于媒体查询</strong> 的资源选择侧重于对不同的屏幕选择不同内容的图片。</p><p>比如在移动设备上只显示头像，在大屏幕显示器上则显示完整的大图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 640px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-with-background.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 640px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;smiling harttle&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>基于媒体查询的选择在 HTML5 标准中称为 <a href="https://html.spec.whatwg.org/multipage/images.html#art-direction">Art Direction</a>。</p><h3 id="响应式：基于图片格式"><a href="#响应式：基于图片格式" class="headerlink" title="响应式：基于图片格式"></a>响应式：基于图片格式</h3><p><code>&lt;source&gt;</code> 元素的 <code>type</code> 属性可以指定图片格式，浏览器可以选择自己支持的去下载。 基于图片格式的选择可以用于性能优化，有些格式我们知道压缩比非常好但并非所有浏览器都支持。 这时就可以提供多种格式的图片让浏览器来选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.webp&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.jxr&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/vnd.ms-photo&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，如果用户代理支持 WebP 就会选择第一个 <code>&lt;source&gt;</code> 元素。 如果不支持 WebP，但支持 JPEG XR 就会选择第二个 source 元素。 如果这两种都不支持，就会选择 img 元素。（这个例子来自 <a href="https://html.spec.whatwg.org/multipage/images.html#image-format-based-selection">HTML Standard</a>）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://harttle.land/2018/05/30/responsive-img-picture.html">正确使用 HTML5 标签：img, picture, figure 的响应式设计</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记本</tag>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4个你从未听说过的强大的 JavaScript 运算符</title>
    <link href="/index.php/archives/339/"/>
    <url>/index.php/archives/339/</url>
    
    <content type="html"><![CDATA[<p>你有没有花一个下午的时间浏览过 Mozilla 文档？如果你有，你会很清楚网上有很多关于 JavaScript 的信息。这使得人们很容易忽略一些不同寻常的 JavaScript 操作符。</p><p>然而，仅仅因为这些操作符不常见并不意味着它们不强大！它们在语法上看起来都很相似，但是当它们以不同的方式工作时，请务必阅读它们。</p><p>让我们开始吧！</p><blockquote><p>译者注：nullish 代表 null 或者 undefined</p></blockquote><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. ?? 操作符"></a>1. ?? 操作符</h2><p>在 JavaScript 中，<code>??</code> 操作符被称为<code>nullish</code> 合并操作符。如果第一个参数不是 <code>null/undefined</code>，这个运算符将返回第一个参数，否则，它将返回第二个参数。让我们看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">null</span> ?? <span class="hljs-number">5</span> <span class="hljs-comment">// =&gt; 5</span><br><span class="hljs-number">3</span> ?? <span class="hljs-number">5</span> <span class="hljs-comment">// =&gt; 3</span><br></code></pre></td></tr></table></figure><p>当为一个变量分配默认值时，JavaScript 开发人员传统上依赖于逻辑 <code>OR</code> 操作符，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> prevMoney = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> currMoney = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> noAccount = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> futureMoney = -<span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moneyAmount</span>(<span class="hljs-params">money</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> money || <span class="hljs-string">`You currently do not own an account in the bank`</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(moneyAmount(prevMoney)) <span class="hljs-comment">// =&gt; 1</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(currMoney)) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(noAccount)) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(futureMoney))<span class="hljs-comment">//  =&gt; -1</span><br></code></pre></td></tr></table></figure><p>上面我们创建了一个函数 <code>moneyAmount</code>，负责返回用户的当前余额。我们使用了 <code>||</code> 操作符来识别没有帐户的用户。 当 money 为 0 或者 null 的时候都会返回在当前银行没有这个账户，但是实际上账户是可能为 0 的 。在上面的示例中， <code>||</code> 操作符将 0 视为假值，因此识别不出来我们的用户拥有一个 0 美元的帐户。让我们通过使用 nullish 合并操作符来解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> currMoney = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> noAccount = <span class="hljs-literal">null</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moneyAmount</span>(<span class="hljs-params">money</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> money ?? <span class="hljs-string">`You currently do not own an account in the bank`</span><br>&#125;<br> moneyAmount(currMoney) <span class="hljs-comment">// =&gt; 0</span><br> moneyAmount(noAccount) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br></code></pre></td></tr></table></figure><p><strong>总结一下，<code>??</code> 操作符允许我们分配默认值，同时忽略像 0 和空字符串这样的假值。</strong></p><h2 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. ??= 操作符"></a>2. <code>??=</code> 操作符</h2><p><code>??=</code> 又称为逻辑 nullish 赋值操作符，与我们之前学到的内容密切相关。让我们看看它们是如何联系在一起的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> y = <span class="hljs-number">5</span><br><br><span class="hljs-built_in">console</span>.log(x ??= y) <span class="hljs-comment">// =&gt; 5</span><br><span class="hljs-built_in">console</span>.log(x = (x ?? y)) <span class="hljs-comment">// =&gt; 5</span><br></code></pre></td></tr></table></figure><p>只有当前值为 null 或 undefined 时，此赋值运算符才会分配新值。上面的例子强调了这个操作符如何实质上是 nullish 赋值的语法糖。接下来，让我们看看这个操作符与默认参数的区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameSettingsWithNullish</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  options.gameSpeed ??= <span class="hljs-number">1</span><br>  options.gameDiff ??= <span class="hljs-string">&#x27;easy&#x27;</span><br>  <span class="hljs-keyword">return</span> options<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameSettingsWithDefaultParams</span>(<span class="hljs-params">gameSpeed=<span class="hljs-number">1</span>, gameDiff=<span class="hljs-string">&#x27;easy&#x27;</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;gameSpeed, gameDiff&#125;<br>&#125;<br><br>gameSettingsWithNullish(&#123;<span class="hljs-attr">gameSpeed</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">gameDiff</span>: <span class="hljs-literal">null</span>&#125;) <span class="hljs-comment">// =&gt; &#123; gameSpeed: 1, gameDiff: &#x27;easy&#x27; &#125;</span><br>gameSettingsWithDefaultParams(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// =&gt; &#123; gameSpeed: null, gameDiff: null &#125;</span><br></code></pre></td></tr></table></figure><p>上面的函数处理空值的方式有一个显著的不同。默认参数将使用 null 参数覆盖默认值，nullish 赋值操作符不会。默认参数和 nullish 赋值都不会覆盖未定义的值。</p><h2 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. ?. 操作符"></a>3. <code>?.</code> 操作符</h2><p>可选的链接操作符 <code>?.</code> 允许开发人员读取深度嵌套在一个对象链中的属性值，而不必沿途显式验证每个引用。当引用为 null 时，表达式停止计算并返回 <code>undefined</code>，让我们来看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> travelPlans  = &#123;<br>  <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;DC&#x27;</span>,<br>  <span class="hljs-attr">monday</span>: &#123;<br>    <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;National Mall&#x27;</span>,<br>    <span class="hljs-attr">budget</span>: <span class="hljs-number">200</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> tuesdayPlans = travelPlans.tuesday?.location;<br><span class="hljs-built_in">console</span>.log(tuesdayPlans) <span class="hljs-comment">// =&gt; undefined</span><br></code></pre></td></tr></table></figure><p>现在，让我们把迄今为止所学到的一切结合起来，把星期二添加到我们的新旅行计划中去吧！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPlansWhenUndefined</span>(<span class="hljs-params">plans, location, budget</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (plans.tuesday?.location === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">var</span> newPlans = &#123;<br>      plans,<br>      <span class="hljs-attr">tuesday</span>: &#123; <span class="hljs-attr">location</span>: location ?? <span class="hljs-string">&quot;Park&quot;</span>, <span class="hljs-attr">budget</span>: budget ?? <span class="hljs-number">200</span> &#125;,<br>    &#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    newPlans ??= plans; <span class="hljs-comment">//will only override if newPlans is undefined</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Plans have already been added!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> newPlans;<br>&#125;<br><br><span class="hljs-keyword">var</span> newPlans = addPlansWhenUndefined(travelPlans, <span class="hljs-string">&quot;Ford Theatre&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-built_in">console</span>.log(newPlans) <span class="hljs-comment">// =&gt; &#123; plans:</span><br>                  <span class="hljs-comment">//&#123; destination: &#x27;DC&#x27;,</span><br>                  <span class="hljs-comment">// monday: &#123; location: &#x27;National Mall&#x27;, budget: 200 &#125; &#125;,</span><br>                  <span class="hljs-comment">// tuesday: &#123; location: &#x27;Ford Theatre&#x27;, budget: 200 &#125; &#125;</span><br><br>newPlans = addPlansWhenUndefined(newPlans, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// logs =&gt; Plans have already been added!</span><br>                                                      <span class="hljs-comment">// returns =&gt; newPlans object</span><br></code></pre></td></tr></table></figure><p>我们现在已经创建了一个函数，该函数将计划添加到当前没有嵌套属性 <code>tuesday.location</code> 的对象中。我们还使用 nullish 操作符提供默认值。这个函数将接受错误的值，如“0”作为有效的参数。这意味着我们的预算可以设置为零，没有任何错误。</p><h2 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4. ? 操作符"></a>4. <code>?</code> 操作符</h2><p>三元运算符 <code>?</code> 有三个操作数: 一个条件，一个条件为真时执行的表达式，以及一个条件为假时执行的表达式。让我们看看它是如何运作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkCharge</span>(<span class="hljs-params">charge</span>) </span>&#123;<br><span class="hljs-keyword">return</span> (charge &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&#x27;Ready for use&#x27;</span> : <span class="hljs-string">&#x27;Needs to charge&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(checkCharge(<span class="hljs-number">20</span>)) <span class="hljs-comment">// =&gt; &#x27;Ready for use&#x27;</span><br><span class="hljs-built_in">console</span>.log(checkCharge(<span class="hljs-number">0</span>)) <span class="hljs-comment">// =&gt; &#x27;Needs to charge&#x27;</span><br></code></pre></td></tr></table></figure><p>如果你花了一些时间研究 JavaScript，你可能以前见过三元运算符。然而，你知道三元运算符可以用于变量赋值吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> budget = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> transportion = (budget &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&#x27;Train&#x27;</span> : <span class="hljs-string">&#x27;Walking&#x27;</span><br><span class="hljs-built_in">console</span>.log(transportion) <span class="hljs-comment">// =&gt; &#x27;Walking&#x27;</span><br></code></pre></td></tr></table></figure><p>我们甚至可以用它来复制 nullish 赋值的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> x = (x !== <span class="hljs-literal">null</span> || x !== <span class="hljs-literal">undefined</span>) ? x : <span class="hljs-number">3</span><br><span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// =&gt; 6</span><br></code></pre></td></tr></table></figure><p>现在让我们通过创建一个函数来泛化这种行为！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nullishAssignment</span>(<span class="hljs-params">x,y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (x == <span class="hljs-literal">null</span> || x == <span class="hljs-literal">undefined</span>) ? y : x<br>&#125;<br><br><span class="hljs-keyword">var</span> x = nullishAssignment(<span class="hljs-literal">null</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// =&gt; 8</span><br><span class="hljs-keyword">var</span> y = nullishAssignment(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">// =&gt; 4</span><br></code></pre></td></tr></table></figure><p>在结束之前，让我们使用三元运算符来重构前面示例中的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPlansWhenUndefined</span>(<span class="hljs-params">plans, location, budget</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> newPlans =<br>    plans.tuesday?.location === <span class="hljs-literal">undefined</span><br>      ? &#123;<br>          ...plans,<br>          <span class="hljs-attr">tuesday</span>: &#123; <span class="hljs-attr">location</span>: location ?? <span class="hljs-string">&quot;Park&quot;</span>, <span class="hljs-attr">budget</span>: budget ?? <span class="hljs-number">200</span> &#125;,<br>        &#125;<br>      : <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Plans have already been added!&quot;</span>);<br>  newPlans ??= plans;<br>  <span class="hljs-keyword">return</span> newPlans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在已经了解了这些操作符的基本原理。如果您对构建这些示例感到鼓舞，请在这里了解更多关于这些操作符的信息。Cheers ！</p><blockquote><p>原文地址：<a href="https://javascript.plainenglish.io/4-powerful-javascript-operators-youve-never-heard-of-487df37114ad">https://javascript.plainenglish.io/4-powerful-javascript-operators-youve-never-heard-of-487df37114ad</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>聊聊关于如何选择offer</title>
    <link href="/index.php/archives/337/"/>
    <url>/index.php/archives/337/</url>
    
    <content type="html"><![CDATA[<p>前阵子我们组大量招人，看到一些候选人拿了好几个 offer 摇摆不定，一直在纠结；也有不少读者私下跟我询问怎么选择；另外就是知乎上，我回答了一个 蚂蚁和字节怎么选的问题，阅读量比较高，所以也经常有人问我这个问题。</p><p>所以想写篇文章来聊一聊这个问题。</p><blockquote><p>最多的就是字节和阿里怎么选 ♀️</p></blockquote><p>我去年换工作的时候也拿了好几个 offer (蚂蚁、字节、滴滴、拼多多、酷家乐)，当时也有过一阵子的纠结，觉得这个公司这里好，那个公司那里好，现在回想起来有点幼稚。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我之前呆的公司是蘑菇街，一家比较年轻的公司，压力不大，每天基本认认真真敲个四个小时左右代码就可以完成工作，每天晚上大概 7 8 点下班。</p><p>在蘑菇街主要是做平台服务，主要是负责一些运营的后台系统，所以不存在着倒排需求，基本上都是正排，在完成自己的工作以后，就有大量的时间去学习一些新知识。</p><p>但是由于业务比较简单，所以很多新知识无法真正用到项目里，感觉自己的上限有所限制，所以一直有一个想去大公司，可以有更多可能的公司。</p><p>具体原因见： <a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p><h2 id="我是怎么选的"><a href="#我是怎么选的" class="headerlink" title="我是怎么选的"></a>我是怎么选的</h2><blockquote><p>以下内容来自于我在知乎的回答：蚂蚁金服 VS 字节跳动的 Offer 怎么选择? - 桃翁的回答 - 知乎<br><a href="https://www.zhihu.com/question/394340089/answer/1251264179" title="https://www.zhihu.com/question/394340089/answer/1251264179">https://www.zhihu.com/question/394340089/answer/1251264179</a></p></blockquote><p>我之前也有过这样的迷惑，也是最近吧，由于公司裁人，逼得我不得不去面试，面过了五家不差的公司(蚂蚁、字节、拼多多、滴滴、酷家乐) ，除了拼多多都是杭州的，因为我目前是在杭州的，所以杭州岗位比较多。</p><p>当时在选 offer 的时候令我比较纠结的也是字节和蚂蚁，最后选择了蚂蚁，说一下我的选择逻辑吧，希望能给你一些参考。</p><p>1 . 薪资方面。阿里在 P7 以前的薪资是没办法和字节比的，理论上字节待遇会比蚂蚁好，我也是，但是很多人在字节入职即巅峰，涨薪比较少，我了解过，字节绩效好或者晋升才有涨薪，如果绩效仅仅是达到期望基本不会涨薪，但是阿里会有普调，所以如果干几年薪资应该会差不多。另外薪资方面就是年终奖的问题，据我了解阿里的激励会比字节激励的比较多，对于 3.75 加 高潜的同学年终奖将异常的高，而且还会有股票和期权。</p><p>base 上字节是好于蚂蚁，年终奖蚂蚁好于字节，总体薪资我觉得字节还是会优于蚂蚁的，毕竟字节还有加班费和房补。</p><ol start="2"><li><p>背书方面。蚂蚁背靠阿里这座大山，我征询过我身边值得相信的一些大佬，大部分人还是觉得蚂蚁的背书是要大于字节的，就是觉得蚂蚁比字节难进，以后从蚂蚁出来和字节出来，蚂蚁更有优势一点。</p></li><li><p>团队方面。蚂蚁杭州总部，字节是分部。当时我在的团队 leader 是在北京的，我是觉得老板毕竟在北京，虽然每个月会来分部带两天，但是总归还是没有老板在身边这么了解自己，所以在绩效方面我觉得蚂蚁是有优势的。另外我在蚂蚁的老板是我上一家公司的老板，比较熟悉，也给蚂蚁加了不少分。</p></li><li><p>加班程度。蚂蚁很累，累的程度不必字节的大小周差。</p></li></ol><p>我的回答可能倾向于蚂蚁一点，因为我的最终选择是选择了蚂蚁，所以会觉得蚂蚁更好，因为我工作年限也不到 2 年，所以更看重<strong>成长和背书</strong>，我觉得在蚂蚁带来的成长会比字节多。如果仅仅看重薪资的话可能直接选 拼多多 了。</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>我们往往活在对未知的恐惧，害怕对未来预测的偏差，所以才不知道如何选择。我们往往什么都想要，或者说什么都不舍得放弃，所以才不知道如何选择。其实，<strong>只要我们清楚自己最想要的是什么，做减法就可以了</strong>。必须做减法，才能做选择。</p><p>可以这么去做：</p><ol><li>行业、公司、团队、文化、城市、老板、工作内容、工作强度…把你想得到的维度都列下来</li><li>然后就开始划除，一个个划掉。</li><li>最后剩下的那一到三个就是你真心不能放弃的，看看哪个机会最符合或接近符合，就是哪个。</li></ol><p><strong>每个人的境况不同，能做出的选择自然不同。所以，不要轻易地去为别人做决定，随意地去评价别人的决定。毕竟，你不傻，别人也不傻。</strong></p><p><strong>无论今年几岁，我们都要尽量做出属于自己的选择，即使这个选择不完全是自己的真心，但真心一定要有。</strong></p><h2 id="一些忠告"><a href="#一些忠告" class="headerlink" title="一些忠告"></a>一些忠告</h2><ul><li><strong>自己想要什么最重要。</strong></li><li><strong>刚开始工作 base 差个两三 k 不重要。</strong></li><li><strong>工作不久的成长很重要。</strong></li><li><strong>不要完全听别人的，包括你心中的大佬，别人的意见只能当做参考，不能作为答案。</strong></li><li><strong>选了就不要后悔，因为说不定其他选择也跟你想象的不一样。</strong></li><li>如果能有多个选择，证明你在这个行业还是比较优秀的，但是也<strong>不要骄傲，当你到了跟你一样的公司去的时候，你会发现周边比你优秀的人不要太多。</strong></li></ul><p>最后希望每个人都能拿到满意的 offer，选择自己最想去的公司。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27342350" title="Offer 怎么选？这绝对是个问题。">Offer 怎么选？这绝对是个问题。</a></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>职场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何应用 SOLID 原则在 React 中整理代码之开闭原则</title>
    <link href="/index.php/archives/336/"/>
    <url>/index.php/archives/336/</url>
    
    <content type="html"><![CDATA[<p>SOLID 是一套原则。它们主要是关心代码质量和可维护性的软件专业人员的指导方针。</p><p>React 不是面向对象，但这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。</p><p>在前一篇文章中，我们讨论了单一责任原则。今天，我们将讨论 SOLID 的第二个原则: 开闭原则。</p><h2 id="本系列其他文章"><a href="#本系列其他文章" class="headerlink" title="本系列其他文章"></a>本系列其他文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/oOcoy5rJwqH939MIOrgaiA">如何应用 SOLID 原则在 React 中整理代码之单一原则</a></li></ul><h2 id="什么是开闭原则？"><a href="#什么是开闭原则？" class="headerlink" title="什么是开闭原则？"></a>什么是开闭原则？</h2><blockquote><p>Robert c. Martin 认为这个原则是面向对象设计最重要的原则。但他不是第一个定义这个概念的人。Bertrand Meyer 于1988年在他的《面向对象软件构造》一书中写到了这一点。他解释了开放/封闭原则:</p><p>软件实体(类、模块、功能等)应该对扩展开放，但对修改关闭。</p></blockquote><p>这个原则告诉您以这样一种方式来编写代码，即您<strong>能够在不更改现有代码的情况下添加其他功能。</strong></p><p>让我们看看我们在哪里可以应用这个原则。</p><h2 id="让我们从一个例子开始"><a href="#让我们从一个例子开始" class="headerlink" title="让我们从一个例子开始"></a>让我们从一个例子开始</h2><p>假设我们有一个 <code>User</code> 组件，其中我们传递用户的详细信息，这个类的主要目的是显示该特定用户的详细信息。</p><p>这是一个很简单的开始。但是我们的生活并不是那么简单。几天后，我们的经理告诉我们系统中有三种类型的用户: <code>SuperAdmin</code>、 <code>Admin</code> 等等。</p><p>它们每个都有不同的信息和功能。</p><h2 id="一个糟糕的解决方案"><a href="#一个糟糕的解决方案" class="headerlink" title="一个糟糕的解决方案"></a>一个糟糕的解决方案</h2><p>第一个也是显而易见的解决方案：在组件中包含一个条件，并根据不同的用户类型呈现不同的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> User = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Name: &#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Email: &#123;user.email&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#123;</span><br><span class="xml">            user.type === &#x27;SUPER_ADMIN&#x27; &amp;&amp;</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Details about super admin<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#125;</span><br><span class="xml">        &#123;</span><br><span class="xml">            user.type === &#x27;ADMIN&#x27; &amp;&amp;</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Details about admin<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>你知道这里出了什么问题吗？</p><p>首先，我们的代码现在是凌乱的。</p><p>其次，如果我们需要其他类型的用户怎么办？</p><p>然后，我们需要进入 User.js，为特定类型的用户添加另一个条件。</p><p>这明显违反了开闭原则，因为我们不允许更改 User 组件内部的代码。</p><h2 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h2><p>在这个场景中我们可以应用两种主要的技术:</p><ol><li>高阶组件(HOC)</li><li>组件组合(Component composition)</li></ol><p>在可能的情况下，最好采用第二种方法，但是在某些情况下，有必要使用 HOC。</p><p>现在，我们将使用 Facebook 推荐的一种技术，称为<strong>组件组合</strong>。</p><h2 id="让我们创建单独的用户组件"><a href="#让我们创建单独的用户组件" class="headerlink" title="让我们创建单独的用户组件"></a>让我们创建单独的用户组件</h2><p>现在，我们需要以这样一种方式设计代码，即不需要在 <code>User.js</code> 组件中添加条件。让我们为 <code>SuperAdmin</code> 创建一个单独的组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;User&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SuperAdmin = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> This is super admin user details<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，另一个是针对 <code>Admin</code> 用户的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;User&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Admin = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> This is admin user details<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们的 App.js 文件变成了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> Admin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Admin&#x27;</span><br><span class="hljs-keyword">import</span> SuperAdmin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SuperAdmin&#x27;</span><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> = (<span class="hljs-params"></span>) =&gt;</span>&#123;<br>  <br>  <span class="hljs-keyword">const</span> user = &#123;&#125;<br>  <br>  <span class="hljs-keyword">const</span> userByTypes = &#123;<br>    <span class="hljs-string">&#x27;admin&#x27;</span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Admin</span> /&gt;</span></span> ,<br>    <span class="hljs-string">&#x27;superadmin&#x27;</span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SuperAdmin</span> /&gt;</span></span><br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &lt;div&gt;<br>    &#123;userByTypes[<span class="hljs-string">`<span class="hljs-subst">$&#123;user.type&#125;</span>`</span>]&#125;<br>  &lt;div/&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以根据需要创建尽可能多的用户类型。我们针对特定用户的逻辑是封装的，因此我们不需要为了任何额外的修改而重新检查代码。</p><p>有些人可能会说，我们正在不必要地增加文件数量。当然，您可以暂时保持原样，但是随着应用程序的复杂性增加，您肯定会感到痛苦。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>SOLID 是一套原则。它们并不是强制性的，您必须应用于每个场景。作为一个经验丰富的开发人员，您应该在代码长度和可读性之间找到一个很好的平衡。</p><p>要过分执着于这些原则。事实上，有一句名言可以解释这些情况:</p><blockquote><p>Too Much SOLID</p></blockquote><p>所以知道这些原则是好的，但是你必须保持平衡。对于一个或两个额外的字段，您可能不需要这些组合，但是将它们分开肯定会有长远的帮助。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解这些原则会让你走很长的路，因为在一天结束的时候，一段好的代码才是最重要的，而且没有单一的方法来做事情。</p><blockquote><p>本文为译文，原文链接：<a href="https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40">https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理清业务团队开发和业务的关系</title>
    <link href="/index.php/archives/335/"/>
    <url>/index.php/archives/335/</url>
    
    <content type="html"><![CDATA[<p>关于开发是否应该深入了解业务，听到两种我觉得不正确的类型：</p><ol><li>「我是开发，我就做好开发就行了，业务交给产品和运营同学」。<strong>不懂业务，完全不想了解型。</strong></li><li>「懂业务之后就可以跟产品 PK 了，方便砍需求」。<strong>懂业务，目的不正确型。</strong></li></ol><p>我的观点是要想当一个优秀的开发者，<strong>必须懂业务，不是为了跟产品 PK，而是为了预判未来的发展方向，好指导自己写的代码可以适应未来更久的时间。</strong></p><h2 id="懂业务，目的不正确型。"><a href="#懂业务，目的不正确型。" class="headerlink" title="懂业务，目的不正确型。"></a><strong>懂业务，目的不正确型。</strong></h2><p>作为一个开发，不知道多少人经常会在耳边听到这么一句话：<strong>多了解业务，多了解业务</strong>。</p><p>但是大部分情况下并没有告诉你为啥要了解业务。</p><p>可能有些人心里会有这么一个答案：懂了业务可以在需求评审的时候可以<strong>跟产品 PK</strong>，指出他的需求不合理，然后给出一个合理的方案，这就是你对于业务的价值，然后就可以体现你的业务思考了；另外对于你觉得不合理的需求，还可以砍掉。</p><p>这是我听到最多的关于为什么开发要懂业务的观点了，我以前也是这么认为的，但是当我真正的作为一个业务 owner 之后，逼得我不得不去了解业务，我才觉得这个观点不完全对，方向都是错的。</p><p>上面观点的<strong>核心目标就是跟产品 PK</strong>，把产品作为开发的敌人去看待。现在网上很多这样的调侃，产品和程序员是对立的。</p><p><strong>在产品的眼里，程序员天生就是爱砍需求。</strong></p><p><img src="http://imgs.taoweng.site/2021-05-16-101200.jpg" alt="砍需求"></p><p><strong>而在程序员的眼里，会因为不会砍需求被老板教育，不要啥需求都接，要学会砍需求。</strong></p><p><img src="http://imgs.taoweng.site/2021-05-16-101218.jpg" alt="打架"></p><p>实际上，懂业务不是为了去指导产品设计，<strong>而是为了预判未来的发展方向好指导自己写的代码可以适应未来更久的时间。</strong></p><p>懂了业务之后是去发现<strong>前端的“价值点”</strong>，不是为了跟产品 PK。。。。</p><p>你如果去指导产品做产品，反过来想想如果让产品指导你做开发，那能靠谱吗?</p><p>我很赞同玉伯说的专业度的问题，作为开发就是要在开发的专业度上表现出来，效率让产品业务都觉得不可思议。而不是让你的产品、业务能力表现出来让他们觉得不可思议(不是不行，但是这样很难，先把自己专业的搞好再说)。</p><h2 id="不懂业务，完全不想了解型。"><a href="#不懂业务，完全不想了解型。" class="headerlink" title="不懂业务，完全不想了解型。"></a><strong>不懂业务，完全不想了解型。</strong></h2><p>另外还有一些是基本不怎么了解业务，就喜欢专研技术，这种想法基本是工作年限不超过三年的同学。刚毕业，对业务没有什么感知，觉得做技术的技术才是王道，整天喜欢研究各种新技术，处于一种被动接需求的状态。</p><p>这种情况就很容易在晋升的时候无法说清楚业务价值，到底自己做的东西有什么用，给公司带来了什么价值，因为在做需求的时候本来没有去思考过业务价值，所以没办法形成闭环，仅仅只是零散的需求。</p><p>实际上，我们应该这样做，在业务的背景之下，我们可以主动的<strong>发现问题、定义问题、解决问题、优化效果，拿到结果。</strong>这才是创作个人业绩的正确路线。</p><p>如果不懂业务，怎么将技术放到业务里去？不放到业务里去怎么体现技术的价值？</p><p>你不能光讲我做了一个什么东西，这个东西多么多么好，这个业务价值如果没有体现出来，那就是没用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面分析了两种思维模式的差别，以及我觉得正确的思考方向。</p><p>作为一个在业务团队的开发者，我们做一件事的时候，需要时刻提醒自己，要想清楚三个问题：</p><ol><li><strong>弄清楚，为什么做这件事？做这件事的价值是什么？</strong></li><li><strong>去思考，如何做这件事？</strong></li><li><strong>完成后的产出是什么？明确衡量标准。</strong></li></ol><p>你们觉得作为一个业务团队的开发，业务和技术的关系应该是什么样的呢？</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>观点与感想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在蚂蚁工作是一种什么样的体验(一)</title>
    <link href="/index.php/archives/333/"/>
    <url>/index.php/archives/333/</url>
    
    <content type="html"><![CDATA[<p><strong>大家好，我是桃翁！</strong><br>之前有小伙伴留言让我聊聊「希望聊一些在大厂工作是什么体验，想听如何融入，如何适应，如何成长的规划，遇到过的哪些比较棘手的问题和怎么处理的，期待」。</p><p>他这里这么多问题，我准备每个问题都写一篇文章来聊，首先咱们要聊的就是「大厂的工作体验」。</p><h2 id="身边牛人多"><a href="#身边牛人多" class="headerlink" title="身边牛人多"></a>身边牛人多</h2><p>可能很多想去大厂的同学，第一驱动力觉得大厂肯定很多大佬，然后进去了可以带带自己。</p><p>其实这句话不全对，也别抱太大希望，进来了可能跟你的想法是不一样的。<br>我的体感是：前半句是对的，大厂里确实很多牛人，但是不会带你的，或者说不是你想象中那么带。</p><p>在阿里这边一个新同学刚进来的时候，会在组内分配一个师兄，来协助你顺利度过试用期。但是不是那种事无巨细的关注你的那种，大部分时间师兄每天也很忙，一个新人来了还要帮你解决问题，所以师兄就会更忙了，所以师兄主要是帮你解答一些问题。</p><p>再说说身边其他的牛人，牛可以很多方面的：</p><p>比如 <strong>学校牛</strong>，在杭州这边浙大的比较多，我们组才 12 个人就有三个浙大的，还有在国外上大学的。</p><p><strong>网红</strong>，可以接触到很多之前只能在知乎、或者一些大会里才能看到或者听说的一些大牛，来了之后就可以见到，甚至面对面交流，每次交流都会受益匪浅，比如我在蚂蚁体验技术部就可以接触到玉伯、偏右这种超级前端网红。</p><p><strong>技术牛，</strong> 不管是 P5、P6、P7 哪个层级的，你都会发现每个人在一个甚至多个方面技术很厉害，说两个我们组的 P5，工作才一年多，早已经是 React 或者微前端方面的专家了，更高层级的那就更不用说了。</p><p>总之，大厂里有非常多的优秀的人，意味着你有很多可以学习的榜样，如果有一些技术上的问题，以前可能只能在开源项目的 issue 上提问，现在你可以通过钉钉甚至直接面对面的进行交流。</p><p>但是我还是秉承着一个观点，<strong>身边的人优秀，并不意味这自己优秀，也没人会主动带着你变成优秀的人，需要自己主动去跟他们学习，让自己成为别人眼中优秀的人。</strong></p><h2 id="做项目成就感强"><a href="#做项目成就感强" class="headerlink" title="做项目成就感强"></a>做项目成就感强</h2><p>既然是大厂，不管是员工和用户相对都比较的多，做的东西反馈也会很多，不管是好的还是差的，都能感觉到有很多用户在使用，能感觉自己再为这么多人服务，能获得价值感。</p><p>像我现在做的项目虽然是给内部小二(小二就是内部员工)用的，但是每天 UV 也有好几千，PV 也是上百万的，这跟我之前在上家公司做的内部系统就不太一样，之前做的东西不管好还是不好，没有什么人反馈，所以总是在找需求做，做出来也不知道有价值，存在感就比较低。</p><p>如果能做 C 端用户的项目，比如像五福、双十一、双十二这种运营活动，虽然过程很艰苦，但是我相信做完了之后一定是满满的自豪感。</p><p>做项目的成就感就来自于给自己、给别人带来了价值，能服务别人，如果你感受不到这份价值，这个项目估计不久就凉了。。。</p><h2 id="压力大"><a href="#压力大" class="headerlink" title="压力大"></a>压力大</h2><p>我以前在蘑菇街的时候每天正常作息上下班，基本没在工作上感受到过压力。</p><p>但是在蚂蚁无处不在的压力，有时会把自己压得喘不过气，不过大部分时候会把压力当做动力，努力向前。</p><p><strong>一方面来自于项目压力</strong>，据我了解，在蚂蚁的业务团队相对于技术团队来说会忙一些。我们组现在主要是做业务，我们这边发布频率基本上一周一个迭代，一个迭代里可能还包含好几个需求，布频率极其高，项目周期又都很紧。</p><p>偶尔还有项目紧急到需要倒排工期，就是不管你怎么搞，就是要在某一天上线。</p><p><strong>另外一方面来自于周围同事压力</strong>，前面也说了，周围的牛人很多，每个人身上你都能发现比自己优秀的地方，比自己级别低的、一个级别的要想着不要被别人超越，比自己级别高的，需要考虑怎么才能跟他们一样优秀。<br>对于项目压力大的正反馈就是逼着自己去做一些可以提效的技术方案，对于周围同事压力正反馈就是逼着自己去像他们学习，让自己变得越来越优秀。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次主要聊的是环境和项目上的感受，下一篇会介绍一些关于技术上的一些体验。如果你之前没呆过大厂，你可以聊聊你想象的大厂是什么样子。如果你之前在待过，或者现在正在大厂里，可以聊聊你的感受是什么。</p><p>同一个环境可能由于自己的心态不同，感受也会有差别，我只是分享我的感受，希望给你带来帮助。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蚂蚁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MWeb 使用体验总结</title>
    <link href="/index.php/archives/331/"/>
    <url>/index.php/archives/331/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>工欲善其事，必先利其器。</p></blockquote><p>一个称心如意的工具会令人提升我们的效率，节省时间。今天我介绍的这款写作、记笔记软件就是：<a href="http://zh.mweb.im/"><strong>MWeb</strong></a>。</p><blockquote><p>温馨提示两点,如果这两点不太能接受的，可能下面的内容不太适合你:</p><ol><li>该软件支持苹果生态</li><li>该软件是付费软件，是买断型的，不是订阅型的。</li></ol></blockquote><p>笔者曾经写过一篇基于 typora 写作的环境配置文章：<a href="https://mp.weixin.qq.com/s/Tz3JKu_-MvZ2xXAvouoxPw">一套可以提升写作效率的写作环境配置</a></p><p>相比于 typora，我觉得 MWeb 有这三个优势：</p><ol><li><p><strong>免费的图片上传到图床的功能</strong>。 如果用 typora 图片如果要上传到图床，需要结合 iPic，iPic 是付费的，一年是 60 元，具体操作步骤可见上面的文章。MWeb 本地上传图片服务是内置到软件里的，所以这笔每年 60 元的费用可以省掉。</p></li><li><p><strong>发布服务</strong>。 支持发布到 Wordpress、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记、Blogger、Medium、Tumblr。支持 Metaweblog API 协议的服务 这个功能特别强大，后面会详细介绍。</p></li><li><p><strong>苹果整个生态都支持。</strong> 就像官网介绍的</p><blockquote><p>MWeb for Mac, iPad and iPhone<br>专业的 Markdown 写作、记笔记、静态博客生成软件</p></blockquote><p>意味着电脑，手机，平板数据是可以同步的，这点 typora 是完全不支持的。</p></li></ol><p>不过 MWeb 相对于 typora 的一个劣势就是<strong>不支持实时预览</strong>，如果实时预览是强需求的，MWeb 就不适合你了。</p><p>以上三个优势是我从 typora 转到 MWeb 的主要原因，下面我会详细介绍一下我认为 MWeb 的五大特性，希望能给你帮助。</p><h2 id="特性一：图床功能"><a href="#特性一：图床功能" class="headerlink" title="特性一：图床功能"></a>特性一：图床功能</h2><p>图片上传服务（图床）支持 Imgur、七牛云、又拍云、阿里云、腾讯云和自定义的图床服务，基本上主流的图床服务都是支持的。</p><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139024358516.jpg" alt="-w613"></p><p>我用的是七牛云的，可以免费领 10 个 G 的空间，这个我之前在<a href="https://mp.weixin.qq.com/s/Tz3JKu_-MvZ2xXAvouoxPw">「一套可以提升写作效率的写作环境配置」</a>也说过。</p><p>这功能真的是太好了，之前我用 iPic 还每年 60 元，有了这个真可以省挺多钱的。</p><p>顺便再说下这个功能对我为啥这么重要，对于我来说写一篇文章可能会发布到多个平台去，公众号、知乎、掘金等等，每个平台自己的图床是不能在其他平台访问的，所以图片这种东西最好还是放在自己的空间里。</p><h2 id="特性二：发布服务"><a href="#特性二：发布服务" class="headerlink" title="特性二：发布服务"></a>特性二：发布服务</h2><p>使用 MWeb 可以把文档发布到 Wordrpess、支持 Metaweblog API 协议的服务、印象笔记、Blogger、Medium、语雀、为知笔记等网站。</p><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139024553338.jpg" alt="-w588"></p><p>其中<strong>支持 Metaweblog API 协议的服务</strong> 是非常有用的，很多技术博客网站也都是支持 Metaweblog API 的。</p><p>下边列出国内网站中常用的 Metaweblog API 地址。</p><ul><li>CSDN： <a href="http://write.blog.csdn.net/xmlrpc/index">http://write.blog.csdn.net/xmlrpc/index</a></li><li>博客园（cnblogs)：<a href="http://www.cnblogs.com/Blog%E5%90%8D(%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D)/services/metaweblog.aspx%E3%80%82%E5%85%B6%E4%B8%AD">http://www.cnblogs.com/Blog名(你的用户名)/services/metaweblog.aspx。其中</a> Blog 名 请换为您的博客名。cnblogs 的博客后台设置，拉到最下面，也可以找到这个网址。比如说我的是 <a href="http://rpc.cnblogs.com/metaweblog/Seachal">http://rpc.cnblogs.com/metaweblog/Seachal</a> 两者网址不同，但是效果一样。</li><li>开源中国（oschina)：<a href="https://my.oschina.net/action/xmlrpc">https://my.oschina.net/action/xmlrpc</a></li><li>51cto：<a href="http://imguowei.blog.51cto.com/xmlrpc.php">http://imguowei.blog.51cto.com/xmlrpc.php</a></li><li>网易（163）：<a href="http://os.blog.163.com/word/">http://os.blog.163.com/word/</a></li><li>typecho 博客：<a href="http://xx.com/action/xmlrpc%EF%BC%8C%E5%85%B6%E4%B8%AD">http://xx.com/action/xmlrpc，其中</a> xx.com 为你的博客网址。如果 typecho 还没有进行 url rewrite，则为 <a href="http://xx.com/index.php/action/xmlrpc">http://xx.com/index.php/action/xmlrpc</a></li></ul><p>意味着你只需要按照这样设置好。<br><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139042733794.jpg" alt="-w583"></p><p>后面就可以不用把文章拷贝到其他的网站上去发布，只需要在 MWeb 里点击发布就行了。</p><h2 id="特性三：自定义预览"><a href="#特性三：自定义预览" class="headerlink" title="特性三：自定义预览"></a>特性三：自定义预览</h2><p>这个功能可以简单的理解为就是可以自己写 CSS 样式来定制主题，这个功能在 typora 里也是有的，但是这不妨碍着依然是一个非常好的功能，每个人对美的定义不一样，默认样式总有人不喜欢。</p><p>比如语雀我听好多人吐槽过就是由于颜值太低了，所以没用，其实功能还是挺强大，所以这种个性化的功能还是很重要的。</p><p>顺便说下我没用语雀作为我的主要的写作软件的主要原因就是客户端体验太差了，另外对于移动端几乎没有支持。</p><h2 id="特性四：多端支持"><a href="#特性四：多端支持" class="headerlink" title="特性四：多端支持"></a>特性四：多端支持</h2><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139052138079.jpg" alt="-w701"></p><p>MWeb 是支持平台三件套的(电脑、手机、平台)，数据可以通过 iCloud 去存储。</p><p>这也是我入手的一个原因吧，因为我有写日记的习惯，我是那种随时想到啥就马上要记录下来的，所有有很强的移动端记笔记的需求，而且要和 PC 端同步，之前我一直用的滴答清单，因为平常做 GTD 都是用的滴答清单，刚好滴答清单之前也支持了 markdown 语法。</p><p>但是滴答清单写文档的体验还是略差了一点，基本不支持图文编排，markdown 支持得也比较弱，MWeb 很好的解决了这个痛点。</p><h2 id="特性五：静态网站"><a href="#特性五：静态网站" class="headerlink" title="特性五：静态网站"></a>特性五：静态网站</h2><p>MWeb 不仅可以记笔记，写作，还有一个卖点就是静态博客生成，这对于没有博客的同学来说确实是一个福音。</p><p><img src="https://cdn.mwebapp.cn/mwebsite/2019/12/15761345831970.jpg" alt="-w600"></p><p>这种方式其实对于静态博客来说是最好的方式了，源文件云端存储，生成的静态文件在 MWeb 里可以定制脚本发布到静态资源服务器上(比如 github page)。</p><p>写完文章之后只需要一键就可以发布。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这么多年来用过挺多笔记软件，写作软件的，给我的感受就是没有最好，只有最适合。</p><p>比如 notion 吧，功能强大，但是访问速度慢，PC 客户端和移动端基本废了；语雀吧，功能也还够用，客户端和移动端支持得也不行；typora 吧，又支持 PC 客户端；还用过有道云笔记、bear、印象笔记等等，都不能满足我的需求。</p><p>没有一个软件满足所有人的需求，还是需要根据自己的需求去挑选最合适的软件，不过可能到最后还是没有一个软件满足你的所有需求，还需要几个软件组合，我觉得这都没关系，最重要的还是写的内容，<strong>软件毕竟只是个工具，里面记的内容，你整理的过程才是最关键的</strong>。</p><p>经过这次对 MWeb 的深度体验，算满足了我大部分的需求了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>写作</tag>
      
      <tag>笔记本</tag>
      
      <tag>MWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桃翁2020年度总结</title>
    <link href="/index.php/archives/326/"/>
    <url>/index.php/archives/326/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020 年真的是不平凡的一年， 疫情夺走了很多人的生命，还夺走了我的工作(公司因为疫情被迫裁员)，所以今年换了工作来到了蚂蚁，在蚂蚁的工作经历跟之前在蘑菇街完全不一样。。。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>来蚂蚁这半年我觉得在工作上的成长比我之前在蘑菇街一年半的成长都还多，经历比较丰富。</p><p>阿里一直都有拥抱变化的文化，我来大概五个月的时候就换了三个主管，经历了好几次的组织架构变动，我刚进来的时候同组的同事（之前组内大概 12 人）到现在还跟我一组的仅剩一名。</p><p>不过随着每一次的变动，我的分工也越来越清晰，从最开始哪里缺人就去哪里，再到负责一块模糊的业务线，再到一个人带着 3 个合作伙伴负责一整个业务线，再到现在有了 3 个正式加 6 个合作伙伴的阵型。</p><p>作为整个业务线的 owner 不仅要接需求还要去预测业务未来的走向，这样才能在技术上做好提前的准备，当业务真的来了，才能快速的支持。这个是我在试用期答辩的时候面试官给到我的期望，这个我在之前试用期结束后有写过。</p><p><a href="https://mp.weixin.qq.com/s/AJjyGV2NG-CyvCPWUtTLFQ">原来我是个业务性选手？？？？</a></p><p>只不过那个时候我只是觉得这个话说得很对，并没有体感，但是当我在负责整块业务的，以及带着一群人在做的期间，作为业务 owner 必须得去思考这些了，因为我们这里业务发展得很快，虽然我们业务团队成员变多了，但是需求也越来越多，所以如果不提前去做一些业务上的预测，技术上的沉淀，当业务发展再快点，需求再多一些我们目前的这些人就消化得很吃力，甚至吃不下，这是我今年非常大的一个收获。</p><p>对于这个收获其实我之前想过我为什么可以得到，我刚开始把原因归结到了运气，因为我能有机会负责一条业务线的东西是由于我的师兄以及其他大部分同事都走了，现有的业务只能由留下来的人去承担，所以我当时想到了那些得到晋升或者 375 的同学是不是运气好，可以做到好的业务或者技术。但是又细想如果机会给你了，如果没有把它当机会，而且他这块重重的东西当做负担，或者平常心看待，可能也做不出什么优秀的成果。</p><p>但是一件平凡的事情如果交给一个优秀的人去做，大概率还是会做出优秀的东西。</p><p>所以最后我得出的结论是<strong>运气可以让一个准备好了，有实力的人加速成功，但不会让一个平凡的人获得成功。</strong></p><h2 id="学习与写作"><a href="#学习与写作" class="headerlink" title="学习与写作"></a>学习与写作</h2><p>当我在准备写总结的时候，我本以为今年读的书(去年 20 本)会比去年要少，没想到今年还略多一点，读完的都有 29 本了，但是我明显能感觉到今年花在读书上的时间变少了，特别是在入职蚂蚁之后，属于自己的时间更少了。</p><p>我想可能是渐渐的找到了读书的方法，越读越快了吧。</p><p>下面是我今年读书列表：<a href="https://book.douban.com/people/crazylxr/" title="豆瓣主页">豆瓣主页</a></p><p><img src="http://imgs.taoweng.site/2021-01-24-105121.jpg"></p><p><img src="http://imgs.taoweng.site/2021-01-24-105115.jpg"></p><p>在写作方面今年公开文章产量就很低了，只有 13 篇，基本都是上半年写的，下半年入职蚂蚁之后就基本没怎么写了，一方面是因为确实工作太忙了，另一方面需要在公司内部写不少的文档。</p><p>文章列表见博客：<a href="http://www.taoweng.site/index.php/archives.html" title="前端桃园">前端桃园</a></p><p><img src="http://imgs.taoweng.site/2021-01-24-105119.jpg"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>很遗憾今年对技术没有做什么深的研究，主要是业务太忙，把我对技术的追求抹平了，整天就想着如何能把业务支持下去。</p><p>来蚂蚁半年没写过 React，大部分时间写钉钉小程序和支付宝小程序，另外还写了将近两个月的云凤蝶。</p><p>在我没怎么接触过小程序前，对小程序有刻板的印象，总觉得小程序限制太多，很简单，没有什么意思，当然也不知道其原理，所以对小程序比较抵触。</p><p>但是当我写了两三个月之后，对小程序了解得越来越多，但是另一方面发现自己对小程序了解得越来越少，为什么这么说呢？</p><p>当我还没怎么接触小程序的时候可能想到的就只有 小程序的语法是什么样的，小程序是怎么运行的，但是写得越来越久，发现自己以前的视野太小了，整个小程序生态还有很多东西可以去研究，越写越发现自己不会的越来越多，这些不知道反而让我对小程序产生了兴趣，感觉可以有新的东西值得去研究。</p><p>比如小程序他是怎么运行的，跟原生、H5 之前的区别在哪里，关联是什么，view 层是怎么渲染的，逻辑部分的 js 是怎么执行的，与客户端，容器是怎么通信，怎么打包的，怎么编译的，编译出来的东西又是什么，怎么发布上架的，以及什么情况下使用小程序技术栈、什么情况下使用 h5 技术栈，等等等，这些没有搞明白的问题深深的让我对小程序产生了兴趣。</p><p>所以明年在技术上的一个目标就是深入小程序。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h3><p>生活方面最令我开心的就是女朋友在 11 月份从上海辞职，来到了杭州，结束了 3 年的异地恋，每天下班后有个人在家里等的感觉真好！</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p><strong>西安旅游</strong></p><p>国庆去西安旅游了，在去西安之前我们还先去南京溧水参加了【咪豆音乐节】。这次是准备得最充分的一次，还做了一些<a href="https://www.notion.so/2020-087ea699aca34c3d8e87230f3ff7f065" title="攻略">攻略</a>。</p><p><img src="http://imgs.taoweng.site/2021-01-24-105120.jpg"></p><p><img src="http://imgs.taoweng.site/2021-01-24-110623.png"></p><p><strong>重庆 Outing</strong></p><p>重庆三峡博物馆</p><p><img src="http://imgs.taoweng.site/2021-01-24-110536.png"></p><p><strong>江景：重庆洪崖洞夜景</strong></p><p><img src="http://imgs.taoweng.site/2021-01-24-110601.png"></p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a><strong>健身</strong></h3><p>今年开始有了到健身房健身的习惯，非常感谢 yixi 带我去健身房教我健身，我以前以为健身器材是非常简单的东西，一进去就知道怎么用，接触了过后才知道健身其实还是挺有学问的，不同的健身器材有多种不同的用法，每种用法锻炼的部位还不一样，所以可以根据自己想健身的部位去筛选器材和器材的使用方式。</p><p>我大概从 9 月份初的时候第一次去的吧，一直到现在也是断断续续的，有时间就天天去，没时间就偷懒了，由于我们是中午去，所以时间还挺苛刻的，如果中午有会议啥的，很可能时间上赶不上了。</p><p>不过从开始第一天到现在我还是能明显得感觉到自己力量的提升，粗略的估计手 腿 肩的力量提升有 30%左右，胸部就 15-20%的样子，总感觉胸部的力量比较弱，明年多练练胸。</p><h3 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h3><p>2020 年在投资上最大的成长是学到了<strong>「打新」</strong>，我主要打的是港股，因为港股相对于 A 股来说中签率高，打新的赚的几率会比美股的大，我大概是在 11 月份才办好香港卡，入金到了富途，才开始打新，打了十几次才中了 3 次，每次收益都超过 15% ，但是在富途现金打新每次会收 50 的手续费，新手打新还是建议找一些现金打新免手续费的，比如艾德、华泰等。</p><p>其他股票、基金就没什么也没什么好总结的。</p><h2 id="2021-目标"><a href="#2021-目标" class="headerlink" title="2021 目标"></a>2021 目标</h2><ul><li>在社区里输出至少 10 篇文章。</li><li>平均每周至少去健身房 2 次。</li><li>旅游两次。</li><li>列太多也完不成，不列了。。。。。。</li></ul>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原来我是个业务性选手</title>
    <link href="/index.php/archives/324/"/>
    <url>/index.php/archives/324/</url>
    
    <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>前几天我试用期转正答辩了，老板也给过了，给到我的评价大概是：<strong>业务型选手，接下来一两年很关键，如果能够在业务中深入挖掘，会是个好苗子，否则就比较平了。</strong></p><p>这个评价其实我还是没想到的，或者说我之前根本没想过结果。</p><p>其实我从大学毕业以来，都觉得自己是个<strong>技术型选手，</strong>之前在蘑菇街的时候我也是按照技术路线走的。在蘑菇街的时候工作不是很忙，所以也有时间去研究技术，也乐于分享然后才经常写文章，才做了公众号。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>不过在我年初的时候，我对技术的追求稍微弱了一点，这是在蘑菇街的时候准备晋升答辩过程中的一些变化。我的前辈呀、主管呀、HR 呀，在我准备 PPT 的期间都不断的给我灌输，<strong>你做的东西到底有什么业务价值？</strong></p><p>在这期间，我的 PPT 找了好几位前辈包括自己的主管都 review 过，也给他们进行试讲，每次的给到我的建议都会有，要注重业务价值。</p><p>之后我的脑海里就深深的有了这么一个意识，<strong>技术是为业务服务的，技术的价值源之于业务的价值，而不是技术本身的价值。</strong></p><p>所以我在后面的工作中，会更注重业务价值，在做需求的时候不再去追求高大上的新技术，热技术，而是花更多的心思去<strong>问这个需求的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益。</strong><br>**</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>没想到我把这个意识也带进了蚂蚁，在蚂蚁的工作是非常忙碌的，我后面会写文章记录一下在蚂蚁有多忙，但是现在我只想说一点，反正忙到没时间去折腾新技术，注意是折腾不是学习，因为我在蚂蚁做的东西对于我来说，一直都是新的技术，但是没有时间去专研，学习新技术是为了完成需求。</p><p>在答辩的前三天我还在跟我的老板说，业务太忙了，没时间写总结了，目前只写了一个总结的目录(可能就 50 个字左右)；老板跟我说，在 9 月 2 号前一定要提交总结，不然系统会自动试用期不通过，在那时我快要崩溃了，项目这么急，哪有时间写总结呀，还要答辩。</p><blockquote><p>真的是抽不出时间来写总结，每天加班到凌晨两三点，回家就想睡觉，根本没精力写。</p></blockquote><p>在答辩的前一天晚上，大概 8 点多的时候，其他伙伴在工作的时候，我就抽了大概一个半小时的样子按照我之前的目录写完了，感觉写出来毫无亮点，看起来就是自己的血泪史。反正就当完成任务了，明天毕竟要答辩了，不可能啥都没有吧，然后写完继续改 bug。</p><p>那天我也回去得比较早，大概 12 点回去了。在这个点其实还是有点精力的，我就寻思着，我感觉自己写的总结很 low，没有亮点，给面试官留不下太多的印象。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>回来之后我就思考怎么才能让面试官觉得我做的东西有价值呢？想了半天没想出来，但是突然想到一个点，我当时不知道这个点该不该讲，但是我很想讲，那就是我现在所做业务的大图。我们整个组都在做一个叫 xx 的项目(应该说是一个很大，很复杂的业务，是很多的项目)，每个人都负责其中的一块，我刚开始来的时候就对这个项目很好奇，因为我完全不能理解 xx 这个项目是一个什么样的项目，是用来干啥的。</p><p>甚至在我已经做了两个月的项目之后，我也仅仅只对我自己做的这块了解，对其他的人做的东西不知道有什么关联，但是我还是知道跟我肯定是有关联的，所以其实一直处于一种比较难受的地步，因为我不知道这个项目到底有多大的价值。</p><p>直到我在第三个月做了另外一部分的需求之后，我才慢慢的了解了这个 xx 项目到底是个什么样子的，我们的目标是什么，我们要做成什么样子，我们现在已经有了哪些能力。</p><p>那几天每天上下班的路上我就在思考这些东西，真的是每天想，后面终于想清楚了每个人做的东西之间的关联，感觉很舒服。</p><p>我觉得这个东西对于我来说价值很大，虽然他是纯业务的，或者说根本都不是我一个人做的，但是这真的是我的收获，所以我觉得站在更高的视角去介绍我们组现在做的 xx 业务，我就<strong>画了整个业务架构图，包含了我们组每个人所做的业务以及他们之间的关联。</strong></p><p>然后就去介绍**整个 xx 业务的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益(是不是觉得似曾相识)**，最后再去介绍我做的东西在整个大图的意义的时候就很容易了。</p><p>在答辩的时候我差不多一半的时间都在讲这个，最后也给面试官留下了深刻的影响，说我提供的视角让他学到了新东西，他之前从来没有这么想过。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>最后面试官给到我当面的评价也说到了我是一个善于思考的同学，喜欢去专研业务，还有其他的好的坏的评价，已经记不得了。</p><p>但是最后老板给我的试用期总评里直接说道我是一个<strong>业务型选手，</strong>这是我没想到的。但是我从他的评语中还得出，我在技术上的研究不够，如果后面我不深入业务的话，技术也没研究，那就真的很平了。</p><p>我后面多次思考了一下，我到底应该去做一个业务型选手还是技术型选手呢？我目前的答案是我应该去做业务型选手，因为我的理想是去创业的，感觉业务型选手更适合创业，如果以后想去做 CTO 啥的，还是选技术型选手比较好。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>想一想你们自己是想做业务型选手还是技术型选手呢？欢迎在评论区说出你们的答案，最好能带上理由。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>桃翁在蚂蚁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5 点可以让你提高面试通过率建议(干货)</title>
    <link href="/index.php/archives/323/"/>
    <url>/index.php/archives/323/</url>
    
    <content type="html"><![CDATA[<p>自从我发过几篇关于面试经历的文章，由于我面试结果还不错，所有很多人来询问我一些面试相关的问题， 我这里给到 5 点建议，希望对大家有帮助。</p><h2 id="1-简历里应该惜字如金"><a href="#1-简历里应该惜字如金" class="headerlink" title="1. 简历里应该惜字如金"></a>1. 简历里应该惜字如金</h2><p>简历简历，可以分为<strong>简</strong>和<strong>历。</strong>简，简单简洁之意，历，经历，总体就是<strong>简单</strong>的表达自己的经历。</p><p>我看到一些人的简历写了四、五页，甚至十来页的都有，每个项目把细节都写出来了，甚至还把项目截图给贴在了简历里面，生怕面试官不能理解需求，我建议最多不超过 2 页，亮点能写两页就已经很牛逼了。</p><p>我相信有很多人工作了很多年，经历的项目很多，其实不需要把所有的项目都列出来，**简历里是要展示自己的亮点，牛逼的点，这个亮点、牛逼的点事相对的，相对于自己所做的东西里面的，不是客观的牛逼(如果有当然更好，那必然也是你相对的里面的亮点，不冲突)**。</p><p>这句话意味着两层意思：</p><ul><li>很多人觉得自己的项目没有亮点的问题，因为你是那这别人更高的标准来衡量自己，所以你相对于别人没有亮点，这样你就写不出一份简历。</li><li>多个亮点类似的项目合并，或者只写一个，因为都是为了给面试官展示这一个亮点，写多了就是浪费空间，简历上面的字很珍贵。</li></ul><p><strong>第一层让你的简历有东西可写(增加)，第二层是让你把简历写得更优质(减少)。</strong></p><h2 id="2-简历应该是你设计过的"><a href="#2-简历应该是你设计过的" class="headerlink" title="2. 简历应该是你设计过的"></a>2. 简历应该是你设计过的</h2><p>「设计简历」可能对这个词有点迷惑，可能你第一感觉是设计得好看一点，其实我想表达的设计是一种「圈套」，给面试设计的「圈套」，下面我会举例子让你明白这个「圈套」是什么。</p><p>我举两个点：技术要点和项目经历。</p><p>技术要点(就是自己会哪些技术)和项目经历相信是简历里面必不可少的内容，但是也许你可能忽略了哪些应该写。</p><p>之前我给别人看简历的时候，我就会问他们写的技术点三个问题</p><ol><li>你对这个技术点的掌握程度是什么样的？</li><li>你对这个技术点准备了哪些问题？</li><li>当问到了相关技术点的时候，你能回答到哪个层次？仅仅了解、用过一两次、熟练使用、还是掌握原理。。。</li></ol><p>当你能清楚的回答完这三个问题之后，你对你自己的水平就有了一定的认识，同时你对自己是否符合这个岗位有了一定的判断。我的目的就是让你了解自己的水平，然后才能<strong>针对性</strong>的去复习，查漏补缺，自己心里要有一杆秤，自己把这个知识点掌握到这个程度，能不能胜任这个岗位。</p><p>当你了解了之后，然后根据你自己是否有充足的复习时间，你就可以去设计你的技术要点部分了，只写你准备好了的技术点，这个准备好了不是说掌握得很深才叫准备好了，就算是只能回答几个简单的问题也算是准备好了，就是你想准备，然后自己也去复习了的，这就叫准备好了，这样你在面试的时候才会胸有成竹。</p><p><strong>这就是在套路面试官问你准备好的问题</strong>，因为技术官基本只会问你简历里面提到的技术点，所以自己要对自己简历里面的技术点有充足的准备(把一些常见的面试题刷一些也是非常有帮助的)。</p><p>第二点设计就是对于项目经历部分。项目经历这部分没有人比你更熟悉，所以如果问到项目经历应该是你的地盘，是你给面试官展示你的项目有多牛逼，你在里面发挥了多大的价值，带来了多大的成果，你要非常自信的去给他讲解。</p><p>你的自信来源于什么？你非常了解这个<strong>项目的需求(为什么要做这个项目)<strong>、</strong>项目价值(做了之后怎么样了)<strong>，以及整个项目的</strong>技术方案，架构体系(怎么做的)，最重要的是你负责的或者参与的</strong>。</p><p>同时，你再把你在项目中遇到的一些<strong>难点，和解决方案总结下来，</strong>那么项目这块就是你的主战场了。</p><p><strong>划重点：上面我所说的，最好最好是要准备，也就是说最好你要写下来，然后可以没事儿自己问自己上面的这些问题，然后自己去回答。</strong></p><p>你可能会说，哇，那要准备好多东西哦，所以说啊，项目不用写太多，就把觉得自己最牛逼的、最熟悉的两、三个项目总结下来就够了，在项目这块<strong>比的不是数量，而是质量。</strong><br>**</p><blockquote><p>项目经历这块在面试的时候面试官会问你一些问题，比如一些其他的解决方案，如果当时想到了，或者面完了想到了，记得补充进去。</p></blockquote><h2 id="3-选常用的东西去准备"><a href="#3-选常用的东西去准备" class="headerlink" title="3. 选常用的东西去准备"></a>3. 选常用的东西去准备</h2><p>前端的技能要求很多，就算解决同一个问题的解决方案也会有很多个，比如解决视图的，就有 React、Vue，构建的就有 Webpack、Rollup、Parcel ，React 状态管理也有 Redux、Mbox、unstate 等。</p><p>如果你的脑袋里面都装着这些东西，那么你肯定是复习不完的了，我的建议是把你项目用常用的东西好好准备，尽量不要让面试官把你常用的东西还问倒了，如果你平时用的东西你都没有掌握得好，你觉得面试官会觉得你平时不用的东西掌握好了吗？</p><h2 id="4-准备一份自我介绍"><a href="#4-准备一份自我介绍" class="headerlink" title="4. 准备一份自我介绍"></a>4. 准备一份自我介绍</h2><p>准备一份自我介绍，不是简简单单的准备，而是自己要写下来，然后对着稿子练习一下。可能你会觉得很麻烦，有必要吗？我说两点：</p><ul><li>自我介绍是每个面试官，每场面试都会问的，没有哪个面试题有如此高的频率，100% 中的面试题不值得去好好准备吗？</li><li>上面我说了简历是去套路面试官问哪些东西？而自我介绍就是去套路面试官怎么去问的一个很好的方式，因为往往面试官会在你自我介绍之后，会问几个你自我介绍里面所包含的东西，自我介绍的结尾，也许就是面试题的开始。</li></ul><p>这个一个很好的引导面试官怎么问的方式。</p><h2 id="5-职业规划"><a href="#5-职业规划" class="headerlink" title="5. 职业规划"></a>5. 职业规划</h2><p>职业规划这个，其实也是一个高频面试题，不管是面试官还是 HR，都喜欢问的一个问题，这个题没有标准答案，我说一下我的一些看法。</p><p>职业规划我觉得可以从三个方面去谈：</p><ol><li>我想做什么？(兴趣、价值观等方面)</li><li>我能做什么？(你的知识、技术、经历等方面来支持)</li><li>环境支持我做什么(意味着未来)？(外部环境，公司、团队)</li></ol><p>大致你可以像这样去回答，我的兴趣是 XXX，优势是 XXX，因此我选择了前端，这是一个可以将我的兴趣和工作结合起来的行业，是我非常喜欢的，所以我会很用心对待这个工作。我之前做过 XX，有了 XX 的经验，然后觉得很有意思，想继续深挖(当然你也可以说，我之前一直在做 XXX，以后想换一种 XXX 技术)。近期我打算研究 XXX，后续可以在 XXX 上独当一面，独立负责 XXXX 事务,解决 XXXX 问题。谈到远期规划，我会根据环境的变化，工作内容的变化，以及我自身能力的变化，不断进行调整的。</p><p>讲道理面试官问这个问题无非是想考察这四个点：</p><ol><li>求职者对自我的认知</li><li>求职者对岗位的了解程度，对职业的理解程度</li><li>求职者工作的稳定性</li><li>求职者的上进心、目标感和自我驱动力</li></ol><p>知己知彼，方能百战不殆嘛，看看面试官的考察点，然后针对的去准备。职业规划这个东西不仅仅是为了面试，对自己长远来说都是非常有用的，每个人都希望好好准备下。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章里没有写任何关于技术上的东西，而是重点介绍了如果去准备面试以及要准备哪些东西的策略，这些策略是通用的，无论是前端、后端都应该去准备的东西，看了这篇文章的同学，希望你能找到如意的工作。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蚂蚁、字节、滴滴面试经历总结</title>
    <link href="/index.php/archives/321/"/>
    <url>/index.php/archives/321/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近两篇面试以及离职相关的文章不容错过哦。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EG5HCgz_M1S2Xbky0lgDxg">拼多多和酷家乐面试总结</a></p></li></ul><p>今年面试还是比较顺的，面了五家公司(酷家乐、拼多多、字节、滴滴、蚂蚁)，都过了。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>说一下浏览器缓存</p></blockquote><p>浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</p><p>控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。</p><p>控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><blockquote><p>cookie 与 session 的区别</p></blockquote><p>Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</p><p>详见：<a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a></p><blockquote><p>浏览器如何做到 session 的功能的。</p></blockquote><p>其实就是考察 http 怎么处理无状态是怎么处理的，具体可见 <a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a>里面的答案。</p><blockquote><p>解释一下：csrf 和 xss</p></blockquote><p>XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>怎么防止 csrf 和 xss</p></blockquote><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>跨域的处理方案有哪些</p></blockquote><p>常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></p><blockquote><p>CORS 是如何做的？</p></blockquote><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><blockquote><p>对于 CORS ，Get 和 POST 有区别吗？</p></blockquote><p>其实想考察的就是什么时候会有**预检请求(option 请求)**。</p><blockquote><p>了解 HTTPS 的过程吗？</p></blockquote><p>推荐浪浪的 <a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">深入理解HTTPS工作原理</a></p><blockquote><p>webpack 如何做性能优化</p></blockquote><p>webpack 做性能优化主要是考虑打包体积和打包速度。</p><p>体积分析用 <code>webpack-bundle-analyzer</code> 插件，速度分析用：<code>speed-measure-webpack-plugin</code> 插件。</p><p>打包速度优化瓶子君的：<a href="https://juejin.im/post/5e53dbbc518825494905c45f">玩转 webpack，使你的打包速度提升 90%</a>。</p><blockquote><p>es module 和 commonjs 的区别</p></blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><blockquote><p>react 里如何做动态加载</p></blockquote><p><code>React.lazy</code> ，另外通过 webpack 的动态加载：<code>import()</code> 和 <code>ensure.require</code></p><blockquote><p>动态加载的原理是啥，就是 webpack 编译出来的代码</p></blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p><blockquote><p>笔试题：页面结构包括页头（永远在顶部）、主体内容、页脚，页脚永远在页面底部（不是窗口底部），即内容高度不够时，页脚也要保证在页面底部</p></blockquote><p>常规题，考察基本的布局</p><blockquote><p>笔试题：写 new 的执行过程</p></blockquote><p>new 的执行过程大致如下：</p><ol><li><p>创建一个对象</p></li><li><p>将对象的 _ <em>proto_</em> 指向 构造函数的 prototype</p></li><li><p>将这个对象作为构造函数的 this</p></li><li><p>返回该对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Con, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(Con.prototype)<br>  <span class="hljs-keyword">let</span> result = Con.apply(obj, args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>笔试题：写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3</p></blockquote><p>思路：对于浮点数在底层处理是有问题的，所以目的就是想办法将所以的浮点数转化为整数进行处理，同时乘以一个倍数(A)，然后加起来后再除以这个倍数(A)，这个倍数应该是两个数中最小的那个数的倍数，比如 0.1 + 0.02 ,那么应该同时乘以 100，变为 10 + 2，然后再将值除以 100。</p><blockquote><p>1000000000 + 1000000000 允许返回字符串 处理大数</p></blockquote><p>大数问题就是通过字符串来处理，从后往前加，然后处理进位的问题。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目</p></blockquote><p>项目基本是问：</p><ol><li>项目难点以及怎么解决的</li><li>项目有哪些亮点？</li></ol><blockquote><p>写一个 es6 的继承过程</p></blockquote><p>这个题我觉得出得很好，很考察基本功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个是要实现的方法</span><br>createClass = <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params">sons, <span class="hljs-built_in">super</span></span>)</span> &#123;<br><span class="hljs-comment">// TODO</span><br><span class="hljs-keyword">return</span> fn;<br>&#125;<br><br><span class="hljs-comment">// 这是个 es6 的一个例子，要实现 extends 的功能。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>cons (args) &#123;<br><span class="hljs-built_in">super</span>(args)<br>  <span class="hljs-comment">// xxxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题跟一面的时候思路差不多，只是进位的时候不一定是 1。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><blockquote><p>聊项目</p></blockquote><blockquote><p>写一个防抖函数</p></blockquote><blockquote><p>算法题:<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p></blockquote><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>字节果然是出了名的考算法题比较多的，基本每面都会算法题和编程题，对编程能力比较看重吧。</p><p> 讲道理一面还是比较常规的，二三面因为都是团队 leader 和更高级别的，问的技术细节也比较少了，重点考察一些技术方案和项目的问题。</p><h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><blockquote><p>webpack 原理</p></blockquote><p>大致就是：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><blockquote><p>babel 原理</p></blockquote><p>babel的转译过程分为三个阶段：<strong>parsing、transforming、generating</strong>，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><ol><li>ES6代码输入 </li><li>babylon 进行解析得到 AST</li><li>plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</li><li>用 babel-generator 通过 AST 树生成 ES5 代码</li></ol><blockquote><p>虚拟 DOM 的理解</p></blockquote><p><a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a></p><blockquote><p>项目里如何做的性能优化</p></blockquote><p>这个跟我的项目相关。</p><blockquote><p>写过webpack loader 或者插件吗</p></blockquote><blockquote><p>讲讲你写的 babel 插件</p></blockquote><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><blockquote><p>redux 的原理</p></blockquote><blockquote><p>redux 做状态管理和发布订阅模式有什么区别</p></blockquote><p>redux 其实也是一个发布订阅，但是 redux 可以做到数据的可预测和可回溯。</p><blockquote><p>react-redux 的原理，是怎么跟 react 关联起来的</p></blockquote><p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p><blockquote><p>了解多端的原理吗？</p></blockquote><p>不清楚，没了解过。</p><blockquote><p>http 与 tcp 的关系</p></blockquote><blockquote><p>tcp 可以建立多个连接吗？</p></blockquote><p>我估计是想问 http 的管线化，当时忘了这个叫啥了</p><blockquote><p>介绍一下为什么要有 三次握手，四次挥手</p></blockquote><blockquote><p>写过 babel 插件吗？用来干啥的？怎么写的 babel 插件</p></blockquote><p>写过一些简单的 babel 插件，说了我们公司用来通过代码生成文档的 babel 插件是怎么做的。</p><blockquote><p>知道怎么转化成 AST 的吗？</p></blockquote><p>我估计就是问词法分析和语法分析相关的</p><blockquote><p>研究过 React 的运行时吗？</p></blockquote><blockquote><p>职业规划。</p></blockquote><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><blockquote><p>项目介绍</p></blockquote><blockquote><p>说一下你的项目有哪些复杂的点，以及怎么解决的</p></blockquote><p>这个聊了挺久的，还聊了一些数据量比较大的怎么处理。</p><blockquote><p>你们的业务组件库有多少个，是什么样的组件</p></blockquote><blockquote><p>权限组件是怎么设计的</p></blockquote><blockquote><p>会node 吗？</p></blockquote><p>我说我只会增删改查，会点 express，然后就开始一顿狂轰乱炸的知识。</p><blockquote><p>介绍一下你对中间件的理解</p></blockquote><blockquote><p>怎么保证后端服务稳定性，怎么做容灾</p></blockquote><p>感觉已经超纲了，基本没做过，还好之前跟后端同学聊过他们怎么做容灾的，还记得两点说了下。</p><ol><li>多个服务器部署</li><li>降级处理，服务挂了，从缓存里面取。</li></ol><blockquote><p>怎么让数据库查询更快</p></blockquote><ol><li>索引 </li><li>如果数据量太多了可以拆表，分多个数据库</li></ol><blockquote><p>数据库是用的什么？</p></blockquote><p>mysql</p><blockquote><p>为什么用 mysql</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><p>这个题其实还挺常考的，可以好好准备下，背一下答案。</p><p>最后面试官问我有什么想问他的么，我说没有，因为我之前问得挺多了。不过他还是给我介绍了他们业务还是很厉害的，集团第三，还拿了 A 级绩效，公司有很多技术上的沉淀，跨端呀，web IDE 呀，等等</p><p>这个时候我就感觉自己能过了，感觉是在吸引我去，偷笑。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><blockquote><p>介绍一下项目的难点以及怎么解决的</p></blockquote><p>一起讨论那些难点</p><blockquote><p>自己有什么技术上的优势</p></blockquote><blockquote><p>最近在研究什么技术？</p></blockquote><blockquote><p>职业规划</p></blockquote><blockquote><p>移动端的业务有做过吗？</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><blockquote><p>当业务重的时候怎么安排时间？</p></blockquote><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>滴滴我面的这个岗位是可能回去做一些多端应用，所以会涉及到很多 webpack 和 ast 相关的东西，所以这些问得比较多，感觉这个组还是很不错的，能做到很多技术上的东西。</p><h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><blockquote><p>讲讲来蘑菇街都干了哪些事情</p></blockquote><blockquote><p>聊聊有什么技术上的沉淀</p></blockquote><blockquote><p>除了 redux mbox dva 还用过其他的 状态管理没</p></blockquote><blockquote><p>hooks 原理</p></blockquote><blockquote><p>看过 hooks 相关的草案吗</p></blockquote><blockquote><p>你对蚂蚁有什么期望，或者说技术的规划，想做的东西</p></blockquote><blockquote><p>vue3 的 类似 hooks 的原理是怎么样的</p></blockquote><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目，项目的难点，以及自己做了哪些事情</p></blockquote><blockquote><p>为什么项目里会引入 TS</p></blockquote><blockquote><p>dva 和 redux 的区别</p></blockquote><blockquote><p>职业发展，今年的打算</p></blockquote><blockquote><p>组件升级怎么让使用这个组件的人都知道。</p></blockquote><blockquote><p>如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计</p></blockquote><h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>全程聊项目，因为他不是前端的，所以没问前端任何知识，主要聊业务相关的，看看我对业务的理解，以及一些想法。</p><ul><li><p>项目难点</p></li><li><p>怎么解决</p></li><li><p>项目有什么改进的地方</p></li><li><p>业务方怎么拿到反馈的，就是做的这个东西具体有什么用</p></li></ul><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>一面面试官问了很多我完全不知道的东西，我知道的东西可能答的比较随意吧，记不起来了。反正能深深的感受到面试对知识的广度和深度远超我很多很多，基本不在一个 level 的。</p><p>二三面已经是 P9 的大佬来面了，所以也没问太多的技术细节，都是考察一些技术的解决方案和项目的东西。</p><p>蚂蚁的面试其实还是比较难的，问题都不是那种有确定的答案，基本都是考察你平时的积累和经验。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上一篇拼多多和酷家乐的面经之后有很多人问我工作几年，怎么学习的之类的，或者你面了这么多都过了是不是有什么技巧呀？</p><p>首先我目前工作了快两年了，18 年 7 月份毕业的。</p><p>关于如何准备面试的问题，我的策略是把自己<strong>会的东西以及常用的东西</strong>，尽量让面试官问不倒你，不会的东西可以跟面试官说不会，不怎么了解，那一般面试官也不会问相关的问题了，如果连自己常用的东西都了解得不深，那么就不太有可能把平时不常用的了解得很深了。</p><p>比如我可能写 react 比较多，参与过组件库的开发，webpack 写得也比较多。所以我在准备的时候，就尽量准备的这些知识，了解我的人都知道，我对 react 研究得比较多，原理、性能优化都写过文章，所以如果考 react 的东西，我基本不担心。 对于 vue、移动端、小程序、node 啥的，我基本没准备，问倒的时候我就说仅仅了解，没有什么实战经验。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>最后我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蚂蚁、字节、滴滴面试经历总结</title>
    <link href="/index.php/archives/320/"/>
    <url>/index.php/archives/320/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近两篇面试以及离职相关的文章不容错过哦。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EG5HCgz_M1S2Xbky0lgDxg">拼多多和酷家乐面试总结</a></p></li></ul><p>今年面试还是比较顺的，面了五家公司(酷家乐、拼多多、字节、滴滴、蚂蚁)，都过了。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>说一下浏览器缓存</p></blockquote><p>浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</p><p>控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。</p><p>控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><blockquote><p>cookie 与 session 的区别</p></blockquote><p>Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</p><p>详见：<a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a></p><blockquote><p>浏览器如何做到 session 的功能的。</p></blockquote><p>其实就是考察 http 怎么处理无状态是怎么处理的，具体可见 <a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a>里面的答案。</p><blockquote><p>解释一下：csrf 和 xss</p></blockquote><p>XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>怎么防止 csrf 和 xss</p></blockquote><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>跨域的处理方案有哪些</p></blockquote><p>常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></p><blockquote><p>CORS 是如何做的？</p></blockquote><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><blockquote><p>对于 CORS ，Get 和 POST 有区别吗？</p></blockquote><p>其实想考察的就是什么时候会有**预检请求(option 请求)**。</p><blockquote><p>了解 HTTPS 的过程吗？</p></blockquote><p>推荐浪浪的 <a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">深入理解HTTPS工作原理</a></p><blockquote><p>webpack 如何做性能优化</p></blockquote><p>webpack 做性能优化主要是考虑打包体积和打包速度。</p><p>体积分析用 <code>webpack-bundle-analyzer</code> 插件，速度分析用：<code>speed-measure-webpack-plugin</code> 插件。</p><p>打包速度优化瓶子君的：<a href="https://juejin.im/post/5e53dbbc518825494905c45f">玩转 webpack，使你的打包速度提升 90%</a>。</p><blockquote><p>es module 和 commonjs 的区别</p></blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><blockquote><p>react 里如何做动态加载</p></blockquote><p><code>React.lazy</code> ，另外通过 webpack 的动态加载：<code>import()</code> 和 <code>ensure.require</code></p><blockquote><p>动态加载的原理是啥，就是 webpack 编译出来的代码</p></blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p><blockquote><p>笔试题：页面结构包括页头（永远在顶部）、主体内容、页脚，页脚永远在页面底部（不是窗口底部），即内容高度不够时，页脚也要保证在页面底部</p></blockquote><p>常规题，考察基本的布局</p><blockquote><p>笔试题：写 new 的执行过程</p></blockquote><p>new 的执行过程大致如下：</p><ol><li><p>创建一个对象</p></li><li><p>将对象的 _ <em>proto_</em> 指向 构造函数的 prototype</p></li><li><p>将这个对象作为构造函数的 this</p></li><li><p>返回该对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Con, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(Con.prototype)<br>  <span class="hljs-keyword">let</span> result = Con.apply(obj, args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>笔试题：写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3</p></blockquote><p>思路：对于浮点数在底层处理是有问题的，所以目的就是想办法将所以的浮点数转化为整数进行处理，同时乘以一个倍数(A)，然后加起来后再除以这个倍数(A)，这个倍数应该是两个数中最小的那个数的倍数，比如 0.1 + 0.02 ,那么应该同时乘以 100，变为 10 + 2，然后再将值除以 100。</p><blockquote><p>1000000000 + 1000000000 允许返回字符串 处理大数</p></blockquote><p>大数问题就是通过字符串来处理，从后往前加，然后处理进位的问题。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目</p></blockquote><p>项目基本是问：</p><ol><li>项目难点以及怎么解决的</li><li>项目有哪些亮点？</li></ol><blockquote><p>写一个 es6 的继承过程</p></blockquote><p>这个题我觉得出得很好，很考察基本功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个是要实现的方法</span><br>createClass = <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params">sons, <span class="hljs-built_in">super</span></span>)</span> &#123;<br><span class="hljs-comment">// TODO</span><br><span class="hljs-keyword">return</span> fn;<br>&#125;<br><br><span class="hljs-comment">// 这是个 es6 的一个例子，要实现 extends 的功能。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>cons (args) &#123;<br><span class="hljs-built_in">super</span>(args)<br>  <span class="hljs-comment">// xxxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题跟一面的时候思路差不多，只是进位的时候不一定是 1。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><blockquote><p>聊项目</p></blockquote><blockquote><p>写一个防抖函数</p></blockquote><blockquote><p>算法题:<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p></blockquote><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>字节果然是出了名的考算法题比较多的，基本每面都会算法题和编程题，对编程能力比较看重吧。</p><p> 讲道理一面还是比较常规的，二三面因为都是团队 leader 和更高级别的，问的技术细节也比较少了，重点考察一些技术方案和项目的问题。</p><h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><blockquote><p>webpack 原理</p></blockquote><p>大致就是：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><blockquote><p>babel 原理</p></blockquote><p>babel的转译过程分为三个阶段：<strong>parsing、transforming、generating</strong>，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><ol><li>ES6代码输入 </li><li>babylon 进行解析得到 AST</li><li>plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</li><li>用 babel-generator 通过 AST 树生成 ES5 代码</li></ol><blockquote><p>虚拟 DOM 的理解</p></blockquote><p><a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a></p><blockquote><p>项目里如何做的性能优化</p></blockquote><p>这个跟我的项目相关。</p><blockquote><p>写过webpack loader 或者插件吗</p></blockquote><blockquote><p>讲讲你写的 babel 插件</p></blockquote><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><blockquote><p>redux 的原理</p></blockquote><blockquote><p>redux 做状态管理和发布订阅模式有什么区别</p></blockquote><p>redux 其实也是一个发布订阅，但是 redux 可以做到数据的可预测和可回溯。</p><blockquote><p>react-redux 的原理，是怎么跟 react 关联起来的</p></blockquote><p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p><blockquote><p>了解多端的原理吗？</p></blockquote><p>不清楚，没了解过。</p><blockquote><p>http 与 tcp 的关系</p></blockquote><blockquote><p>tcp 可以建立多个连接吗？</p></blockquote><p>我估计是想问 http 的管线化，当时忘了这个叫啥了</p><blockquote><p>介绍一下为什么要有 三次握手，四次挥手</p></blockquote><blockquote><p>写过 babel 插件吗？用来干啥的？怎么写的 babel 插件</p></blockquote><p>写过一些简单的 babel 插件，说了我们公司用来通过代码生成文档的 babel 插件是怎么做的。</p><blockquote><p>知道怎么转化成 AST 的吗？</p></blockquote><p>我估计就是问词法分析和语法分析相关的</p><blockquote><p>研究过 React 的运行时吗？</p></blockquote><blockquote><p>职业规划。</p></blockquote><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><blockquote><p>项目介绍</p></blockquote><blockquote><p>说一下你的项目有哪些复杂的点，以及怎么解决的</p></blockquote><p>这个聊了挺久的，还聊了一些数据量比较大的怎么处理。</p><blockquote><p>你们的业务组件库有多少个，是什么样的组件</p></blockquote><blockquote><p>权限组件是怎么设计的</p></blockquote><blockquote><p>会node 吗？</p></blockquote><p>我说我只会增删改查，会点 express，然后就开始一顿狂轰乱炸的知识。</p><blockquote><p>介绍一下你对中间件的理解</p></blockquote><blockquote><p>怎么保证后端服务稳定性，怎么做容灾</p></blockquote><p>感觉已经超纲了，基本没做过，还好之前跟后端同学聊过他们怎么做容灾的，还记得两点说了下。</p><ol><li>多个服务器部署</li><li>降级处理，服务挂了，从缓存里面取。</li></ol><blockquote><p>怎么让数据库查询更快</p></blockquote><ol><li>索引 </li><li>如果数据量太多了可以拆表，分多个数据库</li></ol><blockquote><p>数据库是用的什么？</p></blockquote><p>mysql</p><blockquote><p>为什么用 mysql</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><p>这个题其实还挺常考的，可以好好准备下，背一下答案。</p><p>最后面试官问我有什么想问他的么，我说没有，因为我之前问得挺多了。不过他还是给我介绍了他们业务还是很厉害的，集团第三，还拿了 A 级绩效，公司有很多技术上的沉淀，跨端呀，web IDE 呀，等等</p><p>这个时候我就感觉自己能过了，感觉是在吸引我去，偷笑。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><blockquote><p>介绍一下项目的难点以及怎么解决的</p></blockquote><p>一起讨论那些难点</p><blockquote><p>自己有什么技术上的优势</p></blockquote><blockquote><p>最近在研究什么技术？</p></blockquote><blockquote><p>职业规划</p></blockquote><blockquote><p>移动端的业务有做过吗？</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><blockquote><p>当业务重的时候怎么安排时间？</p></blockquote><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>滴滴我面的这个岗位是可能回去做一些多端应用，所以会涉及到很多 webpack 和 ast 相关的东西，所以这些问得比较多，感觉这个组还是很不错的，能做到很多技术上的东西。</p><h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><blockquote><p>讲讲来蘑菇街都干了哪些事情</p></blockquote><blockquote><p>聊聊有什么技术上的沉淀</p></blockquote><blockquote><p>除了 redux mbox dva 还用过其他的 状态管理没</p></blockquote><blockquote><p>hooks 原理</p></blockquote><blockquote><p>看过 hooks 相关的草案吗</p></blockquote><blockquote><p>你对蚂蚁有什么期望，或者说技术的规划，想做的东西</p></blockquote><blockquote><p>vue3 的 类似 hooks 的原理是怎么样的</p></blockquote><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目，项目的难点，以及自己做了哪些事情</p></blockquote><blockquote><p>为什么项目里会引入 TS</p></blockquote><blockquote><p>dva 和 redux 的区别</p></blockquote><blockquote><p>职业发展，今年的打算</p></blockquote><blockquote><p>组件升级怎么让使用这个组件的人都知道。</p></blockquote><blockquote><p>如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计</p></blockquote><h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>全程聊项目，因为他不是前端的，所以没问前端任何知识，主要聊业务相关的，看看我对业务的理解，以及一些想法。</p><ul><li><p>项目难点</p></li><li><p>怎么解决</p></li><li><p>项目有什么改进的地方</p></li><li><p>业务方怎么拿到反馈的，就是做的这个东西具体有什么用</p></li></ul><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>一面面试官问了很多我完全不知道的东西，我知道的东西可能答的比较随意吧，记不起来了。反正能深深的感受到面试对知识的广度和深度远超我很多很多，基本不在一个 level 的。</p><p>二三面已经是 P9 的大佬来面了，所以也没问太多的技术细节，都是考察一些技术的解决方案和项目的东西。</p><p>蚂蚁的面试其实还是比较难的，问题都不是那种有确定的答案，基本都是考察你平时的积累和经验。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上一篇拼多多和酷家乐的面经之后有很多人问我工作几年，怎么学习的之类的，或者你面了这么多都过了是不是有什么技巧呀？</p><p>首先我目前工作了快两年了，18 年 7 月份毕业的。</p><p>关于如何准备面试的问题，我的策略是把自己<strong>会的东西以及常用的东西</strong>，尽量让面试官问不倒你，不会的东西可以跟面试官说不会，不怎么了解，那一般面试官也不会问相关的问题了，如果连自己常用的东西都了解得不深，那么就不太有可能把平时不常用的了解得很深了。</p><p>比如我可能写 react 比较多，参与过组件库的开发，webpack 写得也比较多。所以我在准备的时候，就尽量准备的这些知识，了解我的人都知道，我对 react 研究得比较多，原理、性能优化都写过文章，所以如果考 react 的东西，我基本不担心。 对于 vue、移动端、小程序、node 啥的，我基本没准备，问倒的时候我就说仅仅了解，没有什么实战经验。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>最后我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac写作环境搭建</title>
    <link href="/index.php/archives/319/"/>
    <url>/index.php/archives/319/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写作是我一直都提倡每个人去做的一件事情，也许你是通过写作来进行总结，也许你是通过写作生计，也许像我一样写文章提升自己的影响力，不管怎么样，工欲善其事必先利其器，今天我将两年以来最好用的一套写作软件配置介绍给大家。</p><p>在这篇文章中你可以了解到三个工具：</p><ol><li>最好用的 markdown 写作编辑器</li><li>mac 平台专属的图床工具</li><li>选取合适的工具美化排版</li></ol><h2 id="写作软件-Typora"><a href="#写作软件-Typora" class="headerlink" title="写作软件(Typora)"></a>写作软件(Typora)</h2><p>我使用过很多的 markdown 编辑器，<strong>bear</strong>、<strong>MWeb</strong>、<strong>UIysses</strong>、<strong>印象笔记</strong>等等，每个都号称最专业的 markdown 软件，但是这些软件对于图片的处理都不是特别满足我的需求。</p><p>只有 <strong>typora</strong>，让文字和图片完美的结合在一起，并且支持将文章复制到其他平台。</p><p>接下来，我将介绍一下 Typora 吸引我的几个地方：</p><h3 id="1-所见即所得的特性"><a href="#1-所见即所得的特性" class="headerlink" title="1. 所见即所得的特性"></a>1. 所见即所得的特性</h3><p>实时预览，不需要分两栏。</p><p><img src="http://imgs.taoweng.site/2020-05-10-132912.gif" alt="实时预览"></p><h3 id="2-自定义主题。"><a href="#2-自定义主题。" class="headerlink" title="2. 自定义主题。"></a>2. 自定义主题。</h3><p>你可以从<a href="http://theme.typora.io/">官网下载主题</a>，或者自己写主题。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133121.jpg" alt="自定义主题"></p><h3 id="3-大纲与文章目录。"><a href="#3-大纲与文章目录。" class="headerlink" title="3. 大纲与文章目录。"></a>3. 大纲与文章目录。</h3><p>自动识别标题，展示出目录。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133207.png"></p><h3 id="4-可以方便的将图片自动上传到自己的图床上"><a href="#4-可以方便的将图片自动上传到自己的图床上" class="headerlink" title="4. 可以方便的将图片自动上传到自己的图床上"></a>4. 可以方便的将图片自动上传到自己的图床上</h3><p>大部分的写作编辑器都需要手动的去将图片上传到图床上，然后再把链接写到编辑器来，这样来回切换很麻烦。typora 可以自动识别图片然后直接上传上自己的图床上。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133238.png"></p><p>当你把图片直接拖到编辑器，或者说截屏之后复制到编辑器的时候，就会让你选择是否上传图片，点击上传图片就可以直接上传到图床上，然后将链接替换成图床的链接。</p><p>你只需要在偏好设置图像的上传服务设置为 iPic 即可，下面我会介绍 iPic。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133258.png"></p><p>上传服务这里还可以选择自定义命令，也就是说你可以自己写一个上传图片的 <code>shell</code> 然后上传到自己的图床上，图片处理非常的强大。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133310.png"></p><h3 id="5-可以直接复制富文本格式-包括主题样式-到公众号或者其他支持富文本的地方。"><a href="#5-可以直接复制富文本格式-包括主题样式-到公众号或者其他支持富文本的地方。" class="headerlink" title="5. 可以直接复制富文本格式(包括主题样式)到公众号或者其他支持富文本的地方。"></a>5. 可以直接复制富文本格式(包括主题样式)到公众号或者其他支持富文本的地方。</h3><p>公众号后台排版其实不是特别好用，另外我们程序员往往喜欢写 <strong>markdown</strong> 而不是富文本，所以就需要一个将 <strong>markdown</strong> 转富文本的一个工具，typora 在这方面也很擅长。</p><h2 id="图片处理-iPic-和-iPic-Move"><a href="#图片处理-iPic-和-iPic-Move" class="headerlink" title="图片处理(iPic 和 iPic Move)"></a>图片处理(iPic 和 iPic Move)</h2><h3 id="怎么获得免费图床"><a href="#怎么获得免费图床" class="headerlink" title="怎么获得免费图床"></a>怎么获得免费图床</h3><p>对于图床这个东西，我觉得还是用自己的比较好，或者说付费的图床，而不是选用网上一些免费的，比如微博图床，其他网站的图床(比如掘金)，使用别人的图床虽然免费，但是一旦加了防盗链，你想迁移图片就非常的麻烦(我就踩过这个坑)，那么这个时候免费的其实就更贵了。</p><p>所以很早我就开始研究怎么能用上专业的，自己的图床，我就发现了<strong>七牛云</strong>这个良心云服务商。七牛云对于新用户免费送 10 个 G 的空间，你可以将图片通过<strong>对象存储</strong>的方式存在七牛云里。而且这些图片还是都可以增加 <strong>CDN</strong> 的。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133320.png"></p><p>具体如何去创建自己的对象存储空间，你可以参考<a href="https://developer.qiniu.com/kodo/manual/1233/console-quickstart">官网教程</a>。</p><p>有了图床，如何将图片上传到图床上面去呢？在 Mac 下 iPic 就是一个很好的工具。</p><h3 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h3><p>iPic 是一个 Markdown 图床上传工具，将你的图片上传到你的图床上后，你可以得到一个 markdown 格式的图片文本，然后你可以直接复制到你的编辑器中。</p><p>你只需要在<strong>偏好设置</strong>里面设置好你自己图床相关的参数就可以很方便的上传图片到图床了。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133329.png"></p><h3 id="iPic-Mover"><a href="#iPic-Mover" class="headerlink" title="iPic Mover"></a>iPic Mover</h3><p><a href="https://itunes.apple.com/cn/app/id1183822957?ls=1&mt=12">iPic Mover</a> 可以一键将已有 Markdown 文件中所有图片迁移至新图床。批量上传图片、图床搬家，从未如此简单。</p><p><img src="https://ps-hz.toolinbox.net/006y8lVagw1fajaszqardg30ia0bc4cp.gif"></p><p>有了 iPic Mover，你就可以将你以前的图片统统放到自己的图床了，再也不怕别人给你加防盗链了。</p><h2 id="美化排版"><a href="#美化排版" class="headerlink" title="美化排版"></a>美化排版</h2><p>美化排版我的目的是要将文章复制到<strong>公众号</strong>里，公众号是需要讲颜值的，这样别人读起来才会舒服，读完率才会高。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>基于以上目的，如果你觉得默认的主题不太好看，Typora 默认还提供了好几种主题，你可以切换你自己喜欢的。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133351.png"></p><p>typora 默认提供了大概五个主题，你可以进行切换选择，如果你觉得这几个还不够好看，那么你可以去<a href="http://theme.typora.io/">主题市场</a>下载更多好看的主题。</p><p>如果你对主题市场的主题还不满意，可以手写一份 CSS，打造自己的主题。</p><h3 id="Mdnice"><a href="#Mdnice" class="headerlink" title="Mdnice"></a>Mdnice</h3><p>另外一个 markdown 美化排版的工具就是大名鼎鼎的 <a href="https://mdnice.com/">mdnice</a>，提供了将近 20 种主题：</p><p><img src="http://imgs.taoweng.site/2020-05-10-133403.png"></p><p>另外这个工具还支持<strong>格式化文档</strong>和<strong>微信外链转脚注</strong>的功能，这对于做公众号的同学来说非常的友好。也强烈推荐大家去尝试一下。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是我完成一篇公众号文章所需要用到的一些工具以及使用方法，我相信这些工具可以令你在写文章的时候不会为了工具不好用而烦恼，也不会为了写出来的文章排版不好看被读者吐槽。</p><p>如果你有更好的写作工具或者使用方法，欢迎留言给我，咱们一起讨论。</p><blockquote><p>我是桃翁，一个爱思考的前端er，期待你的关注。如果这篇文章能给你带来收获，希望你能点赞转发。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拼多多和酷家乐面试经历总结</title>
    <link href="/index.php/archives/318/"/>
    <url>/index.php/archives/318/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离职原因看我这篇文章吧：<a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a>，然后不得不去找工作恰饭呀。</p><p>我目前面了五家公司：滴滴、蚂蚁、拼多多、酷家乐、字节跳动，拼多多和酷家乐基本已拿到 offer，蚂蚁二面完了，滴滴和字节即将三面，我先把我已经面过的面经先总结出来，其他的不管过没过，这周内我都会总结出来，希望能给到正在找工作同学的帮助。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="酷家乐"><a href="#酷家乐" class="headerlink" title="酷家乐"></a>酷家乐</h2><p>酷家乐是我最早面的一家公司，还没被裁的那周二刚好面完，结果周五就被裁了，可能这就是冥冥之中吧。</p><p>面试的部门是工具组，是酷家乐最核心的部门，四面面试官跟我说我面的组是工具团队中的最核心组，会涉及到一些图像相关的技术，比如 Tree.js、WebGL等，所以这个组其实也挺好的，感觉能学到不少技术。</p><h3 id="一面-电话面"><a href="#一面-电话面" class="headerlink" title="一面(电话面)"></a>一面(电话面)</h3><ul><li><p>你在项目如何优化的</p><blockquote><p>我在简历里面写到了性能优化相关的，所以这个问题。</p></blockquote></li></ul><ul><li><p>你做的项目有什么值得说的</p><blockquote><p>基本上就是考察项目的亮点，可以说一些项目难点是如何解决的，或者介绍一些项目中用到的牛逼的技术。</p></blockquote></li><li><p>Ts 有什么优势</p><blockquote><p>讲道理所有现在在网上能查到的优势都是得益于<strong>静态语言</strong>的优势。</p></blockquote></li><li><p>type 和 interface 的区别</p><blockquote><p>这是一个高频题，如果考察 TS，这应该是最容易考察的，网上也都能查到相关的资料，但是很可能忽略一个点：<strong>type 只是一个类型别名，并不会产生类型</strong>。所以其实 type 和 interface 其实不是同一个概念，其实他们俩不应该用来比较的，只是有时候用起来看着类似。</p></blockquote></li><li><p>React 事件机制</p><blockquote><p>我觉得需要答的点：</p><ol><li>React 为什么要用合成事件</li><li>事件机制：注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 <code>document</code> 节点上。</li></ol><p>参考资料：<a href="https://toutiao.io/posts/28of14w/preview">一文吃透 React 事件机制原理</a></p></blockquote></li><li><p>聊聊 React 的 diff </p><blockquote><p>聊 diff 建议先看看我之前写过的一篇关于虚拟 DOM 的文章：<a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a>，有助于理解 diff 的意义。</p><p>diff 的细节可以看我之前写的：<a href="https://mp.weixin.qq.com/s/_jAW4Z3VR-uW0AEnjHgAEw">详解 React 16 的 Diff 策略</a></p></blockquote></li><li><p>React 优化</p><blockquote><p>可以看之前我写的 <a href="https://mp.weixin.qq.com/s/mpL1MxLjBqSO49TRijeyeg">React 函数式组件性能优化指南</a>，对于类组件也有对应的 API。</p></blockquote></li><li><p>怎么理解闭包</p><blockquote><p>基础中的基础，虽然社招考得不多，但是如果连闭包都理解不了，应该会减分不少。闭包由于在规范里没有定义，所以很多人下的定义不一样，理解的角度也不同，但是自己要有一套正确的理解方式，如果按照我的理解 JavaScript 里面所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量。</p></blockquote></li><li><p>节流怎么实现的</p><blockquote><p>防抖和节流的代码还是需要会手写的，这也是一个闭包的例子，</p></blockquote></li><li><p>原型，class B 继承 class A 翻译成 es5 应该是什么样子</p><blockquote><p>说实话，我觉得这道题其实蛮有水平的，即考察了如何写出一个好的继承方式，也对 new 过程进行了考察，还对考察了对 Class 的理解。</p><p>注意的点：<code>class</code> 是有重载功能的，怎么在子类的构造函数里面调用 <code>super</code></p></blockquote></li></ul><h3 id="二面-现场面"><a href="#二面-现场面" class="headerlink" title="二面(现场面)"></a>二面(现场面)</h3><ul><li><p>react 的基本原理</p><blockquote><p>UI = f(state) ，虚拟 DOM、diff 策略、setState</p></blockquote></li><li><p>react 如何做性能优化</p><blockquote><p>这个题也是高频，见一面回答</p></blockquote></li><li><p>redux 的重点概念</p><blockquote><p>store、reduce、action、actionCreater、dispatch</p></blockquote></li><li><p>聊一聊 React 的生命周期</p><blockquote><p>尽量把 React 15 和 16 的进行对比，然后 16 为什么要准备废除那几个生命周期，以及新增的生命周期可以进行替代。</p><p>这个图好好的理解一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejro09e6qj31j70u0ah0.jpg" alt="react 生命周期"></p></blockquote></li><li><p>聊一聊 hooks 怎么处理生命周期</p><blockquote><p>讲道理函数式组件是没有生命周期的，但是如何去模拟类组件的生命周期的作用，都是在 <code>useEffect</code> 里面进行操作的，因为生命周期里面所做的基本都是副作用，放到 <code>useEffect</code> 里是最合适的，专门用来处理副作用。</p></blockquote></li><li><p>笔试题一</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123; b ： <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj.b = <span class="hljs-number">5</span><br><br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-keyword">const</span> aa = foo(a)<br><br><span class="hljs-built_in">console</span>.log(a.b)<br><br><span class="hljs-built_in">console</span>.log(aa.b)<br></code></pre></td></tr></table></figure><ul><li>笔试题二：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ofo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bick</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;mybick&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> myBick = <span class="hljs-keyword">new</span> Ofo()<br><br>Ofo.prototype = <span class="hljs-keyword">new</span> Bick()<br><br><span class="hljs-keyword">var</span> youbick = <span class="hljs-keyword">new</span> Bick()<br><br><span class="hljs-built_in">console</span>.log(myBick.name)<br><br><span class="hljs-built_in">console</span>.log(youbick.name)<br></code></pre></td></tr></table></figure><ul><li><p>笔试题三：考察盒子模型和 <code>box-sizing</code> 属性，判断元素的尺寸和颜色。</p></li><li><p>实现一个 fill 函数，不能用循环。</p><blockquote><p>考察递归</p></blockquote></li><li><p>用 ES5 实现私有变量</p><blockquote><p>考察闭包的使用</p></blockquote></li></ul><h3 id="三面-现场面"><a href="#三面-现场面" class="headerlink" title="三面(现场面)"></a>三面(现场面)</h3><ul><li><p>简历里面的性能优化是如何做的</p><blockquote><p>减少请求频率、图片压缩、<code>React.memo</code>、<code>React.useMemo</code></p></blockquote></li><li><p>class 组件里面如何做性能优化(因为前面我说了用 React.memo 做了性能优化)</p><blockquote><p>shouldComponentUpdate(简称 SCU)。SCU 跟 immutable 强相关，一定要好好理解 react 的 immutable，否则很可能理解不了为什么不能直接去修改 state，然后再去 setState，以及 redux 的 reducer 要返回一个新的对象。</p></blockquote></li><li><p>实现一个 Typescript 里的 Pick</p><blockquote><p><code>type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;</code></p></blockquote></li><li><p>手写 Promise.all</p></li><li><p>手写并发只能 10 个</p></li><li><p>算法题，怎么判断单链表相交。</p><blockquote><p>很多种方法，我当时说的是最后一个节点如果相同，那么就代表相交。</p></blockquote></li><li><p>算法题，怎么找到第一个相交的节点。</p><blockquote><p>同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。</p><p>这是我刚想到的一种方式，不过当时面试的时候我记得好像更简单，但是想不起来了。</p></blockquote></li></ul><h3 id="四面-现场面"><a href="#四面-现场面" class="headerlink" title="四面(现场面)"></a>四面(现场面)</h3><ul><li><p>你觉得你在公司人缘怎么样</p></li><li><p>你觉得你为你们小组做了什么贡献</p></li><li><p>为什么要离职</p></li><li><p>除了我们公司还投了其他公司吗</p></li><li><p>薪资和层级有什么要求</p></li><li><p>如何垂直水平居中</p></li><li><p>你看过开源库的源码吗？</p></li><li><p>那你聊聊 React 的源码，把你记得起的讲一讲</p><blockquote><p>我看过 React 的一部分源码的，所以关于 React 源码更新部分的东西，应该基本都能说个大概。</p></blockquote></li><li><p>FiberNode 有哪些属性</p></li><li><p>stadeNode 有什么用？</p></li><li><p>还有一些技术问题想不起来了</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>酷家乐面试体验还是不错的，我是一面电话面，面完觉得 OK 之后就叫到公司去现场面试，6 点半下班了就骑车去了酷家乐，七点开始面试，一口气面完了三面，饭都没来得及吃，不过面试官很好给我倒了水。</p><p>感觉面试官对我的项目似乎不太敢兴趣，很少问项目的东西，可能由于他们是工具组，连我简历里面组件库相关的也没面，考察基础的比较多，基础考察得比较全面。</p><p>但是由于考虑到我之前做的项目复杂性不够，以及工作年限的问题，给到的评级不高，导致薪资也不是特别高，但是已经是这个评级的顶峰了，要是没有更好的 offer 酷家乐还是非常值得去的，特别是工具组。</p><h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li><p>react 16 生命周期有什么改变</p><blockquote><p><code>componentWillMount</code>，<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code> 准备废除，新增了 <code>static getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code></p><p>我还详细的介绍了为什么要用 <code>getDerivedStateFromProps</code> 来代替即将废除的三个生命周期，主要是16 版本 render 之前的生命周期可能会被多次执行，具体的可看我的这篇文章：<a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A">Deep In React之浅谈 React Fiber 架构(一)</a></p></blockquote></li><li><p>详细的介绍一下 <code>getDerivedStateFromProps</code></p></li><li><p>你在项目中如何做性能优化的</p></li><li><p><code>flex: 0 1 auto;</code> 是什么意思？</p><blockquote><p>flex 这个属性常考题，好好把阮老师的那篇 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex 语法篇</a>看完 flex 的面试题基本没问题。</p></blockquote></li><li><p>less 的 &amp; 代表什么？</p></li><li><p>算法题：求最大公共前缀，如 <code>[&#39;aaafsd&#39;, &#39;aawwewer&#39;, &#39;aaddfff&#39;] =&gt; &#39;aa&#39;</code></p><blockquote><p>不能调试，全靠编程素养，只能面试官才能运行。</p></blockquote></li><li><p>interface 和 type 的区别</p><blockquote><p>又考了，上面有回答</p></blockquote></li><li><p>有用状态管理吗？</p><blockquote><p>我常用的是 redux 和 dva，然后再聊了聊区别已经 redux 的理念</p></blockquote></li><li><p>有用 ssr 吗？</p><blockquote><p>没用过</p></blockquote></li><li><p>node 熟悉吗？</p><blockquote><p>写得少</p></blockquote></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li><p>class 组件与函数式组件的区别</p><blockquote><p>生命周期、设计理念，感觉这道题比较开发，可以看看 dan 的这篇：<a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？</a></p></blockquote></li><li><p>css 优先级</p><blockquote><p>important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p></blockquote></li><li><p>避免 css 全局污染。</p><blockquote><p>我常用的 css modules</p></blockquote></li><li><p>css modules 的原理</p><blockquote><p>生成唯一的类名</p></blockquote></li><li><p>有一个a标签，如何动态的决定他的样式。</p><blockquote><p>我说了先写几个 css，然后外部传一个前缀的方式。面试官问了都要这样吗？我说可以通过 context 的方式，就不需要每个组件都传了。</p></blockquote></li><li><p>import 和 require 导入的区别</p><blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p></blockquote></li><li><p>require 有什么性能问题</p><blockquote><p>好好想想上一个题的区别就能想到了</p></blockquote></li><li><p>组件库如何做按需加载</p><blockquote><p>我常用的是<code>babel-plugin-import</code> </p></blockquote></li><li><p>webpack 如何实现动态加载</p><blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p></blockquote></li><li><p>react 里有动态加载的 api 吗？</p><blockquote><p>React.lazy</p></blockquote></li><li><p>React.lazy 的原理是啥？</p></li><li><p>webpack 能动态加载 require 引入的模块吗？</p><blockquote><p>应该是不能的，前面说了，webpack 支持动态导入基本上只能用<code> import()</code> 和<code>require.ensure</code>。</p></blockquote></li><li><p>require 引入的模块 webpack 能做 Tree Shaking 吗？</p><blockquote><p>不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。</p></blockquote></li><li><p>设计一个input 组件需要哪些属性。我说了 value 、defaultValue、onChange</p></li><li><p>value 的类型是什么？</p></li><li><p>onChange 怎么规定 value 的类型</p></li><li><p>interface 和 type 的区别</p></li><li><p>写一个 promise 重试函数，可以设置时间间隔和次数。<code>function foo(fn, interval, times) &#123;&#125;</code></p><blockquote><p>常规题，网上有参考答案的。</p></blockquote></li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul><li><p>组件平台有哪些功能？</p><blockquote><p>详细的跟我讨论组件平台的设计，因为他们也想做一个组件平台。</p></blockquote></li><li><p>实现一个 redux</p><blockquote><p>实现 <code>createStore</code> 的功能，关键点发布订阅的功能，以及取消订阅的功能。</p></blockquote></li><li><p>用 ts 实现一个 redux</p><blockquote><p>简单的加上类型，我写的类型没有 redux 源码那么复杂，当时写得比较简单。</p></blockquote></li></ul><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>一面的时候其实我自己感觉答得不是特别好，连 less 的语法都忘记了，当时面下来感觉要凉了，平时写 样式的时间确实太少了。</p><p>很幸运的时候还是给我过了，二面面试官我觉得面得很专业，基本都是从浅入深的考察知识的深度，我感觉答得还可以，因为我是属于那种会的就尽量深一点，暂时不用的就很少花时间，所以我目前知识的广度很有欠缺，对于 node、ssr、移动端、小程序这些方面我的能力都很薄弱，但是面试的时候如果你不熟悉，直接说不熟悉就行，他就不会面了。</p><p>我准备面试之前对我自己的要求就是，我会的尽量不会很快就被问倒，所以我重点复习了我擅长的知识。</p><p>面下来感觉拼多多也没有想象中那么难，虽然拼多多薪资算行业内高的，不过拼多多在上海，我在杭州，另外就是强制上 6 天班，我比较忌惮这点。考虑到我和女朋友本来就是异地，要是单休，而且节假日也会比正常的少，见面的机会就更少了。</p><p>反正选 offer 这种事还是尽量综合考虑吧，团队、薪资、个人生活都应该考虑进去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离开蘑菇街后，我最近的一些想法</title>
    <link href="/index.php/archives/317/"/>
    <url>/index.php/archives/317/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被裁之后我就一直在家复习，面试，所以就一直没有写文章，没有太多心思搭理公众号，现在也拿了两个 offer 了，所以开始回到正途。</p><h2 id="胎死腹中的-Vue-3-0-Beta-文章"><a href="#胎死腹中的-Vue-3-0-Beta-文章" class="headerlink" title="胎死腹中的 Vue 3.0 Beta 文章"></a>胎死腹中的 Vue 3.0 Beta 文章</h2><p>4  月 17 日，早上我收到了浪浪(浪里行舟)的消息，给我发了一个微博消息，尤大在微博上宣布发布 <strong>Vue 3.0 Beta</strong> 了，然后跟我说这是热点，让我写一篇文章，我就暂停了前一天晚上定时发的文章，准备写一篇详细介绍 Vue 3.0 Beta 所发布的东西。</p><p>所以当天我早早的来到了公司，希望在上班前能搞定，然后就开始翻阅 <code>vue-next</code> 的文档以及草案，想从根源去探究 <strong>vue 3.0 Beta</strong> 能给我们带来什么。</p><p>没过多久，在我们技术部的群里有人就 @ 了所有人，让我们去看下邮件，邦哥(化名)发了一封邮件，每个人都要看一下。</p><p>我由于还在写文章，收集资料，就没那么快去看邮件，不一会儿，突然安静的 9L 就开始叽叽喳喳，议论纷纷，这时我感觉应该是一件大事儿。</p><p>我就迅速打开了邮件，第一段就描述着公司在今天要优化 140+  的人，第二段描述着公司的核心方向，<strong>直播和品牌特卖</strong>，在这个时候，我已经能意识到，我可能要被优化了，也许我们组绝大部分人都会被优化，因为我们组基本是做内部系统的，跟核心业务极大的偏离。</p><p>我也加入到他们叽叽喳喳的氛围中，放下了手上所有的事情，和旁边的同事讨论着裁员的事情。</p><h2 id="被裁"><a href="#被裁" class="headerlink" title="被裁"></a>被裁</h2><p>大概在十一点左右的时候，我左手边的一个应届生小声的说，我凉了，HR 让我去 11 楼一趟，然后我将这个事情传达给了我们的一个小群，以及我对接的后端，并询问他他们组的情况。</p><p>没想到聊着聊着，他跟我留下了一句，<strong>我中了，我先上去了</strong>。</p><p>接下来就眼睁睁的看着身边的人一个一个的都被喊上去，从工作一年的到两年的(包括我)，再到四年的，以及更多的。</p><p>到中午的时候，我们组只留下一个人没沟通了，是一个工作了四年多的老员工了，就坐在我旁边，他很慌，因为大家都拿着赔偿金(n+1.5)，他也想有。</p><p>一直等到一点、两点、三点、四点，五点，他放弃了，成为了我们这层楼我们组唯一个留下的。</p><p>后面就开始办理离职手续，交接项目，晚上我们整个前端到旁边的<strong>修舍酒店</strong>进行聚餐，虽然离别时悲伤的，但是被裁的人拿到高于常规的赔偿，是幸运的。</p><p>这次裁员对于应届生来说是最惨的，他们工作年限不久，不到一年，对于社招来说，是非常的吃亏的。工作年限不够，而且整个大环境来说又不好，现在又被裁没有工作，大公司很少会招工作年限这么短的，去小公司又有可能被压价。</p><p>唉，不想写这些消极情绪的了，在这被裁的两周里，空闲下来我也思考了很多，接下来说一些我的见解，希望能给到大家帮助。</p><h2 id="定时更新简历"><a href="#定时更新简历" class="headerlink" title="定时更新简历"></a>定时更新简历</h2><p>之前我在知乎上看到一个 HR 的回答里面说到，不管你跳不跳槽，其实都可以定时更新自己的简历。</p><p>我是比较赞成他的说法的，我倾向于半年更新一次简历，因为在更新简历的过程中你会去思考，去总结你在之前的这半年里，你做了什么有价值的东西，有没有什么亮点。</p><p>一旦发现在这半年里没有做出什么成绩，那么你也许需要在后面的时间里调整自己的工作方式，思考为什么没有值得写在简历里面的东西，然后给自己定目标，做规划，尽量在半年后可以有一些亮点可以跟别人吹。</p><h2 id="多做总结"><a href="#多做总结" class="headerlink" title="多做总结"></a>多做总结</h2><p>总结这个东西，其实每个人都会觉得应该做，但是很少人真正的去执行，也许是因为太忙，也许是因为懒，也许是因为觉得他不重要。</p><p>我相信很多人会有这样的感觉，当别人问你做的项目有没有什么难度，在做的时候遇到了什么困难，以及怎么解决的。你会感觉都已经做出来了，感觉没什么难的了。</p><p>其实在我看来，这其实就是没有及时的总结导致的。</p><p>我的建议是当你遇到难题并解决之后，<strong>马上</strong>记下来，因为这个时候是你最有动力，也是最清醒的时刻，一旦你想<strong>后面有空了再记</strong>，那么基本上就是不会记了。</p><p>另外就是每个项目完结之后也需要进行总结，遇到的问题，项目的架构，项目的价值等等，这些东西是以后可以跟面试官聊项目的资本。如果不记下来，当你写简历的时候，很可能会把关键的地方忘掉。</p><h2 id="忙一点的公司挺好"><a href="#忙一点的公司挺好" class="headerlink" title="忙一点的公司挺好"></a>忙一点的公司挺好</h2><p>可能对于这一点很多人会觉得我政治不正确，觉得理想的工作不应该是朝九晚六，到点下班么。</p><p>但是我最近在观察那些发展得好的企业，加班都比较严重，比如阿里、腾讯、字节跳动、拼多多等，当然这些公司都会给你更高的薪水。</p><p>为什么我会绝对忙的公司其实挺好呢？主要是因为公司发展迅速，意味着就会扩大生产，那么就需要更多的劳动力，但是对于招聘合适的人又是一个急不得的事儿，所以留在公司的人可能会很忙，得干超出正常一个人所干的事儿。</p><p>这样其实你可以有更多需求做，也许是重复的，也许是新的东西，不管怎么样，一旦你代码写得多，你能更可能发现到别人发现不到的痛点，也会给公司做更多的贡献，其实对于成长是有帮助的。</p><p>可能有人会觉得我只是一个打工的，在规定的时间把东西做完，下班时间再去学习，其实这种方式对于大部分人来说不是特别的高效，因为学习这件事其实是反人性的，下班了也许你更多的时间会用于其他娱乐中。</p><p>再说一下对于比较闲的公司，也许很多人都想去，比如外企，相对国内的大厂来说要轻松很多，但是闲的公司很容易让人养成懒的习惯，特别是对于工作不久的，一旦养成了懒惰的习惯，就会危害自己一辈子。</p><p><strong>我希望这一点不要跟我争论，如果你希望去不忙的公司，你去就行了，也不用说服我。</strong></p><blockquote><p> 可以想想之前甲骨文裁员的时候，那些老员工的无奈。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>蘑菇街还是一家很有良心的公司，我也很感谢公司给我带来的成长，希望蘑菇街能越来越好。</p><p>这次裁员其实对于我来说影响不是特别的大，因为我其实在工作期间会偶尔出去其他公司面试，面试的目的其实不仅仅是想换份工作，另外主要也想看看自己在面试中发现自己哪些不足，然后好好的改进。</p><p> 刚好在裁员的那一周，我也过了一家杭州 1000 人左右的公司，但是觉得给的薪资不是特别满意，所以我被裁之后就安心在家复习，继续投一些大点的公司。</p><p>投递的公司有蚂蚁、滴滴、字节跳动，拼多多(已经面完，可拿 offer)，没拿到 offer 的也都在流程中(二面或者三面)，基本上还没有挂过。</p><p>后面我会将我最近的面试题总结下来，以及我是如何复习的，希望能给到正在找工作或者想找工作的人帮助。</p><blockquote><p> 我是桃翁，期待你的关注</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解 JavaScript 中的执行上下文和执行栈</title>
    <link href="/index.php/archives/315/"/>
    <url>/index.php/archives/315/</url>
    
    <content type="html"><![CDATA[<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>最近在研究 JavaScript 基础性的东西，但是看到对于<strong>执行上下文</strong>的解释我发现有两种，一种是执行上下文包含：scope(作用域)、variable object(变量对象)、this value(this 值)，另外一个种是包含：lexical environment(词法环境)、variable environment(变量环境)、this value(this 值)。</p><p>后面我查阅了不少博客以及 ES3 和 ES5 的规范才了解到，第一种是 ES3 的规范，经典书籍《JavaScript高级程序设计》第三版就是这样解释的，也是网上广为流传的一种，另一种是 ES5 的规范。</p><p>然后我接着又去翻了 ES2018 中的，发现又有变化了，已经增加了更多的内容了，考虑到这部分内容颇为复杂，准备后面再进行总结分享，查资料的时候看到这篇讲执行上下文(ES5 )的还不错，所以就翻译出来先分享给大家。</p><p>以后看到变量对象、活动对象知道是 ES3 里面的内容，而如果是词法环境、变量环境这种词就是 ES5 以后的内容。</p><p>以下是正文：</p><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>简而言之，执行上下文是计算和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>JavaScript 中有三种执行上下文类型。</p><ul><li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</li></ul><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）的数据结构，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行处于栈顶的执行上下文的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>让我们通过下面的代码示例来理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-title">functionfirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  second();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">functionsecond</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><br>first();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="http://imgs.taoweng.site/2020-03-19-145946.png"><br>上述代码的执行上下文栈。</p><p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p><p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>first()</code> 函数的执行上下文。</p><p>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p><h3 id="怎么创建执行上下文？"><a href="#怎么创建执行上下文？" class="headerlink" title="怎么创建执行上下文？"></a>怎么创建执行上下文？</h3><p>到现在，我们已经看过 JavaScript 怎样管理执行上下文了，现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。</p><p>创建执行上下文有两个阶段：<strong>1) 创建阶段</strong> 和 <strong>2) 执行阶段</strong>。</p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p><ol><li><strong>this</strong> 值的决定，即我们所熟知的 <strong>this 绑定</strong>。</li><li>创建<strong>词法环境</strong>组件。</li><li>创建<strong>变量环境</strong>组件。</li></ol><p>所以执行上下文在概念上表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ExecutionContext = &#123;<br>  ThisBinding = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">this</span> <span class="hljs-attr">value</span>&gt;</span>,</span><br><span class="xml">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="xml">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="this-绑定："><a href="#this-绑定：" class="headerlink" title="this 绑定：**"></a>this 绑定：**</h4><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p><p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = &#123;<br>  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>foo.baz();   <span class="hljs-comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span><br>             <span class="hljs-comment">// 对象 &#x27;foo&#x27; 调用</span><br><br><span class="hljs-keyword">let</span> bar = foo.baz;<br><br>bar();       <span class="hljs-comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span><br>             <span class="hljs-comment">// 没有指定引用对象</span><br></code></pre></td></tr></table></figure><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p><a href="http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p><blockquote><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>outer</strong>词法环境的空值组成。</p></blockquote><p>简单来说<strong>词法环境</strong>是一种持有<strong>标识符—变量映射</strong>的结构。（这里的<strong>标识符</strong>指的是变量/函数的名字，而<strong>变量</strong>是对实际对象[包含函数类型对象]或原始数据的引用）。</p><p>现在，在词法环境的<strong>内部</strong>有两个组件：(1) <strong>环境记录器</strong>和 (2) 一个<strong>外部环境的引用</strong>。</p><ol><li><strong>环境记录器</strong>是存储变量和函数声明的实际位置。</li><li><strong>外部环境的引用</strong>意味着它可以访问其父级词法环境（作用域）。</li></ol><blockquote><p>译者注：外部环境已经跟 ES3 规定的作用域的作用类似</p></blockquote><p><strong>词法环境</strong>有两种类型：</p><ul><li><strong>全局环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 <strong>null</strong>。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象。</li><li>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul><p><strong>环境记录器</strong>也有两种类型（如上！）：</p><ol><li><strong>声明式环境记录器</strong>存储变量、函数和参数。</li><li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。</li></ol><p>简而言之，</p><ul><li>在<strong>全局环境</strong>中，环境记录器是对象环境记录器。</li><li>在<strong>函数环境</strong>中，环境记录器是声明式环境记录器。</li></ul><p><strong>注意 —</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">GlobalExectionContext = &#123;<br>  <span class="hljs-attr">LexicalEnvironment</span>: &#123;<br>    <span class="hljs-attr">EnvironmentRecord</span>: &#123;<br>      <span class="hljs-attr">Type</span>: <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br>    <span class="hljs-attr">outer</span>: &lt;<span class="hljs-literal">null</span>&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  <span class="hljs-attr">LexicalEnvironment</span>: &#123;<br>    <span class="hljs-attr">EnvironmentRecord</span>: &#123;<br>      <span class="hljs-attr">Type</span>: <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br>    <span class="hljs-attr">outer</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Global</span> <span class="hljs-attr">or</span> <span class="hljs-attr">outer</span> <span class="hljs-attr">function</span> <span class="hljs-attr">environment</span> <span class="hljs-attr">reference</span>&gt;</span></span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="变量环境："><a href="#变量环境：" class="headerlink" title="变量环境："></a>变量环境：</h4><p>它同样是一个词法环境，其环境记录器持有<strong>变量声明语句</strong>在执行上下文中创建的绑定关系。</p><p>如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p><p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p><p>我们看点样例代码来理解上面的概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> c;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">e, f</span>) </span>&#123;<br> <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;<br> <span class="hljs-keyword">return</span> e * f * g;<br>&#125;<br><br>c = multiply(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>执行上下文看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript">GlobalExectionContext = &#123;<br><br>  <span class="hljs-attr">ThisBinding</span>: &lt;Global Object&gt;,<br><br>  LexicalEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 在这里绑定标识符<br>      a: &lt; uninitialized &gt;,<br>      b: &lt; uninitialized &gt;,<br>      multiply: &lt; func &gt;<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;,<br><br>  VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 在这里绑定标识符<br>      c: undefined,<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  ThisBinding: &lt;Global Object&gt;,<br><br>  LexicalEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 在这里绑定标识符<br>      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;,<br><br>VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 在这里绑定标识符<br>      g: undefined<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong> — 只有遇到调用函数 <code>multiply</code> 时，函数执行上下文才会被创建。</p><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p><p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p><p>这就是我们说的变量声明提升。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>这是整篇文章中最简单的部分。在此阶段，完成对所有这些变量的分配，最后执行代码。</p><p><strong>注意</strong> — 在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code>。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们已经讨论过 JavaScript 程序内部是如何执行的。虽然要成为一名卓越的 JavaScript 开发者并不需要学会全部这些概念，但是如果对上面概念能有不错的理解将有助于你更轻松，更深入地理解其他概念，如变量声明提升，作用域和闭包。</p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 代码规范</title>
    <link href="/index.php/archives/314/"/>
    <url>/index.php/archives/314/</url>
    
    <content type="html"><![CDATA[<h2 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a><strong>基本规范</strong></h2><ul><li>每个文件只包含的一个 React 组件：<ul><li>联系紧密的组件可以使用「命名空间」的形式；</li><li>每个文件中可包含多个纯函数组件。</li></ul></li><li>始终使用 JSX 语法，不要使用 <code>React.createElement</code> 创建 ReactElement，以提高编写速度、可读性、可维护性（没有 JSX 转换的特殊场景例外，如在 <code>console</code> 中测试组件）。</li></ul><h2 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h2><ul><li><p>组件文件使用一致的<code>.js</code>或 <code>.jsx</code>后缀。所有组件文件的后缀名从<code>.js</code>或<code>.jsx</code>中任选其一。不应在项目中出现部分组件为<code>.js</code>文件，部分为<code>.jsx</code>的情况。</p></li><li><p>每个存放组件的目录使用一个<code>index.js/index.jsx</code>以命名导出的形式暴露所有组件。同目录内的组件相互引用使用<code>import Foo from &#39;./Foo&#39;;</code>进行。引用其它目录的组件使用<code>import &#123;Foo&#125; from &#39;../component&#39;;</code>进行。</p></li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li><p>文件名：使用<strong>大驼峰命名法（PascalCase）</strong>，如 MyComponent.jsx；</p></li><li><p>组件命名：组件名称和文件名一致，如 MyComponent.jsx 里的组件名应该是 MyComponent；一个目录的根组件使用 index.jsx 命名，以目录名称作为组件名称；</p></li><li><p>引用命名：React 组件使用大驼峰命名法（PascalCase）；</p></li><li><p>高阶组件使用camelCase命名。高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。</p></li><li><p>使用<code>onXxx</code>形式作为<code>props</code>中用于回调的属性名称。使用统一的命名规则用以区分<code>props</code>中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。</p></li><li><p>使用withXxx或xxxable形式的词作为高阶组件的名称。高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。</p></li></ul><h3 id="带命名空间的组件"><a href="#带命名空间的组件" class="headerlink" title="带命名空间的组件"></a>带命名空间的组件</h3><ul><li>如果一个组件有许多关联子组件，可以以该组件作为命名空间编写、调用子组件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Row</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Label</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br>Form.Row = Row;<br>Form.Label = Label;<br>Form.Input = Input;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Form;<br><br><span class="hljs-comment">// refence Form component</span><br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Form&#x27;</span>;<br><br><span class="hljs-keyword">const</span> App = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Form</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Form.Row</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form.Label</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form.Input</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Form.Row</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Form</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><ul><li>在组件行内设置属性（以便 propTypes 校验），不要在外部改变属性的值；</li><li>属性较多使用 <code>&#123;…this.props&#125;</code> 语法；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> props = &#123;&#125;;<br>props.foo = x;<br>props.bar = y;<br><span class="hljs-keyword">const</span> component = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br></code></pre></td></tr></table></figure><ul><li>属性值明确为 <code>true</code> 时，省略值。</li></ul><h3 id="属性对齐方式"><a href="#属性对齐方式" class="headerlink" title="属性对齐方式"></a>属性对齐方式</h3><ul><li>属性较少时可以行内排列；</li><li>属性较多时每行一个属性，闭合标签单独成行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad - too long</span><br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=&#123;<span class="hljs-built_in">this</span>.state.newDinosaurName&#125; onChange=&#123;<span class="hljs-built_in">this</span>.inputHandler.bind(<span class="hljs-built_in">this</span>, <span class="hljs-string">&#x27;newDinosaurName&#x27;</span>)&#125; /&gt;  <br><br><span class="hljs-comment">// bad - aligning attributes after the tag</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  </span></span><br><span class="hljs-tag"><span class="xml">       <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.newDinosaurName&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">       <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.inputHandler.bind(this,</span> &#x27;<span class="hljs-attr">newDinosaurName</span>&#x27;)&#125; /&gt;</span></span><br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  </span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.newDinosaurName&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.inputHandler.bind(this,</span> &#x27;<span class="hljs-attr">newDinosaurName</span>&#x27;)&#125;</span></span><br><span class="hljs-tag"><span class="xml"> /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="属性空格"><a href="#属性空格" class="headerlink" title="属性空格"></a>属性空格</h3><ul><li>属性 <code>=</code> 前后不要添加空格</li><li>JSX 中的花括号前后不要添加空格。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>&lt;Foo bar=&#123; baz &#125; foo = <span class="hljs-string">&quot;bar&quot;</span> /&gt;<br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> <span class="hljs-attr">bar</span>=<span class="hljs-string">&#123;baz&#125;</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;bar&quot;</span> /&gt;</span></span><br><br><span class="hljs-comment">// good &#123; left: &#x27;20px&#x27; &#125; 为一个对象</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">left:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="propTypes-及默认值"><a href="#propTypes-及默认值" class="headerlink" title="propTypes 及默认值"></a><code>propTypes</code> 及默认值</h3><ul><li>组件属性都应该在 <code>propTypes</code> 中声明类型；</li><li>始终明确指定非必选属性的默认值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SFC</span>(<span class="hljs-params">&#123; foo, bar, children &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SFC</span>(<span class="hljs-params">&#123; foo, bar, children &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br>SFC.propTypes = &#123;<br>  <span class="hljs-attr">foo</span>: PropTypes.number.isRequired,<br>  <span class="hljs-attr">bar</span>: PropTypes.string,<br>  <span class="hljs-attr">children</span>: PropTypes.node,<br>&#125;;<br><br>SFC.defaultProps = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">children</span>: <span class="hljs-literal">null</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li>JSX 属性使用<strong>双引号</strong> <code>&quot;</code>；</li><li>JS 使用<strong>单引号</strong> <code>&#39;</code>；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="() 使用"></a><code>()</code> 使用</h2><ul><li>多行的 JSX 使用 () 包裹，有组件嵌套时使用多行模式；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br> <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ComponentOne</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ComponentTwo</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">var</span> multilineJsx = (  <br>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Nav</span> /&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br> );<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">return</span> (<br>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">ComponentOne</span> /&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">ComponentTwo</span> /&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ul><li>单行 JSX 省略 ()</li></ul><h2 id="自闭合标签"><a href="#自闭合标签" class="headerlink" title="自闭合标签"></a>自闭合标签</h2><ul><li>自闭合所有没有子组件的标签；</li><li>自闭合标签 <strong><code>/</code> 前留一个空格</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>&lt;Logo&gt;&lt;/Logo&gt;<br><br><span class="hljs-comment">// very bad</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span>                 /&gt;</span></span><br><br><span class="hljs-comment">// bad</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span></span></span><br><span class="hljs-tag"><span class="xml"> /&gt;</span></span><br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>事件函数用 <code>public class fields</code> 型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// bad</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>事件处理方法以 handle 开头，如 handleClick() {}，用 on 的作为回调做区分</li></ul><h2 id="组件代码组织"><a href="#组件代码组织" class="headerlink" title="组件代码组织"></a>组件代码组织</h2><ul><li>按照生命周期顺序组织组件的属性、方法；</li><li>方法（属性）之间空一行；</li><li><code>render()</code> 方法始终放在最后；</li><li>自定义方法 React API 方法之后、<code>render()</code> 之前；</li><li><code>class extends React.Component</code> 顺序：<ol><li><code>static</code> 属性</li><li><code>static</code> 方法</li><li><code>constructor</code></li><li><code>getChildContext</code></li><li><code>componentWillMount</code></li><li><code>componentDidMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li><li><em>点击处理函数或者其他事件处理函数</em>，如 <code>onClickSubmit()</code> 或 <code>onChangeDescription()</code></li><li><em><code>render</code> 的 getter 方法</em>，如 <code>getSelectReason()</code> 或 <code>getFooterContent()</code></li><li><em>可选的 render 方法</em>，如 <code>renderNavigation()</code> 或 <code>renderProfilePicture()</code></li><li><code>render</code></li></ol></li><li>定义 propTypes, defaultProps, contextTypes</li></ul><h2 id="代码校验工具"><a href="#代码校验工具" class="headerlink" title="代码校验工具"></a><strong>代码校验工具</strong></h2><ul><li><a href="https://www.github.com/eslint/eslint">ESLint</a></li><li><a href="https://github.com/yannickcr/eslint-plugin-react">ESLint React Plugin</a></li><li><a href="https://github.com/evcohen/eslint-plugin-jsx-a11y">ESLint JSX A11Y Plugin</a></li></ul><p>参考：<a href="https://github.com/minwe/style-guide/blob/master/React.js.md">https://github.com/minwe/style-guide/blob/master/React.js.md</a></p><p>参考：<a href="https://github.com/JasonBoy/javascript/tree/master/react">JasonBoy/javascript</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从两个角度看 Typescript 中的类型是什么?</title>
    <link href="/index.php/archives/302/"/>
    <url>/index.php/archives/302/</url>
    
    <content type="html"><![CDATA[<h2 id="0-作者以及原文介绍"><a href="#0-作者以及原文介绍" class="headerlink" title="0. 作者以及原文介绍"></a>0. 作者以及原文介绍</h2><p>作者是 <strong>Dr. Axel Rauschmayer</strong>，号称”德国阮一峰“，本文原文来自于他的博客：<a href="https://2ality.com/2020/02/understanding-types-typescript.html%EF%BC%8C%E4%B8%8D%E7%86%9F%E6%82%89%E4%BB%96%E7%9A%84%E5%8F%AF%E4%BB%A5%E5%85%B3%E6%B3%A8%E4%B8%80%E4%B8%8B%E4%BB%96%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82">https://2ality.com/2020/02/understanding-types-typescript.html，不熟悉他的可以关注一下他的博客。</a></p><h2 id="1-每个角度都从这三个问题来解释"><a href="#1-每个角度都从这三个问题来解释" class="headerlink" title="1. 每个角度都从这三个问题来解释"></a>1. 每个角度都从这三个问题来解释</h2><p>以下三个问题对于理解类型是如何工作的非常重要，需要从这两个角度中的每一个角度来回答。</p><ol><li><code>myVariable</code> 的类型 <code>MyType</code> 意味着什么？</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myVariable: MyType = <span class="hljs-comment">/*...*/</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>Sourcetype</code> 可以分配给 <code>TargetType</code> 吗?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> source: SourceType = <span class="hljs-comment">/*...*/</span>;<br><span class="hljs-keyword">let</span> target: TargetType = source;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>TypeUnion</code> 是如何从<code> Type1</code>、 <code>Type2 </code>和  <code>Type3</code> 衍生而来的？</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> TypeUnion = Type1 | Type2 | Type3;<br></code></pre></td></tr></table></figure><h2 id="2-角度-1：-类型是一组值"><a href="#2-角度-1：-类型是一组值" class="headerlink" title="2. 角度 1： 类型是一组值"></a>2. 角度 1： 类型是一组值</h2><p>从这个角度来看，类型是一组值：</p><ol><li><p>如果 <code>myVariable</code> 具有 <code>MyType</code> 类型，这意味着可以分配给 <code>myVariable</code> 的所有值都必须是集合 <code>MyType</code> 的元素。</p></li><li><p>如果 <code>Sourcetype</code> 可以分配给 <code>TargetType</code>，那么 <code>Sourcetype</code> 是 <code>TargetType</code> 的子集。 因此，<code>TargetType</code> 也允许<code> SourceType</code> 所允许的所有值。</p></li><li><p>类型 <code>Type1</code>、 <code>Type2</code>和 <code>Type3</code>的联合类型是定义它们的集合在集合论中的并集。</p></li></ol><h2 id="3-角度2：-类型兼容关系"><a href="#3-角度2：-类型兼容关系" class="headerlink" title="3. 角度2： 类型兼容关系"></a>3. 角度2： 类型兼容关系</h2><p>从这个角度来看，我们不关心值以及它们在执行代码时如何流动。 相反，我们采取了一种更为静态的观点:</p><ul><li>源代码有个位置，每个位置都有一个静态类型。 在支持 <strong>Typescript</strong> 的编辑器中，如果我们将鼠标悬停在某个位置的上方，就可以看到该位置的静态类型。</li><li>当源位置通过赋值、函数调用等方式连接到目标位置时，源位置的类型必须与目标位置的类型兼容。 <strong>Typescript</strong> 规范通过所谓的类型关系定义类型的兼容性。</li><li>类型关系分配兼容性定义了源类型 <code>S</code> 何时可以分配给目标类型 <code>T</code>:<ul><li><code>S</code> 和 <code>T</code>  都是一样的类型</li><li><code>S</code> 或者 <code>T</code> 是 any 类型。</li><li>等等</li></ul></li></ul><p>让我们考虑以下问题：</p><ol><li>如果 <code>myVariable</code> 的静态类型可以分配给 <code>MyType</code> ，那么 <code>myVariable</code> 就具有类型 <code>MyType</code></li><li>如果 <code>SourceType</code> 和 <code>TargetType</code> 是互相兼容的，那么<code>SourceType</code>可以分配给 <code>TargetType</code></li><li>联合类型的工作方式是通过类型关系成员定义的。</li></ol><p>类型系统一个有趣的特点是，同一个变量在不同的位置可以有不同的静态类型:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-comment">// %inferred-type: any[]</span><br>arr;<br><br>arr.push(<span class="hljs-number">123</span>);<br><span class="hljs-comment">// %inferred-type: number[]</span><br>arr;<br><br>arr.push(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-comment">// %inferred-type: (string | number)[]</span><br>arr;<br></code></pre></td></tr></table></figure><h2 id="4-标准类型系统和结构类型系统"><a href="#4-标准类型系统和结构类型系统" class="headerlink" title="4. 标准类型系统和结构类型系统"></a>4. 标准类型系统和结构类型系统</h2><p>静态类型系统的职责之一是确定两个静态类型是否兼容：</p><ul><li>实际参数的静态类型U（例如，通过函数调用提供）</li><li>对应形式参数的静态类型T（指定为函数定义的一部分）</li></ul><p>这通常意味着要检查 U 是否是 T 的子类型。这种检查的两种方法(大致)是:</p><ul><li><p>在标准类型中，如果两个静态类型具有相同的标识(“名称”) ，则它们是相等的。 一种类型是另一种类型的子类型，它们的子类型关系是显式声明的。</p><blockquote><p>具有标准类型的语言有 <strong>c++</strong> 、 <strong>Java</strong>、 <strong>c#</strong> 、 <strong>Swift</strong> 和 <strong>Rust</strong></p></blockquote></li><li><p>在结构类型系统中，如果两个静态类型具有相同的结构(如果它们的部分具有相同的名称和相同的类型) ，则它们是相等的。 如果 U 包含 T 的所有部分(可能还包括其他部分) ，并且 U 的每个部分都包含 T 的相应部分的子类型，那么一种类型 U 就是另一种类型 T 的子类型。</p><blockquote><p>具有结构类型的语言有 <strong>ocaml</strong>/<strong>reasonml</strong>、 <strong>Haskell</strong> 和 <strong>TypeScript</strong></p></blockquote></li></ul><p>下面的代码在标准类型系统中产生类型错误(第 A 行) ，但在 <strong>Typescript</strong> 的结构类型系统中是合法的，因为类 <code>A</code> 和类 <code>B</code> 具有相同的结构:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  name = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>  name = <span class="hljs-string">&#x27;B&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">const</span> someVariable: A = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// (A)</span><br></code></pre></td></tr></table></figure><p><strong>Typescript</strong> 的接口在结构上也能工作——它们不需要实现来匹配:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">interface Point &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  y: number;<br>&#125;<br><span class="hljs-keyword">const</span> point: Point = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h2 id="5-进一步阅读"><a href="#5-进一步阅读" class="headerlink" title="5. 进一步阅读"></a>5. 进一步阅读</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">Chapter “Type Compatibility” in the TypeScript Handbook</a></li><li><a href="https://github.com/microsoft/TypeScript/blob/master/doc/spec.md#311-type-relationships">Section “TypeRelationships” in the TypeScript Specification</a></li></ul><blockquote><p>如果翻译得不对的地方希望您可以帮忙指出来。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我也想做自己喜欢做的事儿</title>
    <link href="/index.php/archives/301/"/>
    <url>/index.php/archives/301/</url>
    
    <content type="html"><![CDATA[<p>我今天看到一视频，给了我非常大感触。是 B 站上的一个视频，标题名叫：<strong>《这有可能是我最后一期视频了，再见了 B 站》，</strong> 视频链接可以点击「原文链接」得到。</p><p>这个视频大概讲的是这样：</p><p>一个富二代，大学毕业以后没有去家里帮爸妈，由于自己非常喜欢游戏，所以就想做自媒体，自己赚钱养自己，做了差不多一年半，在 B 站拥有不多不少的 25 万粉丝，由于他自己喜欢的是单机游戏，但是国内喜欢单机游戏的人太少，所以在 B 站涨粉缓慢，慢慢的，迫于生计，不得追求快速涨粉，不至于入不敷出。</p><p>所以就开始做一些自己不喜欢的视频，比如热点视频，电影娱乐等，因为这些看的人多，涨粉相对较快，但是自己并不喜欢这些视频。以前自己做的游戏视频做完之后会回味好几遍，但是现在做的这些视频自己非常不喜欢，做完之后完全没有动力去看。</p><p>突然有一天他的爸妈给他买了一套 <strong>1600 万</strong>的房子，加上装修可能 1700 万左右，但是他爸妈只付了首付(他爸妈能全款买得起)，剩下的贷款要让他自己还，目的就是要让他回去帮家里的忙，因为他做自媒体根本换不起这个贷款。</p><p>一个月贷款要还 3 万多，他做 B 站一年半才赚了 10 万，他爸妈就质问他，你觉得你做现在这个职业有前途吗？能还得起这个房贷吗？如果将来你的儿子想住这么大的房子你买得起吗？</p><p>他就开始思考当初的初心，自己做自媒体是为了赚钱，现在家里有四个厂，家里父母也 50 了，回去帮忙岂不是能花更少的时间赚更多的钱。</p><p>所以他就关了自己的工作室，不再做自己不喜欢的视频，并且回家去继承家业。</p><p>看完这段视频莫名的感到了一丝心酸和无奈。</p><p><strong>心酸</strong>的是很多做自媒体(包括我自己)的刚开始都是做自己喜欢的东西，后来慢慢的为了粉丝向营销号靠拢，远离了自己的初心，这视频作者可以回家继承家产，而剩下的那些远离了初心的人又会何去何从呢？</p><p><strong>无奈</strong>的是即使家里这么有钱，不想靠着父母打拼出一番事业，但是在房贷的压力下，以及对自己能力确实不太能够打拼出一番事业，最后只能回家靠父母的无奈。</p><p>这种富二代他们一次一次的失败之后，还是会有退路(回家继承家产)，但是对于我们普通人来说，就没有退路，只能向前冲，就得努力赚钱。</p><p>但是在自己能力还没到的时候，做自己想做的事的时候，又赚不了那么多钱，所以只能违背这自己的初心，去赚一些合法的钱。</p><p>在这种金钱和自己喜欢的东西做斗争的时候，我无法给出应该选择哪种的建议。可能站在局外人来说，当然做自己喜欢的事儿呀，把事情做好，然后赚钱是自然的。</p><p>道理谁都懂，但是我觉得这是在考验人性的时候，当这件事儿发生在你的身上可能就不一定会这么做，因为我遇到太多太多这样的人了，只有非常少数的人能坚持自己的原则，这种人往往就缺少一个贵人，等待一个爆发期，但是在爆发期来临之前，又有多少人能坚持下来呢，很难说。</p><p>最后想说的是还是想做那个最初想做的人，<strong>把这个公众号做成自己喜欢的样子</strong>，提供一些在其他地方看不到的稀缺的有价值的东西，跟我公众号的 slogon 一样：<strong>成为自己想成为的那个样子。</strong> 每天花一小时来写文章，而不是花半个小时来找一篇好的文章。</p><p>其实我很希望你们可以给我多留言，多跟我<strong>交流</strong>你们的想法，而不是向我提一些问题，让我解答，两者之间的区别在于我们两是否在同一个水平，是否双方都会受益。</p><p>所以我喜欢你在请教我一些东西的时候，你已经做好了功课，咱们在此次对话中花了这么多时间，都能得到一些价值。</p><p>虽然我不是一个大 V，但是我还是很忙，有我自己的事儿，每天向我请教的人又特别多，我目前不想专门开一个付费的知识星球来回答问题，然后出售我的时间。</p><p>如果你希望和我交流，可以在公众号后台回复「微信」，联系到我。</p><p><strong>最后如果你还愿意继续关注我的话，可以留个言，点个好看，甚至帮我多转发文章。</strong></p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 年你应该知道的 React 库</title>
    <link href="/index.php/archives/300/"/>
    <url>/index.php/archives/300/</url>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本文为译文，原文链接：<a href="https://www.robinwieruch.de/react-libraries">https://www.robinwieruch.de/react-libraries</a></p></blockquote><p>React 已经诞生很久了，自从它诞生开始，围绕组件驱动形成了一个非常全面的生态，但是来自其他编程语言或者框架的开发人员很难找到要构建一个 React 系统的所有组件。如果你是来自于像 Angular 这样的框架的开发者，你可能已经习惯了框架包含了所需要的所有功能，</p><p>然而对于 React 来说，它的核心并不是完善所有的可选库。 这是优势还是劣势取决于你自己。 <a href="https://www.robinwieruch.de/reasons-why-i-moved-from-angular-to-react/">当我从 Angular 切换到 React</a>，我绝对经历了它作为 React 的优势。</p><p>只有通过 React，您才能使用<a href="https://www.robinwieruch.de/react-function-component">函数组件</a>和 <a href="https://www.robinwieruch.de/react-pass-props-to-component">props</a> 构建组件驱动的用户界面。 它带有一些内置的解决方案，例如，用于本地状态和副作用的 React Hooks。</p><p>下面的文章将向您提供一些自己总结的方法，以便从补充库中进行选择，从而构建一个全面的 React 应用程序。 </p><h2 id="如何开始-React"><a href="#如何开始-React" class="headerlink" title="如何开始 React"></a>如何开始 React</h2><p>如果你是一个完全不熟悉 React 的初学者想创建一个 React 项目，加入 React 的世界。有许多工具包项目可以选择，每个项目都试图满足不同的需求。 React 社区的现状是通过 Facebook 的 <a href="https://github.com/facebookincubator/create-react-app">create-react-app(CRA)</a>。 它提供了一个零配置的设置，并给你一个开箱即用并且简单的启动和运行的 React 应用程序。 所有的工具都对您隐藏起来了，但是最终要由您来更改这些工具。</p><p>如果你已经熟悉 React，你可以选择它流行的入门工具包之一: Next.js 和 Gatsby.js。 这两个框架都建立在 React 之上，因此你应该已经熟悉 React 的基本原理。 Next.js  用于服务器端渲染(如动态 web 应用程序) ，Gatsby.js 用于静态站点生成(如博客、登陆页面)。</p><p>如果您只是想了解这些初学者工具包是如何工作的，那么可以尝试<a href="https://www.robinwieruch.de/minimal-react-webpack-babel-setup">从头开始设置 React 项目</a>。 你将从一个基本的 HTML 和 JavaScript 项目开始，然后自己添加 React 和它的支持工具。</p><p>如果你想选择一个自定义样板项目，试着缩小你的要求。 样板文件应该是最小的，不要试图解决所有问题。 它应该针对你的问题。 例如，<a href="https://github.com/rwieruch/gatsby-firebase-authentication">gatsby-Firebase-authentication</a> 样板文件只在 Gatsby.js 中为您提供了完整的 Firebase 身份验证机制，但是其他所有内容都被省略了。</p><p><strong>建议：</strong></p><ul><li>create-react-app for React beginners/advanced </li><li>Gatsby.js for static websites in React</li><li>Next.js for server-side rendered React</li><li>custom React project to understand the underlying tools</li></ul><h2 id="React-状态管理"><a href="#React-状态管理" class="headerlink" title="React 状态管理"></a>React 状态管理</h2><p>React 带有内置的 hooks 来管理局部状态: useState、 useReducer 和 useContext。 所有这些都可以在 React 中用于复杂的本地状态管理。 它甚至可以模拟 Redux(Redux 是 React 的一个流行的状态管理库)。</p><p>所有 React 的内置 hooks 都非常适合本地状态管理。 当涉及到远程数据的状态管理时，如果远程数据带有 GraphQL 端点，我建议使用 Apollo Client。Apollo Client 的替代方案是 <a href="https://github.com/FormidableLabs/urql">urql</a> 和 <a href="https://relay.dev/">Relay</a>。</p><p>如果远程数据不是来自 GraphQL 端点，请尝试使用 React 的 Hooks 来管理它。 如果不行，像  <a href="https://www.robinwieruch.de/react-redux-tutorial">Redux</a> 或者 <a href="https://mobx.js.org/">MobX</a>/<a href="https://mobx-state-tree.js.org/">Mobx State tree</a> 这样的解决方案可能会有所帮助。</p><p>如果你想了解更多细节，请访问我的<a href="https://www.robinwieruch.de/react-state">综合状态管理反应教程</a>。</p><p><strong>推荐：</strong></p><ul><li>局部状态: React 的 useState, useReducer, useContext Hooks </li><li>通过 Graph QL 的远程状态: Apollo Client </li><li>通过 REST 的远程状态: React Hooks or Redux/MobX/Mobx State Tree </li></ul><h2 id="使用-React-路由"><a href="#使用-React-路由" class="headerlink" title="使用 React 路由"></a>使用 React 路由</h2><p>路由在 React 中起着重要作用。 毕竟，React 可以帮助您实现在客户端处理路由的单页应用程序。 当介绍一个复杂的路由 的时候，有好几个路由解决方案。 最值得推荐的解决方案是 <a href="https://github.com/ReactTraining/react-router">React Router</a>。</p><p>在您引入路由以前，您可以先尝试 <a href="https://www.robinwieruch.de/conditional-rendering-react">React 的条件渲染</a>，它虽然不是路由的合理替代，但是小型应用中以及足够用了。</p><p><strong>建议:</strong></p><ul><li>React Router </li></ul><h2 id="React-中的样式库"><a href="#React-中的样式库" class="headerlink" title="React 中的样式库"></a>React 中的样式库</h2><p>虽然关于 React 样式处理有很多解决方法，但是作为一个 React 初学者，刚开始使用内联样式和基本 CSS 是很好的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./Headline.css&#x27;</span>;<br><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123; title &#125;</span>) =&gt;</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;headline&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">color:</span> &#x27;<span class="hljs-attr">blue</span>&#x27; &#125;&#125;&gt;</span></span><br><span class="xml">  &#123;title&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>虽然内联样式可以用 JavaScript 在 React 中动态地添加样式，但是一个外部的 CSS 文件可以拥有 React 应用程序的所有剩余样式。 一旦您的应用程序增长，还有许多其他样式方案选择。</p><p>首先，我建议您研究一下 CSS Modules，将其作为 CSS-in-CSS 解决方案之一。 CSS Modules 受到 create-react-app 的支持，并为您提供了将 CSS 封装到模块中的方法。 这样，它就不会意外地泄漏到其他人的样式中。 尽管应用程序的某些部分仍然可以共享样式，但其他部分不必访问它。 在 React 中，CSS Modules 通常将 CSS 文件与 React 组件文件共存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styles <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./style.css&#x27;</span>;<br><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123; title &#125;</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&#123;styles.headline&#125;</span>&gt;</span></span><br><span class="xml">    &#123;title&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>其次，我想推荐的是被称作为 styled components，作为 React 的 CSS-in-JS 解决方案之一。 这个方法是由一个名为 <a href="https://www.robinwieruch.de/react-styled-components">styled-components</a>  的库提供的，它将样式与 JavaScript 共享到 React 组件的旁边:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> styled <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;styled-components&#x27;</span>;<br><span class="hljs-keyword">const</span> BlueHeadline = styled.h1<span class="hljs-string">`</span><br><span class="hljs-string">  color: blue;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123; title &#125;</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BlueHeadline</span>&gt;</span></span><br><span class="xml">    &#123;title&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">BlueHeadline</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>第三，我想推荐 <a href="https://tailwindcss.com/">Tailwind CSS</a> 作为一个函数式的 CSS 解决方案:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Headline = <span class="hljs-function">(<span class="hljs-params">&#123; title &#125;</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;text-blue-700&quot;</span>&gt;</span></span><br><span class="xml">    &#123;title&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>是否选择 CSS in CSS、 CSS in js 或函数式 CSS 取决于您。 所有的策略都适用于大型的 React 应用程序。</p><p><strong>建议:</strong></p><ul><li>CSS-in-CSS with CSS Modules </li><li>CSS-in-JS with Styled Components </li><li>Functional CSS with Tailwind CSS </li></ul><h2 id="React-UI-库"><a href="#React-UI-库" class="headerlink" title="React UI 库"></a>React UI 库</h2><p>如果您不想从头开始构建所有必要的 React UI 组件，您可以选择 React UI Library 来完成这项工作。 所有这些都有一些基本的组件，比如按钮，下拉菜单，对话框和列表。 有很多 UI 库可供 React 选择:</p><ul><li><a href="https://ant.design/">Ant Design</a></li><li><a href="https://chakra-ui.com/">Chakra UI</a></li><li><a href="https://www.tailwindui.com/">Tailwind UI </a></li><li><a href="https://www.robinwieruch.de/react-semantic-ui-tutorial">Semantic UI </a></li><li><a href="https://material-ui.com/">Material UI </a></li><li><a href="https://react-bootstrap.github.io/">React Bootstrap 1. React Bootstrap</a></li></ul><h2 id="React-动画"><a href="#React-动画" class="headerlink" title="React 动画"></a>React 动画</h2><p>任何 web 应用程序中的动画都是从 CSS 开始的。 最终你会发现 CSS 动画并不能满足你的需求。 通常开发人员会检查 <a href="https://reactcommunity.org/react-transition-group/">React Transition Group</a>，这样他们就可以使用 React 组件执行动画。 其他著名的 React 动画库有:</p><ul><li><a href="https://github.com/chenglou/react-motion">react-motion </a></li><li><a href="https://github.com/react-spring/react-spring">react-spring </a></li><li><a href="https://www.framer.com/motion/">Framer Motion</a></li><li><a href="https://facebook.github.io/react-native/docs/animated">Animated </a> (React Native)</li></ul><p><strong>建议:</strong></p><ul><li>React Transition Group</li></ul><h2 id="React-可视化和图表库"><a href="#React-可视化和图表库" class="headerlink" title="React 可视化和图表库"></a>React 可视化和图表库</h2><p>如果你真的想自己从头开始构建图表，你没办法不去学习 <a href="https://d3js.org/">D3</a> 。 这是一个底层的可视化库，它为你提供了创建令人惊叹的图表所需的一切。 然而，学习 D3 是一个完全不同的冒险，因此许多开发人员只是想选择一个 React 图表库，它可以为他们做任何事情，以换取灵活性。 以下是一些流行的解决方案:</p><ul><li><a href="https://nivo.rocks/">nivo</a></li><li><a href="https://formidable.com/open-source/victory/">Victory </a></li><li><a href="https://uber.github.io/react-vis/">react-vis</a></li><li><a href="http://recharts.org/">Recharts</a></li><li><a href="https://microsoft.github.io/chart-parts/">Chart Parts </a></li></ul><h2 id="React-中的表单库"><a href="#React-中的表单库" class="headerlink" title="React 中的表单库"></a>React 中的表单库</h2><p>在 React 中最流行的表单库是 <a href="https://github.com/jaredpalmer/">Formik</a>。 它提供了从验证到提交到形成状态管理所需的一切。另外一个选择是 <a href="https://react-hook-form.com/">React Hook Form</a>。 如果您开始使用更复杂的表单，这两种方法对于 React 应用程序都是有效的解决方案。</p><p><strong>建议:</strong></p><ul><li>Formik</li><li>React Hook Form </li></ul><h2 id="React-中的数据获取库"><a href="#React-中的数据获取库" class="headerlink" title="React 中的数据获取库"></a>React 中的数据获取库</h2><p>很快，您就必须向远程 API 发出请求，以便在 React 中获取数据。 现代浏览器带有本地获取 API 来执行异步数据请求:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  React.useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = fetch(my/api/domain)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>      .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>        <span class="hljs-comment">// do success handling</span><br>        <span class="hljs-comment">// e.g. store in local state</span><br>      &#125;);<br>    setData(result.data);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    ...<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>基本上，你不需要添加任何其他库来完成这项工作。 但是，有时候不仅需要提供复杂的异步请求，还需要它们具有更强大的功能，而且只是一个轻量级的库。 我推荐的这些库之一称为 axios。 当您的应用程序增大时，可以使用它来代替本地获取 API。</p><p>如果您有足够的时间来处理 GraphQL API，我建议您使用 Apollo Client。 可供选择的 GraphQL 客户端将是 urql 或 Relay。</p><p><strong>建议:</strong></p><ul><li>浏览器的本地 fetch API</li><li>axios</li><li>Apollo Client </li></ul><h2 id="React-类型检查"><a href="#React-类型检查" class="headerlink" title="React 类型检查"></a>React 类型检查</h2><p>幸运的是 React 有自己的类型检查能力。 使用 PropTypes，你可以为你的 React 组件定义传入的 props。 无论何时向组件传递了错误的类型，在运行应用程序时都会收到错误消息。 但是这种形式的类型检查只应该用于较小的应用程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> PropTypes <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;prop-types&#x27;</span>;<br><span class="hljs-keyword">const</span> List = <span class="hljs-function">(<span class="hljs-params">&#123; list &#125;</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    &#123;list.map(item =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>List.propTypes = &#123;<br>  <span class="hljs-attr">list</span>: PropTypes.array.isRequired,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在较大的 React 应用程序中，TypeScript 为整个应用程序增加了类型安全性，而不是使用 React PropTypes。 当使用这样的类型检查器时，您可以在开发期间获得错误。 您不必启动应用程序就可以找到本可以通过这种类型检查防止的 bug。 这样一来，类型检查器就可以提高您的开发人员体验，避免首先引入 bug。</p><p><strong>建议:</strong></p><ul><li>TypeScript</li></ul><h2 id="React-代码风格"><a href="#React-代码风格" class="headerlink" title="React 代码风格"></a>React 代码风格</h2><p>对于代码风格，基本上有三个选项可以用的。</p><p>第一种方法是遵循一个被社区所接受的风格指南。 一个流行的 Airbnb 开源的<a href="https://github.com/airbnb/javascript/tree/master/react">React style guide</a> 。 即使你没有刻意遵循这些样式指南，但是读一读它们，在 React 中获得常见代码样式的要点是有意义的。</p><p>第二种方法是使用 linter，比如 ESLint。 虽然样式指南只给出建议，但是 linter 在应用程序中强制执行这个建议。 例如，你可以要求遵循流行的 Airbnb 样式指南，你的 IED/编辑器会告诉你每一个错误。</p><p>第三种也是最流行的方法是使用 Prettier。 它是一个强制的代码格式化程序。 您可以将其集成到编辑器或 IDE 中，使其在每次保存文件时格式化您的代码。 也许它并不总是符合您的口味，但至少您不必再担心自己或团队代码库中的代码格式。 虽然 Prettier 不能取代 ESLint，但是它与 ESLint 的集成非常好。</p><p><strong>建议:</strong></p><ul><li>ESLint</li><li>Prettier </li></ul><h2 id="React-认证"><a href="#React-认证" class="headerlink" title="React 认证"></a>React 认证</h2><p>在较大的 React 应用程序中，您可能希望引入具有注册、登录和退出功能的身份验证。 此外，密码重置和密码更改功能往往是需要的。 这些特性远远超出了 React，因为后端应用程序为您管理这些事情。 </p><p>通常的方法是使用自定义身份验证实现自己的自定义后端应用程序。 如果您不想启动自己的身份验证，可以考虑类似 <a href="http://www.passportjs.org/">Passport.js</a> 的东西。</p><p>如果你根本不想关心后端，以下三种解决方案可能适合你:</p><ul><li><a href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial/">Firebase</a></li><li><a href="https://auth0.com/">Auth0</a></li><li><a href="https://aws.amazon.com/cognito/">AWS Cognito </a></li></ul><p>如果您正在寻找身份验证 + 数据库的一体化解决方案，请坚持使用 Firebase 或 AWS。</p><p>建议:</p><ul><li>DIY: Custom Backend </li><li>Get it off the shelf: Firebase </li></ul><h2 id="React-主机"><a href="#React-主机" class="headerlink" title="React 主机"></a>React 主机</h2><p>您可以像其他 web 应用程序一样部署和托管 React 应用程序。 如果你想拥有完全的控制权，选择像<a href="https://m.do.co/c/fb27c90322f3">Digital Ocean</a>这样的。 如果你希望有人来处理所有的事情，如果你已经在使用第三方的身份验证/数据库，Netlify 是一个很受欢迎的解决方案，比如 Firebase，你可以检查他们是否也提供主机服务(比如 Firebase Hosting)。 您还可以使用 S3的静态站点与 Cloudfront 一起托管。</p><h2 id="React-测试"><a href="#React-测试" class="headerlink" title="React 测试"></a>React 测试</h2><p>如果您想深入了解 React 中的测试，请阅读以下内容: <a href="https://www.robinwieruch.de/react-testing-tutorial">How to test components in React</a>。 要点如下: 测试 React 应用程序的主干是 Jest。 它提供了测试运行程序、断言库和监视(spying)/模拟(mocking)/stubbing 功能， 一个全面的测试框架中需要的所有东西。</p><p>至少，您可以使用 <a href="https://reactjs.org/docs/test-renderer.html">React-test-renderer</a> 在 Jest 测试中渲染 React 组件。 这已经足以用 jest 来执行所谓的<a href="https://www.robinwieruch.de/react-testing-jest">快照测试</a>了。 快照测试的工作方式如下: 运行测试之后，将创建 React 组件中渲染的 DOM 元素的快照。 当您在某个时间点再次运行测试时，将创建另一个快照，用作前一个快照的差异。 如果 diff 不完全相同，则 Jest 将报错，您要么必须接受快照，要么必须更改组件的实现。</p><p>最终，您会发现自己在使用 Enzyme 或 React Testing Library (这两个都在 Jest 测试环境中使用)来进行更详细的测试功能集。 这两个库使得在 HTML 元素上呈现组件和模拟事件成为可能。 然后，Jest 用于 DOM 节点上的断言。</p><p>如果您正在为 React-to-end (E2E)测试寻找测试工具，Cypress 是最受欢迎的选择。</p><p>建议:</p><ul><li>Unit/Integration/Snapshot Tests: Jest + React Testing Library</li><li>E2E Tests: Cypress 2e test: Cypress</li></ul><h2 id="用于-React-的工具库"><a href="#用于-React-的工具库" class="headerlink" title="用于 React 的工具库"></a>用于 React 的工具库</h2><p>Javascript 为处理数组、对象、数字、对象和字符串提供了大量内置功能。 React 中最常用的 JavaScript 内置功能之一是内置 <code>map()</code> 数组。 为什么？ 因为您总是必须呈现组件中的列表。 由于 JSX 是 HTML 和 JavaScript 的混合物，所以您可以使用 JavaScript 在数组上进行映射并返回 JSX。 使用 React 创建列表组件变得简单:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> List = <span class="hljs-function">(<span class="hljs-params">&#123; list &#125;</span>) =&gt;</span><br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    &#123;list.map(item =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span>&gt;</span>&#123;item.title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>但是，您可能需要选择一个实用程序库来提供更详细的功能。 您甚至可能希望在将这些实用函数链接起来时更加灵活，甚至可以将它们动态地组合在一起。 这时，您将引入一个实用程序库: Lodash 或 Ramda。 对于每一个 JavaScript 开发者来说，Lodash 是一个更加实际的库，而 Ramda 在函数式编程中有一个强大的核心。 请记住，现代 JavaScript 提供了很多开箱即用的特性，现在使用实用程序库的必要性已经降低了。</p><p><strong>建议:</strong></p><ul><li>JavaScript</li><li>Lodash </li></ul><h2 id="react-和不可变的数据机构"><a href="#react-和不可变的数据机构" class="headerlink" title="react 和不可变的数据机构"></a>react 和不可变的数据机构</h2><p>原生 JavaScript 提供了大量内置工具来处理数据结构，就像它们是不可变的一样。 但是，如果您和您的团队认为有必要实施不可变的数据结构，最流行的选择之一是 Immer。 就我个人而言，我不使用它，但是任何时候有人问到 JS 中的不变性(immutability)，大家都会指出 Immer，并且这可以加上 redux 或 React hooks。</p><h2 id="React-国际化"><a href="#React-国际化" class="headerlink" title="React 国际化"></a>React 国际化</h2><p>当涉及到 <a href="https://www.robinwieruch.de/react-internationalization">React 应用程序的国际化</a>  时，您不仅需要考虑翻译，还需要考虑多元化、日期和货币的格式化，以及其他一些事项。 以下是最受欢迎的处理该问题的库:</p><ul><li><a href="https://github.com/i18next/react-i18next">react-i18next</a></li><li><a href="https://github.com/formatjs/react-intl">react-intl</a></li><li><a href="https://lingui.js.org/index.html">LinguiJS</a></li><li><a href="https://github.com/facebookincubator/fbt">FBT</a></li></ul><p><strong>建议:</strong></p><ul><li>react-i18next </li></ul><h2 id="React-富文本编辑器"><a href="#React-富文本编辑器" class="headerlink" title="React 富文本编辑器"></a>React 富文本编辑器</h2><p>当涉及到在 React 中的富文本编辑器时，我只能想到以下内容，因为我没有在 React 中使用任何其他内容:</p><ul><li><a href="https://draftjs.org/">Draft.js</a></li><li><a href="https://github.com/ianstormtaylor/slate">Slate</a></li></ul><h2 id="React-中的支付"><a href="#React-中的支付" class="headerlink" title="React 中的支付"></a>React 中的支付</h2><p>和其他网络应用一样，最常见的支付提供商是 Stripe 和 PayPal。 两者都可以整齐地集成到 React 中。 </p><ul><li><a href="https://developer.paypal.com/docs/checkout/">PayPal </a></li><li><a href="https://github.com/stripe/react-stripe-elements">Stripe Elements </a> 或 <a href="https://stripe.com/docs/payments/checkout">Stripe Checkout</a></li></ul><h2 id="React-中的时间"><a href="#React-中的时间" class="headerlink" title="React 中的时间"></a>React 中的时间</h2><p>如果你的 React 应用程序正在处理大量的日期和时区，你应该引入一个库来为你管理这些事情。 最受欢迎的库是 <a href="https://momentjs.com/">moment.js</a>。 更轻量级的替代品是 <a href="https://github.com/date-fns/date-fns">date-fns</a> 和 <a href="https://github.com/iamkun/dayjs">Day.js</a>。</p><h2 id="Reac-桌面应用"><a href="#Reac-桌面应用" class="headerlink" title="Reac 桌面应用"></a>Reac 桌面应用</h2><p>Electron 是跨平台桌面应用程序的首选框架。 不过，也有其他选择，例如:</p><ul><li><a href="https://nwjs.io/">NW.js</a></li><li><a href="https://github.com/neutralinojs/neutralinojs">Neutralino.js</a></li></ul><h2 id="React-的移动开发"><a href="#React-的移动开发" class="headerlink" title="React 的移动开发"></a>React 的移动开发</h2><p>我想把 React 从网络带到移动设备的首选解决方案仍然是 React Native。 如果您是 React Native 开发人员，想要创建一个 Web 应用程序，您应该查看 <a href="https://github.com/necolas/react-native-web">React Native Web</a>。</p><h2 id="REACT-VR-AR"><a href="#REACT-VR-AR" class="headerlink" title="REACT VR/AR"></a>REACT VR/AR</h2><p>实话说，我们很有可能用 React 深入虚拟现实或者增强现实中，我没有使用过这些库中的任何一个，但是它们是我在谈到 React AR/VR 时从大脑闪过的就是：</p><ul><li><a href="https://facebook.github.io/react-360/">React 360</a></li><li><a href="https://www.npmjs.com/package/react-viro">react-viro</a></li><li><a href="https://github.com/react-native-ar/react-native-arkit">react-native-arkit</a></li></ul><h2 id="为-React-设计原型"><a href="#为-React-设计原型" class="headerlink" title="为 React 设计原型"></a>为 React 设计原型</h2><p>如果您来自 UI/UX 背景，那么您可能希望使用一个工具为新的 React 组件、布局或 UI/UX 概念进行快速原型设计。 我以前用过 Sketch，但最近转到了 <a href="https://www.framer.com/">Figma</a>。 尽管我两者都喜欢，但我现在并不后悔使用 Figma。 另一个流行的工具是 Framer。</p><h2 id="为-React-书写文档"><a href="#为-React-书写文档" class="headerlink" title="为 React 书写文档"></a>为 React 书写文档</h2><p>如果你负责为你的软件、 UI 库或者其他东西编写文档，那么你可以使用一些简洁的 React 文档工具。 我已经广泛地使用了 Storybook，我可以说他非常好用，但是我也听说了其他解决方案的好处:</p><ul><li><a href="https://react-styleguidist.js.org/">Styleguidist</a></li><li><a href="https://www.docz.site/">docz</a></li><li><a href="https://docusaurus.io/">Docusaurus</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以最终，React 生态系统可以看作是一个 React 的框架，但它保持灵活性。 它是一个灵活的框架，您可以自己决定选择哪些库。 您可以从小型开始，只添加库来解决特定的问题。 当应用程序增长时，您可以沿途扩展构建块。 否则你可以通过使用普通的 React 来保持轻量级。 因此，这里再次列出了可以补充 React 作为应用程序关于不同项目大小的核心的库。 请记住，这个列表是我的个人看法，我也渴望得到你的反馈。</p><h3 id="小型应用程式"><a href="#小型应用程式" class="headerlink" title="小型应用程式"></a>小型应用程式</h3><ul><li><strong>样板</strong>: create-react-app</li><li><strong>样式库:</strong> basic CSS and inline style</li><li><strong>异步请求</strong>: fetch or axios </li><li><strong>代码风格:</strong> 无</li><li><strong>类型检查:</strong> 无</li><li><strong>状态管理:</strong>  React Hooks </li><li><strong>路由:</strong> 无 or React Router</li><li><strong>身份验证:</strong> Firebase</li><li><strong>数据库:</strong> Firebase</li><li><strong>UI 库:</strong> none</li><li><strong>表单库:</strong> 无</li><li><strong>测试库:</strong> Jest</li><li><strong>实用程序库:</strong> JavaScript</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><h3 id="中型应用"><a href="#中型应用" class="headerlink" title="中型应用"></a>中型应用</h3><ul><li><strong>样板文件:</strong> Next.js or Gatsby.js</li><li><strong>样式库:</strong> CSS Modules or Styled Components</li><li><strong>异步请求:</strong> fetch or axios</li><li><strong>代码风格:</strong> Prettier，ESLint</li><li><strong>类型检查:</strong> 无 或 TypeScript</li><li><strong>状态管理:</strong> React Hooks and/or Apollo </li><li><strong>路由:</strong> React Router </li><li><strong>身份验证:</strong> Firebase</li><li><strong>数据库:</strong> Firebase</li><li><strong>Ui 库:</strong> none 或 UI 组件库</li><li><strong>表单库:</strong> none 或 Formik 或 React Hook Form</li><li><strong>测试库:</strong> Jest with React Testing Library</li><li><strong>实用程序库:</strong> JavaScript</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><h3 id="大型应用程序"><a href="#大型应用程序" class="headerlink" title="大型应用程序"></a>大型应用程序</h3><ul><li><strong>样板文件:</strong> Next.js, Gatsby.js, custom setup</li><li><strong>样式库:</strong>  CSS Modules or Styled Components</li><li><strong>异步请求:</strong> axios 或 Apollo Client</li><li><strong>代码风格:</strong> Prettier，ESLint</li><li><strong>类型检查:</strong> TypeScript</li><li><strong>状态管理:</strong> React Hooks and/或者 Apollo/Redux/MobX </li><li><strong>路由:</strong> React Router</li><li><strong>认证:</strong>  Node.js 服务 + Passport.js</li><li><strong>数据库:</strong> 自己用SQL/NoSQL DB 提供 Node.js 服务</li><li><strong>Ui 库:</strong> UI 组件库或者您自己的 UI 组件</li><li>**表单库:**none 或者 Formik 或者 React Hook Form</li><li><strong>测试库:</strong> Jest with React Testing Library and Cypress</li><li><strong>实用程序库:</strong> JavaScript 的 api，Lodash</li><li><strong>国际化:</strong> react-i18next</li><li><strong>React 桌面:</strong> Electron</li></ul><p>以前的建议是个人的。 您可以为理想的 React 应用程序选择自己的灵活框架。 每一个“理想”的 React 设置都是主观的，取决于开发人员和项目的需求。 毕竟，没有理想的 React 应用程序设置。</p>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读者问题|关于如何学习的讨论</title>
    <link href="/index.php/archives/299/"/>
    <url>/index.php/archives/299/</url>
    
    <content type="html"><![CDATA[<p>一个读者的困惑，我做了简单的解答，希望能对他有所帮助。</p><p>##<img src="http://imgs.taoweng.site/2020-01-13-152255.png" alt="image-20200113232252758"></p><p>##1. 如何把一个知识由浅入深的学习？</p><p>见问题 2</p><p>##2. 那些写技术文章的作者，为什么对某一知识或某一框架理解得那么深入，是如何学习的呢？</p><p>我觉得有以下几点：</p><ol><li>使用的多，踩得坑多，经验丰富。</li><li>花时间深入研究过原理。</li><li>思考过这个东西的价值以及为什么会出现(这个点很容易被忽略，我的那篇从<a href="http://www.taoweng.site/index.php/archives/293/"><strong>历史的长河中聊虚拟 DOM 的意义</strong></a>就是这个点)。</li><li>思考过这个东西能给自己的业务带来什么帮助，然后紧密的结合到自己的项目中。</li></ol><p>如果你觉得这几个点感觉你都懂，那我问你几个问题，比如你在你们公司想引入 React 来做项目。</p><ul><li>问题一：你为什么要用 React？</li><li>问题二：用 React 能带来什么好处？</li><li>问题三：如果用 Vue 或者 JQuery 能行吗？</li><li>问题四：React 适合哪些场景？哪些场景又不适用？</li><li>问题五：你觉得 React 存在的意义是什么？</li><li>问题六：React 有什么缺点？</li><li>问题七：你觉得引入 React 会有什么成本，收益和成本如何进行平衡？</li></ul><p>我想表达的是在学习一个东西，或者说想深入一个知识，不仅仅知道它是什么，怎么用，还要去了解它为什么会产生，能带来什么价值，解决了什么问题。这样在你判断是否引入这门新技术才有充足的理由，否则就是追风，看到这个东西比较火，可能你根本就不需要，然后引入了反而给自己增加负担。</p><p>在你想知道它解决了什么问题的时候，可能就会思考为什么它能解决这个问题，然后再去寻找这个答案的时候就会深入他的原理，加上自己大量的实践，慢慢的就成为这个东西的专家了。</p><p>##3. 什么时候去接触和怎么去学一些规范文档？</p><p>我想你说的规范文档应该是官方文档这种吧，然后下面讨论的都是基于官方文档。</p><p>官方文档我一直是把它当做完善我知识体系的东西来看待的，而不是入门教程。毕竟官方文档是给所有人写的，不管你是没使用过的，还是使用过很长时间的，所以就导致大部分的内容都是比较官方的，所以就导致不一定适合你。所以才有了各种各样的教程，因为每个人的所拥有的知识不一样。</p><p>另外官方文档也不会告诉你哪个知识点重要，哪个知识点常用，它只会告诉你有这个东西，这些东西都是需要在实战中去得知。</p><p>特别是对于 CSS 标准，或者 Javascript 标准这种，不到万不得已是不会去看的，东西又多，又不适合新手阅读，但是在你看到网上有不同答案的时候，就非常适合去看标准，平时就看看书、看看博客、看看视频教程就行。</p><h2 id="4-如何处理网上的技术文章以及实体书？"><a href="#4-如何处理网上的技术文章以及实体书？" class="headerlink" title="4. 如何处理网上的技术文章以及实体书？"></a>4. 如何处理网上的技术文章以及实体书？</h2><p>我觉得首先要明白文章和书的区别是什么，然后才能正确的去使用他们。</p><p>我们一般对书的认知是对知识成体系的介绍，书是比较的全，是对整个知识比较全面的介绍，另外由于写书比较的耗时，所以往往书里面的内容都是晚于知识点出来很久的，比较适合那种很久不会变的知识。</p><p>知道了书的特性，那么我们何时需要去读书呢？</p><p>我觉得应该是在你想打造或者说完善你自己的<strong>知识体系</strong>的时候就一定要去读书，特别是像那种《xxx权威指南》这种，就特别的适合用来完善知识体系的。</p><p>但是一本书不可能把方方面面讲完，都是会有侧重点的，就拿学习 JavaScript 来说，想学好《JavaScript高级程序设计》又称<strong>红宝书</strong>、《JavaScript权威指南》又称<strong>犀牛书</strong>是不应该绕过的，那么这两本书又有什么区别呢，这两本书都很厚，理论上讲得都很全。</p><p>这两本书都会把 JavaScript 最重要的东西肯定都是会介绍的，但是红宝书侧重于程序设计，相对来说比较注重实战一点，所以对于原型、继承这种在程序设计方面较多的知识点会用大量的篇幅，然后举很多的例子，这样更利于我们的程序设计。</p><p>而对于犀牛书的话他的侧重点在于<strong>权威</strong>，那么他的侧重点就在于全，要比所有的 JavaScript 的书都介绍的更全，相对来说比较偏理论。</p><p>因为每本书都会有自己的特点，就是侧重点不同，所以在看实体书的时候就要看自己需求，如果想提高自己的程序设计能力，就看红宝书，如果想查漏补缺，看看自己是否对 JavaScript 全面了解，就看犀牛书。</p><p>其他的书也一样，对于技术书我一般的习惯都是带着目的去看，而不是像一些<strong>消费型</strong>的书随便翻。</p><p>再说说技术文章，技术文章他的特点就是可以做到很新，但是质量参差不齐，而且很容易传播错误的知识。</p><p>因为文字的复制能力太强了，然后对版权又没有很高的要求，所以很多技术文章都是东抄一点，西改一点，所以导致有可能一个错误的观点，然后很多人在写文章的时候都去引用了，当你看到不一样的时候就会懵逼了，到底哪个是对的呢？</p><p>最后总结一下，对于想深入和全面的掌握一项技术的时候，一定要去看书，而对于新东西，或者很小的知识点看技术博客是非常好的渠道，具体怎么去处理，真的得看自己是想把这个知识学到什么程度，想学深就一定得看书。</p><h2 id="5-真对你的状况的回答。"><a href="#5-真对你的状况的回答。" class="headerlink" title="5. 真对你的状况的回答。"></a>5. 真对你的状况的回答。</h2><p>我觉得上面回答的东西已经给你答案了，在第三条。</p><p>另外我想补充你说的 <strong>有时候真的一篇接着一篇就学不完</strong>我想说两点：</p><ol><li>每个人都不可能什么都会，我觉得应该多思考目前对于自己重要的是什么，然后再针对性的学习，而不是看到什么新东西就去学。</li><li>对于一个知识点应该有那种通过自己的逻辑把这个知识点解释通的习惯，而不仅仅是看别人是怎么介绍这个东西的，别人写的东西是在给你查漏补缺的。我自己很有体会的就是关于函数式编程和 React 原理相关的，我觉得我自己有一套理论，花了很多时间去研究出来的，这样我再看别人的文章我心里就很有数，虽然用不同的方式去解释，想表达的东西是一样的，所以一旦你自己对某个点再花了大量时间去研究，有深刻的认识的时候，你会发现别人写的东西你早就知道了。比如你自己把原型的东西搞得很明白了，能给小白都能讲懂，以后大部分的原型相关的文章就可以不看了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你可能不知道的 React Hooks</title>
    <link href="/index.php/archives/296/"/>
    <url>/index.php/archives/296/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是译文，原文地址是：<a href="https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb">https://medium.com/@sdolidze/the-iceberg-of-react-hooks-af0b588f43fb</a></p></blockquote><p><strong>React Hooks</strong> 与类组件不同，它提供了用于优化和组合应用程序的简单方式，并且使用了最少的样板文件。</p><p>如果没有深入的知识，由于微妙的 bug 和抽象层漏洞，可能会出现性能问题，代码复杂性也会增加。</p><p>我已经创建了12个案例研究来演示常见的问题以及解决它们的方法。 我还编写了 <strong>React Hooks Radar</strong> 和 <strong>React Hooks Checklist</strong>，来推荐和快速参考。</p><h2 id="案例研究：-实现-Interval"><a href="#案例研究：-实现-Interval" class="headerlink" title="案例研究： 实现 Interval"></a>案例研究： 实现 Interval</h2><p>目标是实现计数器，从 0 开始，每 500 毫秒增加一次。 应提供三个控制按钮: 启动、停止和清除。</p><p><img src="http://imgs.taoweng.site/2020-01-05-134726.gif"></p><h3 id="Level-0：Hello-World"><a href="#Level-0：Hello-World" class="headerlink" title="Level 0：Hello World"></a>Level 0：Hello World</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level00</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel00&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count - 1)&#125;&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个简单的、正确实现的计数器，用户单击时计数器的增加或减少。</p><h3 id="Level-1：setInterval"><a href="#Level-1：setInterval" class="headerlink" title="Level 1：setInterval"></a>Level 1：setInterval</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level01</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel01&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count =&gt; &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此代码的目的是每 500 毫秒增加计数器。 这段代码存在巨大的<strong>内存泄漏</strong>并且实现不正确。 它很容易让浏览器标签崩溃。 由于 Level01 函数在每次渲染发生时被调用，所以每次触发渲染时这个组件都会创建新的 interval。</p><blockquote><p><em>突变、订阅、计时器、日志记录和其他副作用不允许出现在函数组件的主体中(称为 React 的 render 阶段)。 这样做会导致用户界面中的错误和不一致。</em></p></blockquote><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a></p><h3 id="Level-2：useEffect"><a href="#Level-2：useEffect" class="headerlink" title="Level 2：useEffect"></a>Level 2：useEffect</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level02</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel02&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Level 2: count =&gt; &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数副作用放在  <code>useEffect</code> 内部。 但是此代码还有巨大的资源泄漏，并且实现不正确。 <code>useEffect</code>  的默认行为是在每次渲染后运行，所以每次计数更改都会创建新的 <strong>Interval</strong>。</p><p> <a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a>, <a href="https://reactjs.org/docs/hooks-reference.html#timing-of-effects">Timing of Effects</a>.</p><h3 id="Level-3-只运行一次"><a href="#Level-3-只运行一次" class="headerlink" title="Level 3: 只运行一次"></a>Level 3: 只运行一次</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level03</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel03&#x27;</span>);<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);<br>  useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">300</span>);<br>  &#125;, []);<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>count =&gt; &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>将**[]**作为 <code>useEffect</code> 的第二个参数，将在 mount 之后只调用一次 function。，即使只调用一次 setInterval，这段代码的实现也是不正确的。</p><p>虽然 <strong>count</strong> 会从 <strong>0</strong> 增加到 <strong>1</strong>，但是不会再增加，只会保持成 <strong>1</strong>。 因为箭头函数只被创建一次，所以箭头函数里面的 <strong>count</strong> 会一直为 0.</p><p>这段代码也存在微妙的资源泄漏。 即使在组件卸载之后，仍将调用 setCount。</p><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a>, <a href="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect">Conditionally firing an effect</a>.</p><h3 id="Level-4：清理"><a href="#Level-4：清理" class="headerlink" title="Level 4：清理"></a>Level 4：清理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(count + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">300</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);<br>  &#125;, []);<br></code></pre></td></tr></table></figure><p>为了防止资源泄漏，Hooks 的生命周期结束时，必须清理所有内容。 在这种情况下，组件卸载后将调用返回的函数。</p><p>这段代码没有资源泄漏，但是实现不正确，就像之前的代码一样。</p><p> <a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#cleaning-up-an-effect">Cleaning up an effect</a>.</p><h3 id="Level-5：使用-count-作为依赖项"><a href="#Level-5：使用-count-作为依赖项" class="headerlink" title="Level 5：使用 count 作为依赖项"></a>Level 5：使用 count 作为依赖项</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);<br>&#125;, [count]);<br></code></pre></td></tr></table></figure><p>给 <strong>useEffect</strong> 提供依赖数组会改变它的生命周期。 在这个例子中，<strong>useEffect</strong> 在 <strong>mount</strong> 之后会被调用一次，并且每次 <code>count</code> 都会改变。 清理函数将在每次 <code>count</code> 更改时被调用以释放前面的资源。</p><p>这段代码工作正常，没有任何错误，但是还是有点不好，每 500 毫秒创建和释放 setInterval， 每个 setInterval 总是调用一次。</p><p> <a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#useeffect">useEffect</a>, <a href="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect">Conditionally firing an effect</a>.</p><h3 id="Level-6：setTimeout"><a href="#Level-6：setTimeout" class="headerlink" title="Level 6：setTimeout"></a>Level 6：setTimeout</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(count + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearTimeout</span>(timeout);<br>&#125;, [count]);<br></code></pre></td></tr></table></figure><p>这段代码和上面的代码可以正常工作。 因为 useEffect 是在每次 count 更改时调用的，所以使用 setTimeout 与调用 setInterval 具有相同的效果。</p><p>这个例子效率很低，每次渲染发生时都会创建新的 setTimeout，React 有一个更好的方式来解决问题。</p><h3 id="Level-7：useState-的函数更新"><a href="#Level-7：useState-的函数更新" class="headerlink" title="Level 7：useState 的函数更新"></a>Level 7：useState 的函数更新</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>  &#125;, <span class="hljs-number">500</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(interval);<br>&#125;, []);<br></code></pre></td></tr></table></figure><p>在前面的例子中，我们对每次 <strong>count</strong> 更改运行 <strong>useEffect</strong>，这是必要的，因为我们需要始终保持最新的当前值。</p><p><strong>useState</strong> 提供 API 来更新以前的状态，而不用捕获当前值。 要做到这一点，我们需要做的就是向 setState 提供 lambda(匿名函数)。</p><p>这段代码工作正常，效率更高。 在组件的生命周期中，我们使用单个 <code>setInterval</code>， <code>clearInterval</code> 只会在卸载组件之后调用一次。</p><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#usestate">useState</a>, <a href="https://reactjs.org/docs/hooks-reference.html#functional-updates">Functional updates</a>.</p><h3 id="Level-8：局部变量"><a href="#Level-8：局部变量" class="headerlink" title="Level 8：局部变量"></a>Level 8：局部变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level08</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel08&#x27;</span>);  <br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);  <br>  <span class="hljs-keyword">let</span> interval = <span class="hljs-literal">null</span>;  <br>  <br>  <span class="hljs-keyword">const</span> start = <span class="hljs-function">() =&gt;</span> &#123;<br>    interval = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br>  &#125;;  <br>  <span class="hljs-keyword">const</span> stop = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">clearInterval</span>(interval);<br>  &#125;;  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;start&#125;</span>&gt;</span>start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>我们增加了 start 和 stop 按钮。 此代码实现不正确，因为 stop 按钮不工作。 因为在每次渲染期间都会创建新的引用(指 interval 的引用)，因此 stop 函数里面 clearInterval 里面的 interval 是 null。</p><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables">Is there something like instance variables?</a></p><h3 id="Level-9：useRef"><a href="#Level-9：useRef" class="headerlink" title="Level 9：useRef"></a>Level 9：useRef</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level09</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel09&#x27;</span>);  <br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);  <br>  <span class="hljs-keyword">const</span> intervalRef = useRef(<span class="hljs-literal">null</span>); <br>  <br>  <span class="hljs-keyword">const</span> start = <span class="hljs-function">() =&gt;</span> &#123;<br>    intervalRef.current = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br>  &#125;;  <br>  <br>  <span class="hljs-keyword">const</span> stop = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">clearInterval</span>(intervalRef.current);<br>  &#125;;  <br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;start&#125;</span>&gt;</span>start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要变量，useRef 是首选的 Hook。 与局部变量不同，React 确保在每次渲染期间返回相同的引用。</p><p>这个代码看起来是正确的，但是有一个微妙的错误。 如果 start 被多次调用，那么 setInterval 将被多次调用，从而触发资源泄漏。</p><p> <a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#useref">useRef</a></p><h3 id="Level-10-useCallback"><a href="#Level-10-useCallback" class="headerlink" title="Level 10: useCallback"></a>Level 10: useCallback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level10</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel10&#x27;</span>);  <br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);  <br>  <span class="hljs-keyword">const</span> intervalRef = useRef(<span class="hljs-literal">null</span>);  <br>  <br>  <span class="hljs-keyword">const</span> start = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (intervalRef.current !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    intervalRef.current = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br>  &#125;;  <br>  <br>  <span class="hljs-keyword">const</span> stop = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (intervalRef.current === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-built_in">clearInterval</span>(intervalRef.current);<br>    intervalRef.current = <span class="hljs-literal">null</span>;<br>  &#125;;  <br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;start&#125;</span>&gt;</span>start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免资源泄漏，如果 <code>interval</code> 已经启动，我们只需忽略调用。 尽管调用 <code>clearInterval (null)</code> 不会触发任何错误，但是只释放一次资源仍然是一个很好的实践。</p><p>此代码没有资源泄漏，实现正确，但可能存在性能问题。</p><p><strong>memoization</strong> 是 <strong>React</strong> 中主要的性能优化工具。 <strong>React.memo</strong> 进行浅比较，如果引用相同，则跳过 render 阶段。</p><p>如果 <strong>start</strong> 函数 和 <strong>stop</strong> 函数被传递给一个 <strong>memoized</strong> 组件，整个优化就会失败，因为在每次渲染之后都会返回新的引用。</p><p><a href="https://medium.com/@sdolidze/react-hooks-memoization-99a9a91c8853"><strong>React Hooks: Memoization</strong></a></p><h3 id="Level-11-useCallback"><a href="#Level-11-useCallback" class="headerlink" title="Level 11: useCallback"></a>Level 11: useCallback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> intervalRef = useRef(<span class="hljs-literal">null</span>);  <br><br><span class="hljs-keyword">const</span> start = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (intervalRef.current !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    intervalRef.current = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, <span class="hljs-number">500</span>);<br>  &#125;, []);  <br><br><span class="hljs-keyword">const</span> stop = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (intervalRef.current === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;    <br>  <br>  <span class="hljs-built_in">clearInterval</span>(intervalRef.current);<br>    intervalRef.current = <span class="hljs-literal">null</span>;<br>  &#125;, []);<br><br><span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;start&#125;</span>&gt;</span>start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使 <strong>React.memo</strong> 能够正常工作，我们需要做的就是使用 <strong>useCallback</strong> 来记忆(memoize)函数。 这样，每次渲染后都会提供相同的函数引用。</p><p>此代码没有资源泄漏，实现正确，没有性能问题，但代码相当复杂，即使对于简单的计数器也是如此。</p><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-reference.html#usecallback">useCallback</a></p><h3 id="Level-12-自定义-Hook"><a href="#Level-12-自定义-Hook" class="headerlink" title="Level 12: 自定义 Hook"></a>Level 12: 自定义 Hook</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCounter</span>(<span class="hljs-params">initialValue, ms</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = useState(initialValue);<br>  <span class="hljs-keyword">const</span> intervalRef = useRef(<span class="hljs-literal">null</span>);  <br>  <br>  <span class="hljs-keyword">const</span> start = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (intervalRef.current !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    intervalRef.current = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      setCount(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c + <span class="hljs-number">1</span>);<br>    &#125;, ms);<br>  &#125;, []);  <br>  <br>  <span class="hljs-keyword">const</span> stop = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (intervalRef.current === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;    <br>    <span class="hljs-built_in">clearInterval</span>(intervalRef.current);<br>    intervalRef.current = <span class="hljs-literal">null</span>;<br>  &#125;, []);  <br>  <br>  <span class="hljs-keyword">const</span> reset = useCallback(<span class="hljs-function">() =&gt;</span> &#123;<br>    setCount(<span class="hljs-number">0</span>);<br>  &#125;, []);  <br>  <br>  <span class="hljs-keyword">return</span> &#123; count, start, stop, reset &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了简化代码，我们需要将所有复杂性封装在 <strong>useCounter</strong> 自定义钩子中，并暴露 api: <strong>{ count，start，stop，reset }。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Level12</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;renderLevel12&#x27;</span>);  <br>  <span class="hljs-keyword">const</span> &#123; count, start, stop, reset &#125; = useCounter(<span class="hljs-number">0</span>, <span class="hljs-number">500</span>);  <br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">      count =&gt; &#123;count&#125;</span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;start&#125;</span>&gt;</span>start<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;stop&#125;</span>&gt;</span>stop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;reset&#125;</span>&gt;</span>reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://reactjs.org/docs/hooks-reference.html">Hooks API Reference</a>: <a href="https://reactjs.org/docs/hooks-custom.html#using-a-custom-hook">Using a Custom Hook</a></p><h2 id="React-Hooks-Radar"><a href="#React-Hooks-Radar" class="headerlink" title="React Hooks Radar"></a>React Hooks Radar</h2><p><img src="https://miro.medium.com/max/3840/0*Px-sg5tvCOOlPcJb.jpeg"></p><h3 id="Green"><a href="#Green" class="headerlink" title="Green"></a>Green</h3><p>绿色 hooks 是现代 React 应用程序的主要构件。 它们几乎在任何地方都可以安全地使用，而不需要太多的思考</p><ol><li><code>useReducer</code> </li><li><code>useState</code></li><li><code>useContext</code></li></ol><h3 id="Yellow"><a href="#Yellow" class="headerlink" title="Yellow"></a>Yellow</h3><p>黄色 hooks 通过使用记忆(memoize)提供了有用的性能优化。 管理生命周期和输入应该谨慎地进行。</p><ol><li><code>useCallback</code></li><li><code>useMemo</code></li></ol><h3 id="Red"><a href="#Red" class="headerlink" title="Red"></a>Red</h3><p>红色 hooks 与易变的世界相互作用，使用副作用。 它们是最强大的，应该极其谨慎地使用。 自定义 hooks 被推荐用于所有重要用途的情况。</p><ol><li><code>useRef</code></li><li><code>useEffect</code></li><li><code>useLayoutEffect</code></li></ol><h2 id="用好-React-Hooks-的清单"><a href="#用好-React-Hooks-的清单" class="headerlink" title="用好 React Hooks 的清单"></a>用好 React Hooks 的清单</h2><ol><li>服从<a href="https://reactjs.org/docs/hooks-rules.html">Rules of Hooks 钩子的规则</a>.</li><li>不要在主渲染函数中做任何副作用</li><li>取消订阅 / 弃置 / 销毁所有已使用的资源</li><li>Prefer 更喜欢<code>useReducer</code> or functional updates for 或功能更新<code>useState</code>to prevent reading and writing same value in a hook. 防止在钩子上读写相同的数值</li><li>不要在渲染函数中使用可变变量，而应该使用<code>useRef</code></li><li>如果你保存在<code>useRef</code> 的值的生命周期小于组件本身，在处理资源时不要忘记取消设置值</li><li>谨慎使用无限递归导致资源衰竭</li><li>在需要的时候使用 Memoize 函数和对象来提高性能</li><li> 正确捕获输入依赖项(<code>undefined</code>=&gt; 每一次渲染,<code>[a, b]</code> =&gt;  当<code>a</code> or 或<code>b</code>改变的时候渲染, 改变,<code>[]</code> =&gt; 只改变一次)</li><li>对于复杂的用例可以通过自定义 Hooks 来实现。</li></ol>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019 个人深度总结</title>
    <link href="/index.php/archives/295/"/>
    <url>/index.php/archives/295/</url>
    
    <content type="html"><![CDATA[<p>又一年过去了，2018 年写年终总结的场景还历历在目，写这篇文章之前还专门去看了下 2018 年的年度总结，主要是看自己在 2018 学的东西自己还能记得啥。</p><p>印象最深刻的应该是还是<strong>函数式编程</strong>相关的东西，因为确实在我深入的去接触它过后，我的很多编程思维都被它所影响。虽然在项目中不会去用很多函数式的方式去写，但是函数式的那些特点深深的指导着我如何去设计一个更容易维护的函数，其中一些思维可以见我去年的写 <a href="https://juejin.im/post/5c19c3ffe51d45059b632eef" title="函数式编程，真香">函数式编程，真香</a>。</p><blockquote><p>做个预测：三年之内，函数式编程要火一波，原因是 serverless 的兴起。</p></blockquote><p>回顾了过去，我对今年的整体总结是：输入很多、输出不够。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>自我感觉自己是一个焦虑的人，焦虑也许来源与社交(周围优秀的人太多，见了太多比自己年轻或者同龄人)、也许来源于自己见识更多(处于达克效应里面「知道自己不知道」的境界)。</p><p><img src="http://imgs.taoweng.site/2019-12-31-094201.jpg" alt="达克效应"></p><blockquote><p>图片来源于网络</p></blockquote><p>如果按照这张图来的话，我现在处于自信崩溃区，不知道自己是否处于绝望之谷，但是希望明年能进入开悟之坡。</p><blockquote><p>从这张图里可以看到，自信程度高也不一定约好，很可能是处于愚昧山峰。</p></blockquote><p>自我感觉自己还算坚强，没有被焦虑或者自信崩溃打败，相信自己通过努力，提升自己的专业知识和能力，总会逃离绝望之谷，所以我今年比以前都更努力的去学习，得到结果是我感觉自己今年在见识上提升了非常的多，见识越多，意味着格局会慢慢变大，格局越大，就越能成功(这只是我自己的人生逻辑)。</p><p>虽然在精神上的收获了很多，但是从今年各方面的产出来看，不管是职业还是影响力都没有实质性的进展，但是我没有着急，平时安慰我自己的话就是：还没到爆发的时候，现在一直积累就行。</p><h3 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h3><p>读书是我今年最满意的一项输入，读了 20 多本书，虽然这个成绩不算好，但是对于我来说是一个非常大的进步，因为我从小就特别讨厌读文字，小说也不例外。现在一年能读 20 多本，差不多半个月读一本，进步非常的大了。</p><p>最开始想读书也是自己接触的很多大佬，或者在网上看到一些大佬的文章等，了解到读书非常的重要，所以就开始买书来读，刚开始读得很慢，而且很枯燥，一本书可能要花一个月才能读完，大概读了两个月后，自己养成了读书的习惯了，每天花 30 ~ 60 分钟的时间读书，周末就花多一点，一周就能读一本书。</p><p>那个时候成就感就来了，对读书产生了兴趣，然后读书 对于我来说就不算什么难事儿了，反正有大段的空闲时间就会用来读书。</p><p>在书的媒介方面我还是比较传统，喜欢纸质书翻书的感觉，所以我读的大部分书都是纸质书，基本每个月都会买 3、4 本书，主要是每个月基本上当当都会搞活动，打 5 折或者满 100 - 50，另外还有满 200 - 30 的券，然后由于我会每个月自费给公众号里的读者送书，正好就一起会买六七本书，差不多 200 块。</p><p>下面是我今年读完的书，没读完的没有列出来，明年再继续读，大部分都是纸质书。我目前读书还没有进行主题阅读，基本上都是泛读，涉及的不仅仅是技术书，也有心理学、品牌、历史、理财、个人成长各个方面。</p><p><strong>电子书</strong></p><ul><li>《实用性阅读指南》三星</li><li>《麦肯锡精英高效阅读法》三星</li><li>《半小时漫画中国史》1-4 册 三星</li><li>《小狗钱钱》五星</li><li>《如何有效阅读一本书》三星</li></ul><p><strong>纸质书</strong></p><ul><li>《现代前端技术解析》四星</li><li>《你不知道的 JavaScript(上)》五星</li><li>《高效前端：Web 高效编程与优化实践》四星</li><li>《重构(第二版)》五星</li><li>《React 状态管理与同构实战》四星</li><li>《见识》四星</li><li>《被讨厌的勇气》五星</li><li>《刻意练习》四星</li><li>《高效能人士的七个习惯》五星</li><li>《超级符号原理》三星</li><li>《学会写作》三星</li><li>《少有人走的路 4：在焦虑的年代获得精神的成长》四星</li><li>《原则》五星</li><li>《语言学的邀请》五星</li><li>《文明之光(第一册)》五星</li></ul><p>打五星的都是我自己读完之后感觉收获很多的，每个人可能感受不同，三星就是我觉得可读可不读的书。</p><h3 id="知识付费"><a href="#知识付费" class="headerlink" title="知识付费"></a>知识付费</h3><p><strong>得到</strong></p><p>我在年度学习报告的一些信息：一共花了 12541 分钟，参与了 800 讲课程，听了 29 本书，阅读了 6 本电子书。算下来平均每天至少花半小时的时间在学习得到里面的课程。学得最多的课程就是吴军老师的《硅谷来信》、《香帅的北大金融课》、张潇雨的《个人投资课》、陆蓉的《行为金融学》，还有一些 10 来节一门的小课。</p><p><strong>樊登读书</strong></p><p>樊登读书是我偶然接触到的，看到一些关于樊登讲书的短视频，觉得他讲书非常的有魅力，就去开了樊登读书的会员，听他讲书。</p><p>听樊登讲书会觉得这个人特别的有魅力，有温度，也许是因为他讲书是有视频的，所以非常的生动，他的表情以及讲书的语气都非常的到位，仿佛就在身边给你讲一样。</p><p>在听书的体验上对比得到和知乎，樊登讲书给我的体验是最好的，后面也打算写一篇文章来具体对比一下。</p><p><strong>知乎</strong></p><p>知乎在知识付费上给我的感觉是比较的业余，里面涉及的东西很广，形式也多，电子书、专栏、live、杂志。我用的比较多的还是专栏，今年我在时间管理方面的知识基本上都是来自于知乎专栏，主要原因是其他的平台没有。</p><p>所以我目前是把知乎作为一个备胎来考虑的，其他平台找不到再才会去知乎上找，另外知乎的会员也很便宜，我再搞活动的时候续费的，一年也才 99，基本上找不到更便宜的知识付费平台了。</p><p>最后再吐槽一下知乎的听书，对比其他竞品真的有待改进，知乎里的听书让人想睡觉，没有什么情感。</p><p><strong>极客时间</strong></p><p>极客时间现在基本上算是学技术的最大的知识付费平台了，我也买了不少课，将近 20 门，看完了差不多一半，其他的确实有些不是特别符合我的胃口，就没看完。</p><p>看了这么多，我觉得今年在极客时间比较推荐的专栏是《浏览器工作原理与实践》、《数据结构与算法之美》。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>其他比如还有在慕课网呀以及其他平台我就不总结了，花的时间比较少。</p><p>我估算了下，我每天下班回来花在学习上的时间平均一个半小时以上，我相信大家都听过人与人之间的差距大部分都在下班后的几个小时，虽然我并不完全同意这句话，但是我相信把时间花在自己觉得对的事情，总会有收获的，干就完了，把其他的留给时间。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>说道输出，我相比认识的一些写文章的大佬来说，写得有点少，比如<a href="https://mp.weixin.qq.com/s/lIOIgN14W1PGUUq4EmICWA">奇奇</a>，他今年写了 67 篇原创文，太强了，而且绝大部分都是高质量的文章，具体可以看他的 <a href="https://mp.weixin.qq.com/s/hzkRNU-m_4G1bacfUHMPSw">code 秘密花园 2019 年终总结</a> ，一位字节跳动的大佬，公众号就是「code 密码花园」，有兴趣的可以关注一下他。</p><p>我看壹伴生成的年报里面有 34 篇文章，但是有部分可能不是纯技术文，我自己今年在公众号大概仅仅输出了 20 篇左右，由于今年打算是想把 React 好好研究下，所以还是输出的文章 React 部分的比较多。</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484774&idx=1&sn=9dc58e54a28755504d58bef49a78f3b4&scene=21#wechat_redirect">React 函数式组件性能优化指南</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484614&idx=1&sn=a2b5050136c2cd5e00db90a6cc8daaed&scene=21#wechat_redirect">新手学习 React 迷惑的点</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484536&idx=1&sn=94777b8c1aab80dffe1fc224bec02c72&scene=21#wechat_redirect">React 16 的 Diff 策略</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484469&idx=1&sn=f68d044f1b0e4e2eb981e3878427b75b&scene=21#wechat_redirect">React Fiber 架构</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484879&idx=1&sn=ee0d2e3e235fa911ce2878ae2ea2b676&scene=21#wechat_redirect">从 React 历史的长河里聊虚拟 DOM 及其价值</a></li></ul><p>也因为这些 React 的文章，还是结实了不少的 React 爱好者。</p><p>另外还输出了几篇非技术文，反响也还不错：</p><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484242&idx=1&sn=5bffee002d9111881ca02a1f18b235c3&scene=21#wechat_redirect">为什么现在面试总是造火箭？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484215&idx=1&sn=920044e190eca49e85d1cde2510364f0&scene=21#wechat_redirect">群里提问的艺术</a></li><li><a href="https://mp.weixin.qq.com/s/mM1rMtWjzWRtHmXcKZZROw">高级程序员与初级程序员的差别在哪里</a></li></ul><p>还有关于图片知识的文章，这篇<a href="https://mp.weixin.qq.com/s/O1n7_t4izdmpvn2mFrB-kg">每个前端工程师都应该了解的图片知识</a> 也反响不错，在思否上获得了 188 票，这是我在思否上获得点赞最多的一篇文章了，虽然相对于奇奇(ConardLi)、浪浪(浪里行舟)这种思否年度排行榜前五的人来说就是小儿科。对于我来说的意义就在于以后我的文章有机会上推荐了，这篇文章以前我在思否上的文章基本是无人问津。然后当时也是被各大公众号转载，我自己的公众号里也达到了 2000+ 的阅读量。</p><p>另外的一些原创就暂时不推荐了，自己感觉质量没有这些高，我觉得这篇<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247484879&idx=1&sn=ee0d2e3e235fa911ce2878ae2ea2b676&scene=21#wechat_redirect">从 React 历史的长河里聊虚拟 DOM 及其价值</a>是一篇被低估了的文章，这篇文章在理解虚拟 DOM 以及现代框架的意义上总结的很好，但是无奈可能文笔不行，看的人很少，远远低于我的期望。</p><p>除了公众号，我在自己的个人网站<a href="http://www.taoweng.site/" title="桃园http://www.taoweng.site/">桃园 http://www.taoweng.site/</a>里还记录了一些周刊呀、以及其他的小工具和一些坑。由于很多是短文，所以感觉质量不是特别的高，就没有发公众号，有兴趣的也可以去我博客逛一逛。</p><p>对于我的博客我很开心的是今年我终于用了我自己写的主题，前两年都是用的别人的主题，用了一段时间，总觉得不太满意，然后就会花时间去另外找主题，甚至还花钱买过，但是设计理念毕竟是别人的，有些不太符合自己，今年就下定决心自己写了一个主题，我的博客是用 Typecho 搭的，主题在我的 <a href="https://github.com/crazylxr/Typecho-Theme-Notion" title="github：https://github.com/crazylxr/Typecho-Theme-Notion">github：https://github.com/crazylxr/Typecho-Theme-Notion</a>，看完如果觉得不错的记得给我点 star。</p><h2 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h2><p>关于投资理财的话，我并不算专业，但是由于自己今年抓住了一波红利，所以在回报率上还不错。</p><p>我目前的投资 80% 的钱是在指数基金里面，20% 的钱在股票里。今年基金的回报率在 17% 左右，股票的回报率在 12% 左右。</p><p>在前文也可以看到我学习投资理财的知识主要是在得到上学习的，现在的水平只是了解一些投资工具的基本概念。虽然这部分知识还比较薄弱，但不准备纳入我明年花大力气学习的点，因为对于我这种不是靠投资吃饭的人来说，目前积攒本金才是最重要的。</p><p>不过今年是准备写一些关于投资理财的科普文，比如如何理解股票、如何理解基金、对我们普通人来说最好的指数基金又是怎么一会儿相关的。</p><h2 id="技术上"><a href="#技术上" class="headerlink" title="技术上"></a>技术上</h2><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><p>虽然去年我就在<a href="http://www.taoweng.site/index.php/archives/221/" title="总结">总结</a>里面提到过我已经开始接触 Typescript，但是那个时候只是在自己的小项目里面用过，没有在公司的大点的项目用，有些东西理解也不到位，今年通过在公司项目的实践，对 Typescript 有了更深刻的理解，不说精通，也可以说自己算是掌握了 Typescript，熟悉类型编程，我也给公司的组件平台写组件的声明文件。</p><p>并且在<a href="http://www.taoweng.site/index.php/archives/221/" title="总结">总结</a>里预测他一定会火，果然在 2019 年很多大项目都开始用 Typescript 来写，基本上成为大项目的标配，但是目前还没有成为各个公司招聘的必备技能，只是一个加分项。我还是非常建议去学习的，特别是公司内部 Typescript 的生态系统如果搞的很好，代码写起来很舒服的。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>说到测试，作为软件工程中的关键一环，目前很多人都忽视了这个环节，我以前基本上也是忽略的，但是偶然看到了一篇 TDD 的文章，然后意识到测试的重要性，也去慕课网上买了<a href="https://coding.imooc.com/class/372.html" title="前端要学的测试课 从Jest入门到TDD/BDD双实战">前端要学的测试课 从 Jest 入门到 TDD/BDD 双实战</a>这门课来看，不过这里面讲得比较的浅，而且对 BDD 的解释我感觉是错的。</p><p>然后我又去参加了一个熊节(重构这本书的翻译者)的「 TDD 和 重构的练功房」，然后加入了交流群，这里面都是一些 TDD 爱好者，经过一阵子的研究，让我对 TDD 有了认识，当然对单元测试也熟悉了很多，虽然现在还是没办法完全通过 TDD 的方式开发项目，但是里面的思维已经影响了我。</p><h3 id="深入-React"><a href="#深入-React" class="headerlink" title="深入 React"></a>深入 React</h3><p>React 我已经使用了三年了，虽然 API 很熟悉了，了解了基本原理，但是没有深入的去看过源码，已经整体的架构，所以今年需求突破，也去慕课网上买了<a href="https://coding.imooc.com/class/309.html" title="React源码深度解析">React 源码深度解析</a> 来看，不过课程着实枯燥，只看视频是根本看不懂的，给我带来的收获是让我学会了如何去看这种大型项目的源码。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>今年花在技术上的时间没有去年那么多，学的东西也不够多，特别是看了奇奇的总结，深知自己跟他技术上的差距，也许今年是把去年学的东西用来实践了，也许是把时间花在了一些通识教育上，明年重点规划就是在技术上的突破。</p><p>另外还有一点体会就是，当你真正的去专研过一个技术之后，当别人跟你聊到这个话题，你会非常的自信，很有底气，面试啥的根本不怕问到，对于我来说我就比较在行 React、函数式编程相关的，这方面我花过大量时间专研过，大部分问题我都是知道的，但是对于算法和数据、webpack 相关的，我就很虚，很怕在面试的时候被问到。</p><p>虽然前端需要掌握的知识很多，我还是比较倾向于把一些自己常用的知识，或者自己感兴趣的知识，好好专研一下，不要贪多，一个技术点一个技术点的慢慢攻破。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今年还是没有虚度吧，感觉自己在认知方面提升了一大截，养成了看书的习惯，因为做公众号写文章结实了很多新朋友，也帮助了很多人，这点给自己点个赞吧，然后明年就是在技术上提升多一点。</p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端桃园周刊第六期</title>
    <link href="/index.php/archives/294/"/>
    <url>/index.php/archives/294/</url>
    
    <content type="html"><![CDATA[<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul><li><a href="https://segmentfault.com/q/1010000004569689">伪类before/after中的图片大小是不是不能设置的?</a></li></ul><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><h3 id="编写组件的-10-个原则"><a href="#编写组件的-10-个原则" class="headerlink" title="编写组件的 10 个原则"></a><a href="https://dev.to/selbekk/the-10-component-commandments-2a7f"><strong>编写组件的</strong> <strong>10</strong> <strong>个原则</strong></a></h3><p>一篇英文文章，之前面试被面到过设计组件的时候要注意哪些，当时我大脑空白，根本答不出来，看了这篇文章之后，也许知道怎么答了。</p><h3 id="深入解析ES-Module（二）：彻底禁用default-export"><a href="#深入解析ES-Module（二）：彻底禁用default-export" class="headerlink" title="深入解析ES Module（二）：彻底禁用default export"></a><a href="https://zhuanlan.zhihu.com/p/97335917">深入解析ES Module（二）：彻底禁用default export</a></h3><p>文章介绍了 <code>export default object</code> 这种方式所带来的问题，主要是在转换的时候不兼容 cjs，当然这篇文章也有助于更深刻的理解 ES Module。</p><h3 id="「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽"><a href="#「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽" class="headerlink" title="「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽"></a><a href="https://mp.weixin.qq.com/s/2FNYzZMyKc7ryhtgbQzHtw">「圣诞特辑」纯前端实现人脸识别自动佩戴圣诞帽</a></h3><p>通过使用 TensorFlow.js 来进行人脸识别，然后自动佩戴圣诞帽，我最近也在学习机器学习相关的，当然也绕不开 TensorFlow.js ，学完课程之后再来看这篇文章。</p><h3 id="那些你用错了的-React-生命周期"><a href="#那些你用错了的-React-生命周期" class="headerlink" title="那些你用错了的 React 生命周期"></a><a href="https://mp.weixin.qq.com/s/jzY7wcPit7-tY8BTuA4Cnw">那些你用错了的 React 生命周期</a></h3><p>这篇文章的中心思想跟我之前在 React 官方博客里面看到那篇「<a href="https://zh-hans.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">你也许不需要派生 State</a>」基本类似，主要是 componentWillReceiveProps <code>和</code>getDerivedStateFromProps 这两个声明周期可能会写成反模式。</p><h3 id="独家-阿里张勇湖畔分享：领导者如何“落子无悔”"><a href="#独家-阿里张勇湖畔分享：领导者如何“落子无悔”" class="headerlink" title="独家 | 阿里张勇湖畔分享：领导者如何“落子无悔”"></a><a href="https://mp.weixin.qq.com/s/lBZjppE5cwvNs9EfVHcTgg">独家 | 阿里张勇湖畔分享：领导者如何“落子无悔”</a></h3><p>张勇的演讲全文，看到很多大佬推荐这篇文章，先 mark 一波。</p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据 React 历史来聊如何理解虚拟 DOM</title>
    <link href="/index.php/archives/293/"/>
    <url>/index.php/archives/293/</url>
    
    <content type="html"><![CDATA[<p>最近我发现很多面试题里面都有「如何理解虚拟 DOM」这个题，我觉得这个题应该没有想象中那么好答，因为很多人没有真正理解虚拟 DOM 它的价值所在，我这篇从虚拟 DOM 的诞生过程来引出它的价值以及历史地位，帮助你深入的理解它。</p><h2 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h2><p><strong>本质上是 JavaScript 对象，这个对象就是更加轻量级的对 DOM 的描述。</strong></p><p>对，就是这么简单！</p><p>就是一个复杂一点的对象而已，没什么好说的，重点是为什么要有这个东西，以及有了这个描述有什么好处才是我们今天要介绍的内容。</p><h2 id="为什么要有虚拟DOM"><a href="#为什么要有虚拟DOM" class="headerlink" title="为什么要有虚拟DOM"></a>为什么要有虚拟DOM</h2><p>再谈为什么要用虚拟 DOM 之前，先来聊一聊 React 是怎么诞生的，毕竟在了解历史背景，再去思考他的诞生，就知道是必然会出现的。</p><p>再查了很多关于 React 的历史相关的文章，这篇文章我感觉比较值得令我信服：<a href="https://segmentfault.com/a/1190000013365426#item-4">React 是怎样炼成的</a>。</p><p>众所周知，Facebook 是 PHP 大户，所以 React 最开始的灵感就来至于 PHP。</p><h3 id="字符串拼接时代-2004"><a href="#字符串拼接时代-2004" class="headerlink" title="字符串拼接时代 - 2004"></a>字符串拼接时代 - 2004</h3><p>在 2004 年这个时候，大家都还在用 PHP 的字符串拼接来开发网站：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$str = <span class="hljs-string">&#x27;&lt;ul&gt;&#x27;</span>;<br>foreach ($talks <span class="hljs-keyword">as</span> $talk) &#123;<br>  $str += <span class="hljs-string">&#x27;&lt;li&gt;&#x27;</span> . $talk-&gt;name . <span class="hljs-string">&#x27;&lt;/li&gt;&#x27;</span>;<br>&#125;<br>$str += <span class="hljs-string">&#x27;&lt;/ul&gt;&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这种方式代码写出来不好看不说，还容易造成 XSS 等安全问题。</p><p>应对方法是对用户的任何输入都进行转义（Escape）。但是如果对字符串进行多次转义，那么反转义的次数也必须是相同的，否则会无法得到原内容。如果又不小心把 HTML 标签（Markup）给转义了，那么 HTML 标签会直接显示给用户，从而导致很差的用户体验。</p><h3 id="XHP-时代-2010"><a href="#XHP-时代-2010" class="headerlink" title="XHP 时代 - 2010"></a>XHP 时代 - 2010</h3><p>到了 2010 年，为了更加高效的编码，同时也避免转义 HTML 标签的错误，Facebook 开发了 XHP 。XHP 是对 PHP 的语法拓展，它允许开发者直接在 PHP 中使用 HTML 标签，而不再使用字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php+HTML">$content = &lt;ul /&gt;;<br>foreach ($talks as $talk) &#123;<br>  $content-&gt;appendChild(&lt;li&gt;&#123;$talk-&gt;name&#125;&lt;/li&gt;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样的话，所有的 HTML 标签都使用不同于 PHP 的语法，我们可以轻易的分辨哪些需要转义哪些不需要转义。</p><p>不久的后来，Facebook 的工程师又发现他们还可以创建自定义标签，而且通过组合自定义标签有助于构建大型应用。</p><h3 id="JSX-2013"><a href="#JSX-2013" class="headerlink" title="JSX - 2013"></a>JSX - 2013</h3><p>到了 2013 年，前端工程师 Jordan Walke 向他的经理提出了一个大胆的想法：把 XHP 的拓展功能迁移到 JS 中。首要任务是需要一个拓展来让 JS 支持 XML 语法，该拓展称为 JSX。因为当时由于 Node.js 在 Facebook 已经有很多实践，所以很快就实现了 JSX。</p><blockquote><p>可以猜想一下为什么要迁移到 js 中，我猜想应该是前后端分离导致的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> content = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TalkList</span>&gt;</span></span><br><span class="xml">    &#123; talks.map(talk =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">Talk</span> <span class="hljs-attr">talk</span>=<span class="hljs-string">&#123;talk&#125;</span> /&gt;</span>)&#125;</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">TalkList</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>在这个时候，就有另外一个很棘手的问题，那就是在进行更新的时候，需要去操作 DOM，传统 DOM API 细节太多，操作复杂，所以就很容易出现 Bug，而且代码难以维护。</p><p>然后就想到了 PHP 时代的更新机制，每当有数据改变时，只需要跳到一个由 PHP 全新渲染的新页面即可。</p><p>从开发者的角度来看的话，这种方式开发应用是非常简单的，因为它不需要担心变更，且界面上用户数据改变时所有内容都是同步的。</p><p>为此 React 提出了一个新的思想，即<strong>始终整体“刷新”页面</strong></p><p><strong>当发生前后状态变化时，React 会自动更新 UI</strong>，让我们从复杂的 UI 操作中解放出来，使我们只需关于状态以及最终 UI 长什么样。</p><p>下面看看局部刷新和整体刷新的区别。</p><p><img src="http://imgs.taoweng.site/2019-12-22-155012.png"></p><blockquote><p>图片来自于极客时间王沛老师的《React进阶与实战》</p></blockquote><p>局部刷新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面是伪代码</span><br><span class="hljs-keyword">var</span> ul = find(ul) <span class="hljs-comment">// 先找到 ul</span><br>ul.append(<span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;message3&#125;</span>&lt;/li&gt;`</span>) <span class="hljs-comment">//然后再将message3插到最后</span><br><br><span class="hljs-comment">// 想想如果是不插到最后一个，而是插到中间的第n个</span><br><span class="hljs-keyword">var</span> ul = find(ul) <span class="hljs-comment">// 先找到 ul</span><br><span class="hljs-keyword">var</span> preli = find(li(n-<span class="hljs-number">1</span>)) <span class="hljs-comment">// 再找到 n-1 的一个 li</span><br>preli.next(<span class="hljs-string">`&lt;li&gt;<span class="hljs-subst">$&#123;message3&#125;</span>&lt;/li&gt;`</span>) <span class="hljs-comment">// 再插入到 n-1 个的后面</span><br></code></pre></td></tr></table></figure><p>整体刷新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">UI = f(messages) <span class="hljs-comment">// 整体刷新 3 条消息，只需要调用 f 函数</span><br><br><span class="hljs-comment">// 这个是在初始渲染的时候就定义好的，更新的时候不用去管</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">messages</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="xml">&#123;messages.map(message =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123; message &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>)&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个时候，我<strong>只需要关系我的状态（数据是什么），以及 UI 长什么样（布局），不再需要关系操作细节。</strong></p><p>这种方式虽然简单粗暴，但是很明显的缺点，<strong>就是很慢。</strong></p><p>另外还有一个问题就是这样无法包含节点的状态。比如它会失去当前聚焦的元素和光标，以及文本选择和页面滚动位置，这些都是页面的当前状态。</p><h2 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h2><p>为了解决上面说的问题，对于没有改变的 DOM 节点，让它保持原样不动，仅仅创建并替换变更过的 DOM 节点。这种方式实现了 DOM 节点<strong>复用</strong>（Reuse）。</p><p>至此，只要能够<strong>识别</strong>出哪些节点改变了，那么就可以实现对 DOM 的更新。于是问题就转化为<strong>如何比对两个 DOM 的差异</strong>。</p><p>说道对比差异，可能很容易想到<strong>版本控制(git)。</strong></p><p>DOM 是树形结构，所以 diff 算法必须是针对树形结构的。目前已知的完整树形结构 diff 算法复杂度为 O(n^3) 。</p><blockquote><p><a href="https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf">完整的 Tree diff 实现算法。</a></p></blockquote><p>但是时间复杂度  O(n^3) 太高了，所以Facebook工程师考虑到组件的特殊情况，然后将复杂度降低到了 O(n)。</p><blockquote><p>附：详细的 diff 理解：<a href="https://zhuanlan.zhihu.com/p/20346379">不可思议的 react diff 。</a></p></blockquote><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>前面说到，React 其实实现了对 DOM 节点的版本控制。</p><p>做过 JS 应用优化的人可能都知道，DOM 是复杂的，对它的操作（尤其是查询和创建）是非常慢非常耗费资源的。看下面的例子，仅创建一个空白的 div，其实例属性就达到 231 个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Chrome v63</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br><span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k <span class="hljs-keyword">in</span> div) &#123;<br>  m++;<br>&#125;<br><span class="hljs-built_in">console</span>.log(m); <span class="hljs-comment">// 231</span><br></code></pre></td></tr></table></figure><p>对于 DOM 这么多属性，其实大部分属性对于做 Diff 是没有任何用处的，所以如果用更轻量级的 JS 对象来代替复杂的 DOM 节点，然后把对 DOM 的 diff 操作转移到 JS 对象，就可以避免大量对 DOM 的查询操作。这个更轻量级的 JS 对象就称为 Virtual DOM 。</p><p>那么现在的过程就是这样：</p><ol><li>维护一个使用 JS 对象表示的 Virtual DOM，与真实 DOM 一一对应</li><li>对前后两个 Virtual DOM 做 diff ，生成<strong>变更</strong>（Mutation）</li><li>把变更应用于真实 DOM，生成最新的真实 DOM</li></ol><p>可以看出，因为要把变更应用到真实 DOM 上，所以还是避免不了要直接操作 DOM ，但是 React 的 diff 算法会把 DOM 改动次数降到最低。</p><p>剩下的历史就不谈了，已经引出这篇文章的重点：虚拟 DOM。详细的历史可见：<a href="https://segmentfault.com/a/1190000013365426">React 是怎样炼成的</a>，文中历史部分内容很多摘抄与此。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>传统前端的编程方式是命令式的，直接操纵DOM，告诉浏览器该怎么干。这样的问题就是，大量的代码被用于操作 DOM 元素，且代码可读性差，可维护性低。</p><p>React 的出现，将命令式变成了声明式，摒弃了直接操作 DOM 的细节，只关注数据的变动，DOM 操作由框架来完成，从而大幅度提升了代码的可读性和可维护性。</p><p>在初期我们可以看到，数据的变动导致整个页面的刷新，这种效率很低，因为可能是局部的数据变化，但是要刷新整个页面，造成了不必要的开销。</p><p>所以就有了 Diff 过程，将数据变动前后的 DOM 结构先进行比较，找出两者的不同处，然后再对不同之处进行更新渲染。</p><p>但是由于整个 DOM 结构又太大，所以采用了更轻量级的对  DOM 的描述—虚拟 DOM。</p><p>不过需要注意的是，虚拟 DOM 和 Diff 算法的出现是为了解决由命令式编程转变为声明式编程、数据驱动后所带来的性能问题的。换句话说，<strong>直接操作 DOM 的性能并不会低于虚拟 DOM 和 Diff 算法，甚至还会优于。</strong></p><p>这么说的原因是因为 Diff 算法的比较过程，比较是为了找出不同从而有的放矢的更新页面。但是比较也是要消耗性能的。而直接操作 DOM 就是有的放矢，我们知道该更新什么不该更新什么，所以不需要有比较的过程。所以直接操作 DOM 效率可能更高。</p><p>React 厉害的地方并不是说它比 DOM 快，而是说不管你数据怎么变化，我都可以以最小的代价来进行更新 DOM。 方法就是我在内存里面用新的数据刷新一个虚拟 DOM 树，然后新旧 DOM 进行比较，找出差异，再更新到 DOM 树上。</p><p>框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。</p><p>如果你想了解更多的虚拟 DOM 与性能的关系，请看下面公众号里面的两篇文章和那个知乎话题，会让你对虚拟 DOM 又更深层次的理解。</p><ul><li><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ">别再说虚拟 DOM 快了，要被打脸的</a></li><li><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A">深入理解虚拟 DOM，它真的不快</a></li><li><a href="https://www.zhihu.com/question/31809713">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么</a></li></ul><blockquote><p>另外再提一个点，很多人会把 Diff 、数据更新、提升性能等概念绑定起来，但是你想想这个问题：React 由于只触发更新,而不能知道精确变化的数据,所以需要 diff 来找出差异然后 patch 差异队列。Vue 采用数据劫持的手段可以精准拿到变化的数据,为什么还要用虚拟DOM？</p></blockquote><h2 id="虚拟DOM-的作用"><a href="#虚拟DOM-的作用" class="headerlink" title="虚拟DOM 的作用"></a>虚拟DOM 的作用</h2><p>要想回答上面那个问题，真的不要仅仅以为虚拟 DOM 或者 React 是来解决性能问题的，好处可还有很多呢。下面我总结了一些虚拟 DOM 好作用。</p><ul><li><strong>Virtual DOM 在牺牲(牺牲很关键)部分性能</strong>的前提下，增加了可维护性，这也是很多框架的通性。</li><li>实现了对 DOM 的集中化操作，在数据改变时先对虚拟 DOM 进行修改，再反映到真实的 DOM中，用最小的代价来更新DOM，提高效率(提升效率要想想是跟哪个阶段比提升了效率，别只记住了这一条)。</li><li>打开了函数式 UI 编程的大门。</li><li>可以渲染到 DOM 以外的端，使得框架跨平台，比如 ReactNative，React VR 等。</li><li>可以更好的实现 SSR，同构渲染等。这条其实是跟上面一条差不多的。</li><li>组件的高度抽象化。</li></ul><p>既然虚拟 DOM 有这么多作用，那么上面的问题，Vue 采用虚拟 DOM 的原因是什么呢？</p><blockquote><p>Vue 2.0 引入 vdom 的主要原因是 vdom 把渲染过程抽象化了，从而使得组件的抽象能力也得到提升，并且可以适配 DOM 以外的渲染目标。 来自尤大文章：<a href="https://zhuanlan.zhihu.com/p/23752826">Vue 的理念问题</a></p></blockquote><h2 id="虚拟-DOM-的缺点"><a href="#虚拟-DOM-的缺点" class="headerlink" title="虚拟 DOM 的缺点"></a>虚拟 DOM 的缺点</h2><ul><li>首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。</li><li>虚拟 DOM 需要在内存中的维护一份 DOM 的副本(更上面一条其实也差不多，上面一条是从速度上，这条是空间上)。</li><li>如果虚拟 DOM 大量更改，这是合适的。但是单一的，频繁的更新的话，虚拟 DOM 将会花费更多的时间处理计算的工作。所以，如果你有一个DOM 节点相对较少页面，用虚拟 DOM，它实际上有可能会更慢。但对于大多数单页面应用，这应该都会更快。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>本文在介绍虚拟 DOM 并没有像其他文章一样去解释它的实现以及相关的 Diff 算法，关于 Diff 算法可以看这篇 <a href="https://mp.weixin.qq.com/s/oAlVmZ4Hbt2VhOwFEkNEhw">虚拟 DOM 到底是什么？</a>文中介绍了很多库的 diff 算法，可见其实 React 的 diff 算法并不算太快。</p><p>而是通过历史来得出他的价值体现，从历史怎么看大牛们是怎么一步一步的去解决问题，从历史中看为什么别人能做出这么伟大的东西，而我们不能？</p><p>每个伟大的产品都会有非常多的背景支持，都是一步一步发展而来的。</p><p>另外洗清了一个错误观念：<strong>很多人认为虚拟 DOM 最大的优势是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。</strong></p><p>虽然这一个虚拟 DOM 带来的一个优势，但并不是全部。虚拟 DOM 最大的优势在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种 GUI。</p><p>最后希望大家多思考，跟随者浪潮站在浪潮之巅。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://blog.csdn.net/hjc256/article/details/97135687">虚拟DOM为何出现以及性能问题？</a></li><li><a href="https://segmentfault.com/a/1190000013365426">React 是怎样炼成的</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端桃园周刊第五期</title>
    <link href="/index.php/archives/292/"/>
    <url>/index.php/archives/292/</url>
    
    <content type="html"><![CDATA[<h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><h3 id="1-Thinking-in-React-Hooks"><a href="#1-Thinking-in-React-Hooks" class="headerlink" title="1. Thinking in React Hooks"></a>1. <a href="https://wattenberger.com/blog/react-hooks">Thinking in React Hooks</a></h3><p>当从 React 类组件切换到函数组件 + hook 时，基本的思维模式发生了什么变化。</p><h3 id="2-Ant-Design-1-0-背后的故事：把艺术变成技术"><a href="#2-Ant-Design-1-0-背后的故事：把艺术变成技术" class="headerlink" title="2. Ant Design 1.0 背后的故事：把艺术变成技术"></a>2. <a href="https://mp.weixin.qq.com/s/TgBMOuXWgMEkJJkp868hGQ">Ant Design 1.0 背后的故事：把艺术变成技术</a></h3><p>我以前一直不喜欢读历史，今年了解吴军老师比较多，听他的硅谷来信，看他的书：《浪潮之巅》、《文明之光》才决定历史背景原来那么重要，了解历史你会发现现在很多的东西都是必然会出现的。  Ant Desgin 这么伟大的东西，了解一个产品背后的故事，我觉得还是很有必要的，看看为什么别人能做出伟大的东西，而我们不能。</p><h3 id="3-前端API层架构，也许你做得还不够"><a href="#3-前端API层架构，也许你做得还不够" class="headerlink" title="3. 前端API层架构，也许你做得还不够"></a>3. <a href="https://juejin.im/post/5de7169451882512454b18d8">前端API层架构，也许你做得还不够</a></h3><p>架构设计是一条永远走不完的路，没有最好，只有更好。这个道理适用于软件设计的各个场景，前端API 层的设计也不例外，如果您觉得在调用接口时还存在诸多槽点，那就说明您的接口层架构还待优化。作者以 vue + axios 为例，为大家梳理下我的一些经历和设想。</p><h3 id="4-你的-Mac-用对了吗？推荐一些-Mac-上比较好用的软件"><a href="#4-你的-Mac-用对了吗？推荐一些-Mac-上比较好用的软件" class="headerlink" title="4. 你的 Mac 用对了吗？推荐一些 Mac 上比较好用的软件"></a>4. <a href="https://mp.weixin.qq.com/s/t0v9dJ5NPVJ7StTG8kX-Vg">你的 Mac 用对了吗？推荐一些 Mac 上比较好用的软件</a></h3><p>这些 mac 软件都挺好用的，强烈推荐。</p><h3 id="5-再谈编程范式—程序语言背后的思想"><a href="#5-再谈编程范式—程序语言背后的思想" class="headerlink" title="5. 再谈编程范式—程序语言背后的思想"></a>5. <a href="https://imweb.io/topic/5cde5770e363b77a0edeb874">再谈编程范式—程序语言背后的思想</a></h3><p>详细讲述了命令式、过程式、说明式、面向对象、函数式、泛型编程各个编程范式的特性。</p><h3 id="6-少讲大道理，多解决小问题"><a href="#6-少讲大道理，多解决小问题" class="headerlink" title="6. 少讲大道理，多解决小问题"></a>6. <a href="https://mp.weixin.qq.com/s/j1MtPn_2YwPhiLCJHZ4GYQ">少讲大道理，多解决小问题</a></h3><p>二爷这篇文章以很多亲身体验的例子来阐述了多做事，少废话的道理，非常值得一读。</p><h2 id="挖宝"><a href="#挖宝" class="headerlink" title="挖宝"></a>挖宝</h2><h3 id="1-vscode-字体-fira-code"><a href="#1-vscode-字体-fira-code" class="headerlink" title="1. vscode 字体 fira code"></a>1. <a href="http://www.taoweng.site/index.php/archives/290/">vscode 字体 fira code</a></h3><p>一款为程序员专属的字体。</p><h3 id="2-大四学生开源文言文编程语言"><a href="#2-大四学生开源文言文编程语言" class="headerlink" title="2. 大四学生开源文言文编程语言"></a>2. <a href="https://github.com/LingDong-/wenyan-lang">大四学生开源文言文编程语言</a></h3><p>这一项目并不是简单的将程序中的英文字符换成了中文，而是利用 NLP 的一些技术，将文言文程序语法转换到 JavaScript 或 Python 运行，有一定的技术难度。</p><p>如果读者想快速试一试，你也可以玩一玩在线 IDE，上面有很多预定义的函数。即使在手机上，我们也能编辑并运行「文言文代码」。</p><h3 id="3-lutaonan-com"><a href="#3-lutaonan-com" class="headerlink" title="3. lutaonan.com"></a>3. <a href="https://lutaonan.com/">lutaonan.com</a></h3><p>一款很简洁的博客，文章阅读页的样式准备参考他的。</p><h3 id="4-方凳雅集"><a href="#4-方凳雅集" class="headerlink" title="4. 方凳雅集"></a>4. 方凳雅集</h3><p>方凳雅集是阿里B系前端技术团队的专属公众号，内容来自1688、阿里巴巴国际站、零售通、AliExpress、企业金融、考拉等多个BU的前端团队，涵盖阿里原创技术、精彩翻译和公司文化、职业成长等内容。</p><p>最近关注到的质量比较高的前端公众号了，不过不太适合初级工程师，文章话题一般比较高大上，都是他们团队内部的一些解决方案，而不是基础知识。</p><p><img src="http://imgs.taoweng.site/2019-12-22-024546.png" alt="Dec%2016%202019/Untitled.png"></p><h3 id="5-第十四届D2前端技术论坛「创心」"><a href="#5-第十四届D2前端技术论坛「创心」" class="headerlink" title="5. 第十四届D2前端技术论坛「创心」"></a>5. <a href="https://github.com/d2forum/14th">第十四届D2前端技术论坛「创心」</a></h3><p>12 月 14 日，第十四届 D2 前端技术论坛在杭州圆满举办。来自全国各地的近千名开发者齐聚杭州，聆听 3 大会场、来自 24 位海内外嘉宾的 21 个主题分享。</p><p>分了语言框架专场、智能化专场、微前端专场、工程化专场、Serverless 专场、多样化领域专场。</p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>mac</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为 VSCode 添加上程序员专用字体 Fira Code</title>
    <link href="/index.php/archives/290/"/>
    <url>/index.php/archives/290/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>推荐一款号称程序员的字体 <a href="https://github.com/tonsky/FiraCode">Fira Code</a>，Fira 是 Mozilla 主推的字体系列，Fira Code 是基于 Fira Mono 等宽字体的一个扩展，主要特点是加入了编程连字特性（ligatures）。</p><p>Fira Code 就是利用这个特性对编程中的常用符号进行优化，比如把输入的「!=」直接显示成「≠」或者把「&gt;=」变成「≥ 」等等，以此来提高代码的可读性。</p><p>效果如下：</p><p><img src="http://imgs.taoweng.site/2019-12-19-130213.png"></p><p>经过我体验一周来看，这款字体还是不错的。</p><p>更多请前往<a href="https://github.com/tonsky/FiraCode">GitHub地址</a>查看。</p><h2 id="设置步骤"><a href="#设置步骤" class="headerlink" title="设置步骤"></a>设置步骤</h2><h3 id="Step-1-下载"><a href="#Step-1-下载" class="headerlink" title="Step 1. 下载"></a>Step 1. 下载</h3><p>前往 Fira Code 字体的 GitHub 地址，clone 或者 download字体文件，主要有 5 个 .ttf 字体文件，地址<a href="https://github.com/tonsky/FiraCode/tree/master/distr/ttf">https://github.com/tonsky/FiraCode/tree/master/distr/ttf</a></p><h3 id="Step-2-安装"><a href="#Step-2-安装" class="headerlink" title="Step 2. 安装"></a>Step 2. 安装</h3><p>安装刚刚下载的 5 个字体文件：选择文件后点击鼠标右键，点击安装命令即可安装字体。</p><h3 id="Step-3-修改设置"><a href="#Step-3-修改设置" class="headerlink" title="Step 3. 修改设置"></a>Step 3. 修改设置</h3><p>打开 VS Code，如果在安装字体之前已经打开了，**一定要重启 **VS Code，否则识别不到新字体。</p><p>打开菜单File &gt; Preferences &gt; Settings，或者点击 File 后使用快捷键 <code>Ctrl+,</code>即可打开，然后打开 <strong>settings.json</strong>  文件，找到 <code>editor.fontFamily</code>字段，然后再把 Fira Code 添加到第一个，并且加上 <code>&quot;editor.fontLigatures&quot;: true</code> 。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-string">&quot;editor.fontFamily&quot;</span>: <span class="hljs-string">&quot;&#x27;Fira Code&#x27;, Menlo, Monaco, &#x27;Courier New&#x27;, monospace&quot;</span>,<br><span class="hljs-string">&quot;editor.fontLigatures&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//这个控制是否启用字体连字，true 启用，false 不启用，这里选择启用 </span><br></code></pre></td></tr></table></figure><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>来一个我最常用的 JavaScript 代码演示：</p><p><img src="http://imgs.taoweng.site/2019-12-19-131402.png" alt="image-20191219211400669"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
      <tag>VS Code</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端桃园周刊第四期</title>
    <link href="/index.php/archives/289/"/>
    <url>/index.php/archives/289/</url>
    
    <content type="html"><![CDATA[<h2 id="一句话知识"><a href="#一句话知识" class="headerlink" title="一句话知识"></a>一句话知识</h2><h3 id="npm-v-packageName-versions"><a href="#npm-v-packageName-versions" class="headerlink" title="npm v packageName versions"></a>npm v packageName versions</h3><p>npm v packageName versions 查看包的所有版本，不加s 获取新版本。用途，安装了包但是 package.json 里面没有包，需要手动填入的时候。</p><h3 id="typeof-null-为什么返回-“object”？"><a href="#typeof-null-为什么返回-“object”？" class="headerlink" title="typeof null 为什么返回 “object”？"></a><strong>typeof null 为什么返回 “object”？</strong></h3><p>不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判 断为 object 类型，null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“object”。</p><h3 id="in-和-hasOwnProperty-区别"><a href="#in-和-hasOwnProperty-区别" class="headerlink" title="in 和 hasOwnProperty 区别"></a>in 和 hasOwnProperty 区别</h3><p>in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中，不会检查 [[Prototype]] 链。</p><h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for in 和 for of 的区别"></a>for in 和 for of 的区别</h3><p>for in 用于对象的遍历，会遍历原型上可以枚举的属性</p><p>for of 用于遍历可迭代的对象，比如数组，因为数组里面是有迭代器的，凡是有迭代器的对象都可以用 for of 来遍历</p><h3 id="对-constructor-的误解"><a href="#对-constructor-的误解" class="headerlink" title="对 constructor 的误解"></a>对 constructor 的误解</h3><p>对象的 constructor 实际上不是对象创建的时候有的，而是通过委托到 prototype 上找的。</p><pre><code>function Foo() &#123; /* .. */ &#125;Foo.prototype = &#123; /* .. */ &#125;; // 创建一个新原型对象var a1 = new Foo();a1.constructor === Foo; // false! a1.constructor === Object; // true!</code></pre><p>可以看到 prototype 被替换之后，a1 的 constructor 已经不指向 Foo 了。</p><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/Qrzn3rLKfMI9V6diQ_7vBg">前端工程化（一）NPM如何管理依赖包版本？</a></li><li><a href="https://mp.weixin.qq.com/s/jMWoXzrw6WDi5VG9Y8Mn0Q">package.json 知多少？</a></li><li><a href="https://zhuanlan.zhihu.com/p/96084784">精读《正交的 React 组件》</a></li><li><a href="https://blog.bitsrc.io/javascript-internals-javascript-engine-run-time-environment-settimeout-web-api-eeed263b1617">JavaScript Internals: JavaScript engine, Run-time environment &amp; setTimeout Web API</a></li><li><a href="https://juejin.im/post/5b876f86518825431079ddd6#comment">彻底搞懂CSS层叠上下文、层叠等级、层叠顺序、z-index</a></li><li><a href="https://www.jianshu.com/p/e9b94b2d52e2">【JavaScript】深入理解Babel原理及其使用</a></li><li><a href="https://coolshell.cn/articles/19464.html">如何超过大多数人</a></li><li><a href="https://zhuanlan.zhihu.com/p/39620591">巧用 Typescript</a></li><li><a href="https://zhuanlan.zhihu.com/p/89570321">SWR：最具潜力的 React Hooks 数据请求库</a></li><li>[React Hooks 你真的用对了吗？](React Hooks 你真的用对了吗？)</li></ul><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><ol><li><a href="https://lihautan.com/">一个博主 Tan li Hau</a></li><li><a href="https://openlayers.org/">openlayers</a>。一个高性能、功能丰富的库，满足您所有的地图需求</li><li><a href="https://github.com/chenglou/react-motion">react-motion</a>。解决 React 动画的库</li><li><a href="https://github.com/manojVivek/medium-unlimited">medium-unlimited</a>。一个浏览器扩展，可无需会员免费读取medium.com文章。</li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Alfred 好用的 workflow：CodeVar、douban、知乎、Dash</li></ul>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>npm</tag>
      
      <tag>Alfred</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css计数器教程</title>
    <link href="/index.php/archives/288/"/>
    <url>/index.php/archives/288/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSS 里面的伪元素其实是非常好用的，但是经常容易被大家忽略，伪元素里面常用到的 <code>content</code> 属性，可能现在很多人仅仅以为 <code>content</code> 属性的值只支持字符串，除了字符串外常用到的还有 <code>uri</code>、<code>counter</code> ，今天所要介绍的就是 conter(计数器)。</p><p>先看如下的例子：</p><p><img src="http://imgs.taoweng.site/2019-12-09-133936.jpg" alt="905B9F15-6D46-463D-812C-17545A17516C"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>桃翁<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>介绍<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>css 计数器<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>根据如上的 HTML 你是否有办法不通过 JavaScript ，仅仅用 CSS 在 title 前面增加 <code>Title number:</code> 呢？</p><h2 id="CSS-计数器基本概念"><a href="#CSS-计数器基本概念" class="headerlink" title="CSS 计数器基本概念"></a>CSS 计数器基本概念</h2><p>如果仅仅增加一个 <strong>Title</strong>，大家都知道通过伪元素(:before或者:after)，设置 content 为 Title，但是如何自动根据 h3 出现的顺序来展示自动编号可能很多人就不知道了。</p><p>自动编号在 CSS 2.1 中是通过两个属性控制的，<a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-counter-increment">‘counter-increment’</a>和<a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-counter-reset">‘counter-reset’</a>。通过这些属性定义的计数器用于<a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-content">‘content’</a>属性的 counter() 和 counters() 函数</p><h3 id="初始化计数器"><a href="#初始化计数器" class="headerlink" title="初始化计数器"></a>初始化计数器</h3><p>在使用计数器的时候需要先初始化这个计数器，并且设置一个计数器的名字(变量)。下面是例子，title 就是名字，conter-reset 就是用来初始化的，这个属性是必须设置的，否则没办法用计数器。</p><p><a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-counter-reset">‘counter-reset’</a>属性也含有一列一个或多个计数器，每个后面可以跟一个可选的整数。该整数给定了每次出现该元素时给计数器设置的值，默认为 0</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">counter-reset</span>: 计数器名称[, 默认值number];           <span class="hljs-comment">/* 重置计数器成0 */</span><br></code></pre></td></tr></table></figure><h3 id="计数器自增"><a href="#计数器自增" class="headerlink" title="计数器自增"></a>计数器自增</h3><p>有了一个计数器的变量后，然后可以让这个变量进行自增：</p><p><a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-counter-increment">‘counter-increment’</a>属性接受一个或多个计数器名（标识符），每个后面都可以跟一个可选的整数。这个整数表示每次出现该元素时计数器递增几。默认增量是 1，可以接受 0 和负数</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">counter-increment</span>: 计数器名称[, 增量];      <span class="hljs-comment">/* 增加计数器值 */</span><br></code></pre></td></tr></table></figure><h3 id="显示计数器"><a href="#显示计数器" class="headerlink" title="显示计数器"></a>显示计数器</h3><p>最后就是现实计数器的值，获取计数器的值有两个函数：counter() 和 counters() ，如上面的例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(计数器名称[, 显示的风格]) /* 显示计数器 */<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">counters(计数器名称, 嵌套时拼接字符串<span class="hljs-selector-attr">[, 可选的显示风格]</span>)<br></code></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>学完了基本概念，然后就可以解决上面的问题了。按照步骤来，三步：</p><ol><li>初始化计时器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">counter-reset</span>: title;           <span class="hljs-comment">/* 重置计数器成0 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>计数器自增</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>:before &#123;<br>  counter-increment: title;      <span class="hljs-comment">/* 增加计数器值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>显示计数器</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h3</span>:before &#123;<br>  content: <span class="hljs-string">&quot;Title &quot;</span> <span class="hljs-built_in">counter</span>(title) <span class="hljs-string">&quot;: &quot;</span>; <span class="hljs-comment">/* 显示计数器 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>合起来的解决方案如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">counter-reset</span>: title;           <span class="hljs-comment">/* 重置计数器成0 */</span><br>&#125;<br><span class="hljs-selector-tag">h3</span>:before &#123;<br>  counter-increment: title;      <span class="hljs-comment">/* 增加计数器值 */</span><br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Title &quot;</span> <span class="hljs-built_in">counter</span>(title) <span class="hljs-string">&quot;: &quot;</span>; <span class="hljs-comment">/* 显示计数器 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="嵌套计数器与作用域"><a href="#嵌套计数器与作用域" class="headerlink" title="嵌套计数器与作用域"></a>嵌套计数器与作用域</h3><p>计数器是“自嵌套的（self-nesting）”，如果重置一个位于后代元素或者伪元素中的计数器，会自动创建一个新的计数器实例。这对 HTML 中的列表之类的场景来说很重要，这种场景下，元素自身可以嵌套任意深度，不用为每一层定义唯一命名的计数器</p><blockquote><p>计数器的作用域从文档中具有<a href="http://www.ayqy.net/doc/css2-1/generate.html#propdef-counter-reset">‘counter-reset’</a>该计数器的第一个元素开始，包括该元素的后代、后续兄弟及其后代。</p></blockquote><p>官方套话比较难懂，用大白话说就是设置了 <code>counter-reset</code> ，那么这个元素的的子元素都属于这个作用域下。</p><p>想要完全理解作用域，就得把下面这个 图看懂：</p><img src="http://imgs.taoweng.site/2019-12-09-142219.png" style="zoom:50%;" /><p>上面的这个 HTML 代码，再加上这段 CSS 代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">OL</span> &#123; <span class="hljs-attribute">counter-reset</span>: item &#125;<br><span class="hljs-selector-tag">LI</span> &#123; <span class="hljs-attribute">display</span>: block &#125;<br><span class="hljs-selector-tag">LI</span>:before &#123; <br>  counter-increment: item <br>&#125;<br><br></code></pre></td></tr></table></figure><p>OL 将会创建一个计数器，并且 OL 的所有子级将引用该计数器，如果我们用item[n]表示”item”计数器的第 n个实例，用”{“和”}”表示一个作用域的开始和结束，那么上面 HTML 片段将使用标注的计数器。</p><p>注意看 2.3.1 的两个元素，由于他们都在 2.3 下面，有两个同名的计数器，那么这两个同名计数器会分别创建实例，所有会得到两个 2.3.1。</p><p>如果懂了作用域的关系，接下来就可以通过 <code>counter()</code> 或者 <code>counters()</code> 函数进行展示。</p><p><strong>counter</strong></p><p>Counter 显示代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">OL</span> &#123; <span class="hljs-attribute">counter-reset</span>: item &#125;<br><span class="hljs-selector-tag">LI</span> &#123; <span class="hljs-attribute">display</span>: block &#125;<br><span class="hljs-selector-tag">LI</span>:before &#123; <br>  content: <span class="hljs-built_in">counter</span>(item) <span class="hljs-string">&quot;. &quot;</span>; <br>  <span class="hljs-attribute">counter-increment</span>: item <br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://imgs.taoweng.site/2019-12-09-143411.png" alt="image-20191209223410101"></p><p>可以看到 counter 只会显示当前作用域下计数器的值，如果要生成嵌套作用域的计数器就得用 counters 函数。</p><p><strong>counters</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">OL</span> &#123; <span class="hljs-attribute">counter-reset</span>: item &#125;<br><span class="hljs-selector-tag">LI</span> &#123; <span class="hljs-attribute">display</span>: block &#125;<br><span class="hljs-selector-tag">LI</span>:before &#123; <br>  content: <span class="hljs-built_in">counters</span>(item, <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-string">&quot; &quot;</span>; <br>  <span class="hljs-attribute">counter-increment</span>: item;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://imgs.taoweng.site/2019-12-09-143518.png" alt="image-20191209223516878"></p><h3 id="更换格式"><a href="#更换格式" class="headerlink" title="更换格式"></a>更换格式</h3><p>在显示计数器部分 counter 和 counters 都有一个可选参数，显示风格，这个显示风格跟 <a href="https://www.w3school.com.cn/cssref/pr_list-style-type.asp">list-style-type</a> 是一样的，比如我们将文章开头的例子拿来举例，默认是 decimal 风格，比如换成字母(type 是 lower-latin)形式，css 如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">counter-reset</span>: title;           <span class="hljs-comment">/* 重置计数器成0 */</span><br>&#125;<br><span class="hljs-selector-tag">h3</span>:before &#123;<br>  counter-increment: title;      <span class="hljs-comment">/* 增加计数器值 */</span><br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Title &quot;</span> <span class="hljs-built_in">counter</span>(title, lower-latin) <span class="hljs-string">&quot;: &quot;</span>; <span class="hljs-comment">/* 显示计数器 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果如下，list-style-type 有很多种，甚至还有中文(list-style-type 是 cjk-ideographic)的。</p><p><img src="http://imgs.taoweng.site/2019-12-10-140955.png" alt="image-20191210220952021"></p><h3 id="自定义起始值"><a href="#自定义起始值" class="headerlink" title="自定义起始值"></a>自定义起始值</h3><p>起始值订为 5</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">counter-reset</span>: title <span class="hljs-number">5</span>;           <span class="hljs-comment">/*起始值订为 5 */</span><br>&#125;<br><span class="hljs-selector-tag">h3</span>:before &#123;<br>  counter-increment: title;      <br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Title &quot;</span> <span class="hljs-built_in">counter</span>(title) <span class="hljs-string">&quot;: &quot;</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://imgs.taoweng.site/2019-12-10-151858.png" alt="image-20191210231857008"></p><h3 id="自定义每次递增的值"><a href="#自定义每次递增的值" class="headerlink" title="自定义每次递增的值"></a>自定义每次递增的值</h3><p>每次递增的值为 2</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">counter-reset</span>: title <span class="hljs-number">5</span>;       <br>&#125;<br><span class="hljs-selector-tag">h3</span>:before &#123;<br>  counter-increment: title <span class="hljs-number">2</span>;      <span class="hljs-comment">/* 每次递增的值为 2 */</span><br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;Title &quot;</span> <span class="hljs-built_in">counter</span>(title) <span class="hljs-string">&quot;: &quot;</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://imgs.taoweng.site/2019-12-10-152028.jpg" alt="D94591E0-4122-4212-957E-348ED5D0CBDA"></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="场景-1：-嵌套列表"><a href="#场景-1：-嵌套列表" class="headerlink" title="场景 1： 嵌套列表"></a>场景 1： 嵌套列表</h3><p>比如要生成一个文章的大纲：</p><p><img src="http://imgs.taoweng.site/2019-12-10-153647.png" alt="image-20191210233643948"></p><h3 id="场景2：-计算已经勾选的复选框"><a href="#场景2：-计算已经勾选的复选框" class="headerlink" title="场景2： 计算已经勾选的复选框"></a>场景2： 计算已经勾选的复选框</h3><p>使用输入框的：checked 伪类，我们可以检查复选框是否被选中，选中的话，我们计数器的数值就会增加。</p><p>下面的这个 2 种菜系直接就是可以通过计数器来实现的，不需要使用 js</p><p><img src="http://imgs.taoweng.site/2019-12-10-154028.png" alt="image-20191210234026403"></p><h3 id="场景3：-自动追踪文档条目"><a href="#场景3：-自动追踪文档条目" class="headerlink" title="场景3： 自动追踪文档条目"></a>场景3： 自动追踪文档条目</h3><p>当你需要处理一些重复元素的时候，并且你同样想统计他们的数量，那么这个方案会很好用。</p><p><img src="http://imgs.taoweng.site/2019-12-10-154341.png" alt="image-20191210234338534"></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/liuxianan/p/css-counters.html">css计数器详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过fetch发送 post 请求下载文件</title>
    <link href="/index.php/archives/284/"/>
    <url>/index.php/archives/284/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到一个下载的需求，由于 url 参数太长(常用的下载方法 a 标签或者 location.href 的方法都是 get 请求，get 请求参数长度有限制)，无法下载，考虑了好几种方案，最终还是觉得通过 ajax 的 POST 方法进行下载，比较容易实现，下面记录实现过程以及遇到的问题。</p><p>但是由于 <code>AJAX</code> 并不会唤起浏览器的下载窗口，<code>AJAX</code>设计的初衷就是用来实现<code>异步刷新</code>的，用以改善原始的 form 表单提交刷新页面的问题，那么如何来解决呢？</p><h2 id="POST-方法下载实现原理"><a href="#POST-方法下载实现原理" class="headerlink" title="POST 方法下载实现原理"></a>POST 方法下载实现原理</h2><p>通过 fetch 请求获取文件，然后利用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">Blob</a> 对象来接收处理，在接收到后端返回的文件后，把其转化一下，放入<code>a标签</code>的<code>href</code>中，并触发下载行为。</p><p>实现的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetch(url, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(params),<br>  <span class="hljs-attr">header</span>: &#123;<br>     <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span><br>  &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> response.blob();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">blob</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<br>  link.style.display = <span class="hljs-string">&#x27;none&#x27;</span><br>  link.href = URL.createObjectURL(blob)<br>  <span class="hljs-built_in">document</span>.body.appendChild(link)<br>  link.click()<br>  <span class="hljs-comment">// 释放的 URL 对象以及移除 a 标签</span><br>  URL.revokeObjectURL(link.href)<br>  <span class="hljs-built_in">document</span>.body.removeChild(link)<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里需要注意的是要记得要调用  response  的 blob 方法，这样才会返回一个 blob，如果你没用过 blob 的话，可能你以前只知道 json 和 text，其实 response 的 body 还可以转化为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/arrayBuffer"><code>arrayBuffer</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Body/formData"><code>formData</code></a>。</p><p>具体 Response 可以见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">MDN</a></p><h2 id="如何拿到文件名"><a href="#如何拿到文件名" class="headerlink" title="如何拿到文件名"></a>如何拿到文件名</h2><p>可以下载文件了只是第一步，但是你会发现还有一个问题，下载下来的文件名是你看不懂的名字，类似这样：<img src="http://imgs.taoweng.site/2019-11-22-090809.jpg" alt="86B41B95-8285-40FE-AE81-2BA3F179E9CE"></p><p>我这边的方案是把文件名放在 response 的 headers 里，放在 <strong>content-disposition</strong> 字段里，有个 fileName 字段，用来存放文件名。</p><blockquote><p>我感觉在下载文件的时候 <strong>content-disposition</strong>  字段对于他们后端来说感觉是都会加的，因为最开始我用 get 下载的时候就已经有这个字段了，如果你们后端没有设置这个 header ，可以设置一下，当然也可以设置到其他字段里。</p></blockquote><p><img src="http://imgs.taoweng.site/2019-11-22-091004.jpg" alt="4F2C21FF-0B49-456C-A79B-6AA58FF14353"></p><p><strong>一个小插曲</strong></p><p>当我把 fetch 后的 res 打印出来看 Response 的时候，发现 headers 里是空对象，如下：</p><p><img src="http://imgs.taoweng.site/2019-11-22-091415.jpg" alt="63A250A6-F8DF-4742-BD57-42DD1BCDAB4B"></p><p>然后我再通过 <code>res.headers</code> 直接去拿 headers，发现还是一个 Headers 的空对象。</p><p><img src="http://imgs.taoweng.site/2019-11-22-091708.jpg" alt="25D390BE-E613-4059-BE68-27B44BD11B22"></p><p>我还以为 headers 里面没有东西，但是当我直接通过 <code>res.headers.get(&#39;content-disposition&#39;)</code> 去拿的时候，竟然拿到了，数据像这样：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">attachment;fileName=%E7%9B%B4%E6%92%AD%E6%97%B6%E9%95%BF%E4%B8%BB%E6%92%AD%E6%98%8E%E7%BB%86.xls<br></code></pre></td></tr></table></figure><p>然后你就可以通过多种方式将文件名给提取出来，我这里采用的是通过 <code>split</code>方法来提取的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">res.headers.get(<span class="hljs-string">&#x27;content-disposition&#x27;</span>).split(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h2 id="最终的实现"><a href="#最终的实现" class="headerlink" title="最终的实现"></a>最终的实现</h2><p>准备工作都做好了，然后就写出了这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetch(url, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(params),<br>  <span class="hljs-attr">headers</span>: &#123;<br>     <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span><br>  &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> filename = res.headers.get(<span class="hljs-string">&#x27;content-disposition&#x27;</span>).split(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>]<br>  <span class="hljs-keyword">return</span> &#123;<br>    filename,<br>    <span class="hljs-attr">blob</span>: response.blob()<br>  &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<br>  link.style.display = <span class="hljs-string">&#x27;none&#x27;</span><br>  <span class="hljs-comment">// a 标签的 download 属性就是下载下来的文件名</span><br>  link.download = obj.filename<br>  link.href = URL.createObjectURL(obj.blob)<br>  <span class="hljs-built_in">document</span>.body.appendChild(link)<br>  link.click()<br>  <span class="hljs-comment">// 释放的 URL 对象以及移除 a 标签</span><br>  URL.revokeObjectURL(link.href)<br>  <span class="hljs-built_in">document</span>.body.removeChild(link)<br>&#125;);<br></code></pre></td></tr></table></figure><p>本以为就可以了，但是下载下来打开 excel 发现内容是 Promise，然后才发现原来 <code>response.blob()</code> 返回的是一个 promise。</p><p>所以改进的实现方案如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fetch(url, &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(params),<br>  <span class="hljs-attr">headers</span>: &#123;<br>     <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span><br>  &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> filename = res.headers.get(<span class="hljs-string">&#x27;content-disposition&#x27;</span>).split(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>]<br>  <br>  response.blob().then(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<br>    link.style.display = <span class="hljs-string">&#x27;none&#x27;</span><br>    <span class="hljs-comment">// a 标签的 download 属性就是下载下来的文件名</span><br>    link.download = filename<br>    link.href = URL.createObjectURL(blob)<br>    <span class="hljs-built_in">document</span>.body.appendChild(link)<br>    link.click()<br>    <span class="hljs-comment">// 释放的 URL 对象以及移除 a 标签</span><br>    URL.revokeObjectURL(link.href)<br>    <span class="hljs-built_in">document</span>.body.removeChild(link)<br>   &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>不过这种 then 里面又套了 then ，看着有点不好看，所以用 async/await 重新写了一版：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">postDownload</span>(<span class="hljs-params">url, params</span>) </span>&#123;<br>   <span class="hljs-keyword">const</span> request = &#123;<br>     <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify(params),<br>     <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>     <span class="hljs-attr">headers</span>: &#123;<br>       <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json;charset=UTF-8&#x27;</span><br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(url, request)<br>   <span class="hljs-keyword">const</span> filename = response.headers.get(<span class="hljs-string">&#x27;content-disposition&#x27;</span>).split(<span class="hljs-string">&#x27;;&#x27;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;=&#x27;</span>)[<span class="hljs-number">1</span>]<br>   <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> response.blob()<br><br>   <span class="hljs-keyword">const</span> link = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;a&#x27;</span>)<br>   link.download = <span class="hljs-built_in">decodeURIComponent</span>(filename)<br>   link.style.display = <span class="hljs-string">&#x27;none&#x27;</span><br>   link.href = URL.createObjectURL(blob)<br>   <span class="hljs-built_in">document</span>.body.appendChild(link)<br>   link.click()<br>   URL.revokeObjectURL(link.href)<br>   <span class="hljs-built_in">document</span>.body.removeChild(link)j<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数里没有写任何的错误处理，那也不是这篇文章要讲的，不过自己在实现的时候应该加上 try/catch，不然如果有问题，不报错还是很难受的。</p><p><img src="http://www.taoweng.site/usr/uploads/2020/03/1113982871.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fetch</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何对 React 函数式组件进行优化</title>
    <link href="/index.php/archives/280/"/>
    <url>/index.php/archives/280/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>本文只介绍函数式组件特有的性能优化方式，类组件和函数式组件都有的不介绍，比如 key 的使用。另外本文不详细的介绍 API 的使用，后面也许会写，其实想用好 hooks 还是蛮难的。</p><h3 id="面向读者"><a href="#面向读者" class="headerlink" title="面向读者"></a>面向读者</h3><p>有过 React 函数式组件的实践，并且对 hooks  有过实践，对 useState、useCallback、useMemo API 至少看过文档，如果你有过对类组件的性能优化经历，那么这篇文章会让你有种熟悉的感觉。</p><h3 id="React-性能优化思路"><a href="#React-性能优化思路" class="headerlink" title="React 性能优化思路"></a>React 性能优化思路</h3><p>我觉得React 性能优化的理念的主要方向就是这两个：</p><ol><li><p>减少重新 render 的次数。因为在 React 里最重(花时间最长)的一块就是 reconction(简单的可以理解为 diff)，如果不 render，就不会 reconction。</p></li><li><p>减少计算的量。主要是减少重复计算，对于函数式组件来说，每次 render 都会重新从头开始执行函数调用。</p></li></ol><p>在使用类组件的时候，使用的 React 优化 API 主要是：<code>shouldComponentUpdate </code>和  <code>PureComponent</code>，这两个 API 所提供的解决思路都是为了<strong>减少重新 render 的次数</strong>，主要是减少父组件更新而子组件也更新的情况，虽然也可以在 state 更新的时候阻止当前组件渲染，如果要这么做的话，证明你这个属性不适合作为 state，而应该作为静态属性或者放在 class 外面作为一个简单的变量 。</p><p>但是在函数式组件里面没有声明周期也没有类，那如何来做性能优化呢？</p><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><p>首先要介绍的就是 <code>React.memo</code>，这个 API 可以说是对标类组件里面的 <code>PureComponent</code>，这是可以减少重新 render 的次数的。</p><h3 id="可能产生性能问题的例子"><a href="#可能产生性能问题的例子" class="headerlink" title="可能产生性能问题的例子"></a>可能产生性能问题的例子</h3><p>举个例子，首先我们看两段代码：</p><p>在根目录有一个 index.js，代码如下，实现的东西大概就是：上面一个 title，中间一个 button(点击 button 修改 title)，下面一个木偶组件，传递一个 name 进去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [title, setTitle] = useState(<span class="hljs-string">&quot;这是一个 title&quot;</span>)<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123; title &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setTitle(&quot;title 已经改变&quot;)&#125;&gt;改名字<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;桃桃&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Child</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);<br><br></code></pre></td></tr></table></figure><p>在同级目录有一个  child.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// child.js</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(props.name)<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Child<br></code></pre></td></tr></table></figure><p>当首次渲染的时候的效果如下：</p><p><img src="http://imgs.taoweng.site/2019-10-30-141225.png" alt="image-20191030221223045"></p><p>并且控制台会打印<code>&quot;桃桃”</code>，证明 Child 组件渲染了。</p><p>接下来点击<strong>改名字</strong>这个 button，页面会变成：</p><p><img src="http://imgs.taoweng.site/2019-10-30-142024.png" alt="image-20191030222021717"></p><p>title 已经改变了，而且控制台也打印出<code>&quot;桃桃&quot;</code>，可以看到虽然我们改的是父组件的状态，父组件重新渲染了，并且子组件也重新渲染了。你可能会想，传递给 Child 组件的 props 没有变，要是 Child 组件不重新渲染就好了，为什么会这么想呢？</p><p>我们假设 Child 组件是一个非常大的组件，渲染一次会消耗很多的性能，那么我们就应该尽量减少这个组件的渲染，否则就容易产生性能问题，所以子组件如果在 props 没有变化的情况下，就算父组件重新渲染了，子组件也不应该渲染。</p><p>那么我们怎么才能做到在 props 没有变化的时候，子组件不渲染呢？</p><p>答案就是用 <code>React.memo</code> 在给定相同 props 的情况下渲染相同的结果，并且通过记忆组件渲染结果的方式来提高组件的性能表现。</p><h3 id="React-memo-的基础用法"><a href="#React-memo-的基础用法" class="headerlink" title="React.memo 的基础用法"></a>React.memo 的基础用法</h3><p>把声明的组件通过<code>React.memo</code>包一层就好了，<code>React.memo</code>其实是一个高阶函数，传递一个组件进去，返回一个可以记忆的组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Component</span>(<span class="hljs-params">props</span>) </span>&#123;<br>   <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;<br><span class="hljs-keyword">const</span> MyComponent = React.memo(Component);<br></code></pre></td></tr></table></figure><p>那么上面例子的 Child 组件就可以改成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(props.name)<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(Child)<br></code></pre></td></tr></table></figure><p>通过 <code>React.memo</code> 包裹的组件在 props 不变的情况下，这个被包裹的组件是不会重新渲染的，也就是说上面那个例子，在我点击改名字之后，仅仅是 title 会变，但是 Child 组件不会重新渲染（表现出来的效果就是 Child 里面的 log 不会在控制台打印出来），会直接复用最近一次渲染的结果。</p><p>这个效果基本跟类组件里面的 <code>PureComponent</code>效果极其类似，只是前者用于函数组件，后者用于类组件。</p><h3 id="React-memo-高级用法"><a href="#React-memo-高级用法" class="headerlink" title="React.memo 高级用法"></a>React.memo 高级用法</h3><p>默认情况下其只会对 props 的复杂对象做浅层对比(浅层对比就是只会对比前后两次 props 对象引用是否相同，不会对比对象里面的内容是否相同)，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-comment">/* 使用 props 渲染 */</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">areEqual</span>(<span class="hljs-params">prevProps, nextProps</span>) </span>&#123;<br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">  如果把 nextProps 传入 render 方法的返回结果与</span><br><span class="hljs-comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span><br><span class="hljs-comment">  否则返回 false</span><br><span class="hljs-comment">  */</span><br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(MyComponent, areEqual);<br></code></pre></td></tr></table></figure><blockquote><p>此部分来自于 <a href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo">React 官网</a>。</p></blockquote><p>如果你有在类组件里面使用过  <a href="https://zh-hans.reactjs.org/docs/react-component.html#shouldcomponentupdate"><code>shouldComponentUpdate()</code></a> 这个方法，你会对 <code>React.memo</code> 的第二个参数非常的熟悉，不过值得注意的是，如果 props 相等，<code>areEqual</code> 会返回 <code>true</code>；如果 props 不相等，则返回 <code>false</code>。这与 <code>shouldComponentUpdate</code> 方法的返回值相反。</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>现在根据上面的例子，再改一下需求，在上面的需求上增加一个副标题，并且有一个修改副标题的 button，然后把修改标题的 button 放到 Child 组件里。</p><blockquote><p>把修改标题的 button 放到 Child 组件的目的是，将修改 title 的事件通过 props 传递给 Child 组件，然后观察这个事件可能会引起性能问题。</p></blockquote><p><strong>首先看代码：</strong></p><p>父组件 index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [title, setTitle] = useState(<span class="hljs-string">&quot;这是一个 title&quot;</span>);<br>  <span class="hljs-keyword">const</span> [subtitle, setSubtitle] = useState(<span class="hljs-string">&quot;我是一个副标题&quot;</span>);<br><br>  <span class="hljs-keyword">const</span> callback = <span class="hljs-function">() =&gt;</span> &#123;<br>    setTitle(<span class="hljs-string">&quot;标题改变了&quot;</span>);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;subtitle&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setSubtitle(&quot;副标题改变了&quot;)&#125;&gt;改副标题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;callback&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;桃桃&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);<br><br></code></pre></td></tr></table></figure><p>子组件 child.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(props);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;props.onClick&#125;</span>&gt;</span>改标题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(Child);<br></code></pre></td></tr></table></figure><p><strong>首次渲染的效果</strong></p><p><img src="http://imgs.taoweng.site/2019-10-31-155607.png" alt="image-20191031235605228"></p><p>这段代码在首次渲染的时候会显示上图的样子，并且控制台会打印出<code>桃桃</code>。</p><p>然后当我点击<strong>改副标题</strong>这个 button 之后，副标题会变为「副标题改变了」，并且控制台会再次打印出<code>桃桃</code>，这就证明了子组件又重新渲染了，但是子组件没有任何变化，那么这次 Child 组件的重新渲染就是多余的，那么如何避免掉这个多余的渲染呢？</p><h3 id="找原因"><a href="#找原因" class="headerlink" title="找原因"></a>找原因</h3><p>我们在解决问题的之前，<strong>首先要知道这个问题是什么原因导致的？</strong></p><p>咱们来分析，一个组件重新重新渲染，一般三种情况：</p><ol><li><p>要么是组件自己的状态改变</p></li><li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件的 props 没有改版</p></li><li><p>要么是父组件重新渲染，导致子组件重新渲染，但是父组件传递的 props 改变</p></li></ol><p>接下来用排除法查出是什么原因导致的：</p><p>第一种很明显就排除了，当点击<strong>改副标题</strong> 的时候并没有去改变 Child 组件的状态；</p><p>第二种情况好好想一下，是不是就是在介绍 <code>React.memo</code> 的时候情况，父组件重新渲染了，父组件传递给子组件的 props 没有改变，但是子组件重新渲染了，我们这个时候用 <code>React.memo</code> 来解决了这个问题，所以这种情况也排除。</p><p>那么就是第三种情况了，当父组件重新渲染的时候，传递给子组件的 props 发生了改变，再看传递给 Child 组件的就两个属性，一个是 <code>name</code>，一个是 <code>onClick</code> ，<code>name</code> 是传递的常量，不会变，变的就是 <code>onClick</code> 了，为什么传递给 onClick 的 callback 函数会发生改变呢？在文章的开头就已经说过了，在函数式组件里每次重新渲染，函数组件都会重头开始重新执行，那么这两次创建的 callback 函数肯定发生了改变，所以导致了子组件重新渲染。 </p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>找到问题的原因了，那么解决办法就是在函数没有改变的时候，重新渲染的时候保持两个函数的引用一致，这个时候就要用到 <code>useCallback</code> 这个 API 了。</p><h4 id="useCallback-使用方法"><a href="#useCallback-使用方法" class="headerlink" title="useCallback 使用方法"></a>useCallback 使用方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> callback = <span class="hljs-function">() =&gt;</span> &#123;<br>  doSomething(a, b);<br>&#125;<br><br><span class="hljs-keyword">const</span> memoizedCallback = useCallback(callback, [a, b])<br></code></pre></td></tr></table></figure><p>把函数以及依赖项作为参数传入 <code>useCallback</code>，它将返回该回调函数的 memoized 版本，这个 memoizedCallback 只有在依赖项有变化的时候才会更新。</p><p>那么可以将 index.js 修改为这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> React, &#123; useState, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom&quot;</span>;<br><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./child&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [title, setTitle] = useState(<span class="hljs-string">&quot;这是一个 title&quot;</span>);<br>  <span class="hljs-keyword">const</span> [subtitle, setSubtitle] = useState(<span class="hljs-string">&quot;我是一个副标题&quot;</span>);<br><br>  <span class="hljs-keyword">const</span> callback = <span class="hljs-function">() =&gt;</span> &#123;<br>    setTitle(<span class="hljs-string">&quot;标题改变了&quot;</span>);<br>  &#125;;<br><br>  <span class="hljs-comment">// 通过 useCallback 进行记忆 callback，并将记忆的 callback 传递给 Child</span><br>  <span class="hljs-keyword">const</span> memoizedCallback = useCallback(callback, [])<br>  <br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;title&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;subtitle&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setSubtitle(&quot;副标题改变了&quot;)&#125;&gt;改副标题<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;memoizedCallback&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;桃桃&quot;</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">const</span> rootElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;root&quot;</span>);<br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, rootElement);<br><br></code></pre></td></tr></table></figure><p>这样我们就可以看到只会在首次渲染的时候打印出<strong>桃桃</strong>，当点击改副标题和改标题的时候是不会打印<strong>桃桃</strong>的。</p><p>如果我们的 callback 传递了参数，当参数变化的时候需要让它重新添加一个缓存，可以将参数放在 useCallback 第二个参数的数组中，作为依赖的形式，使用方式跟 useEffect 类似。</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>在文章的开头就已经介绍了，React 的性能优化方向主要是两个：一个是减少重新 render 的次数(或者说减少不必要的渲染)，另一个是减少计算的量。</p><p>前面介绍的 <strong>React.memo</strong> 和 <strong>useCallback</strong> 都是为了减少重新 render 的次数。对于如何减少计算的量，就是 useMemo 来做的，接下来我们看例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [num, setNum] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 一个非常耗时的一个计算函数</span><br>  <span class="hljs-comment">// result 最后返回的值是 49995000</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expensiveFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>      result += i;<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(result) <span class="hljs-comment">// 49995000</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> base = expensiveFn();<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>count：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(num + base)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>首次渲染的效果如下：</p><p><img src="http://imgs.taoweng.site/2019-11-13-124545.png" alt="useMemo"></p><p>这个例子功能很简单，就是点击 <strong>+1</strong> 按钮，然后会将现在的值(num) 与 计算函数 (expensiveFn) 调用后的值相加，然后将和设置给 num 并显示出来，在控制台会输出 <code>49995000</code>。</p><h3 id="可能产生性能问题"><a href="#可能产生性能问题" class="headerlink" title="可能产生性能问题"></a>可能产生性能问题</h3><p>就算是一个看起来很简单的组件，也有可能产生性能问题，通过这个最简单的例子来看看还有什么值得优化的地方。</p><p>首先我们把 expensiveFn 函数当做一个计算量很大的函数(比如你可以把 i 换成 10000000)，然后当我们每次点击 <strong>+1</strong> 按钮的时候，都会重新渲染组件，而且都会调用 expensiveFn 函数并输出 <code>49995000</code>。由于每次调用 expensiveFn 所返回的值都一样，所以我们可以想办法将计算出来的值缓存起来，每次调用函数直接返回缓存的值，这样就可以做一些性能优化。</p><h3 id="useMemo-做计算结果缓存"><a href="#useMemo-做计算结果缓存" class="headerlink" title="useMemo 做计算结果缓存"></a>useMemo 做计算结果缓存</h3><p>针对上面产生的问题，就可以用 useMemo 来缓存 expensiveFn 函数执行后的值。</p><p>首先介绍一下 useMemo 的基本的使用方法，详细的使用方法可见<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo">官网</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computeExpensiveValue</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 计算量很大的代码</span><br>  <span class="hljs-keyword">return</span> xxx<br>&#125;<br><br><span class="hljs-keyword">const</span> memoizedValue = useMemo(computeExpensiveValue, [a, b]);<br></code></pre></td></tr></table></figure><p>useMemo 的第一个参数就是一个函数，这个函数返回的值会被缓存起来，同时这个值会作为 useMemo 的返回值，第二个参数是一个数组依赖，如果数组里面的值有变化，那么就会重新去执行第一个参数里面的函数，并将函数返回的值缓存起来并作为 useMemo 的返回值 。</p><p>了解了 useMemo 的使用方法，然后就可以对上面的例子进行优化，优化代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> [num, setNum] = useState(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">expensiveFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>      result += i;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(result)<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-keyword">const</span> base = useMemo(expensiveFn, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>count：&#123;num&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setNum(num + base)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上面的代码，然后现在可以观察无论我们点击 <strong>+1</strong>多少次，只会输出一次 <strong>49995000</strong>，这就代表 expensiveFn 只执行了一次，达到了我们想要的效果。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>useMemo 的使用场景主要是用来<strong>缓存计算量比较大的函数结果</strong>，可以避免不必要的重复计算，有过 vue 的使用经历同学可能会觉得跟 Vue 里面的计算属性有异曲同工的作用。</p><blockquote><p>不过另外提醒两点</p><p>一、如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值；</p><p>二、计算量如果很小的计算函数，也可以选择不使用 useMemo，因为这点优化并不会作为性能瓶颈的要点，反而可能使用错误还会引起一些性能问题。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于性能瓶颈可能对于小项目遇到的比较少，毕竟计算量小、业务逻辑也不复杂，但是对于大项目，很可能是会遇到性能瓶颈的，但是对于性能优化有很多方面：网络、关键路径渲染、打包、图片、缓存等等方面，具体应该去优化哪方面还得自己去排查，本文只介绍了性能优化中的冰山一角：运行过程中 React 的优化。</p><ol><li>React 的优化方向：减少 render 的次数；减少重复计算。</li><li>如何去找到 React 中导致性能问题的方法，见 useCallback 部分。</li><li>合理的拆分组件其实也是可以做性能优化的，你这么想，如果你整个页面只有一个大的组件，那么当 props 或者 state 变更之后，需要 reconction 的是整个组件，其实你只是变了一个文字，如果你进行了合理的组件拆分，你就可以控制更小粒度的更新。</li></ol><blockquote><p>合理拆分组件还有很多其他好处，比如好维护，而且这是学习组件化思想的第一步，合理的拆分组件又是一门艺术了，如果拆分得不合理，就有可能导致状态混乱，多敲代码多思考。</p></blockquote><h2 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h2><p>我这里只介绍了函数式组件的优化方式，更多的 React 优化技巧可以阅读下面的文章：</p><ul><li><a href="https://www.infoq.cn/article/KVE8xtRs-uPphptq5LUz">21 个 React 性能优化技巧</a></li><li><a href="https://juejin.im/post/5d045350f265da1b695d5bf2#heading-0">浅谈React性能优化的方向</a> </li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>我是桃翁，一个爱思考的前端er，想了解关于更多的前端相关的，请关注我的公号：「前端桃园」，如果想加入交流群关注公众号后回复「微信」拉你进群</p><p><img src="http://imgs.taoweng.site/2019-11-19-002953.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在mac上安装XAMPP并搭建 typecho 博客</title>
    <link href="/index.php/archives/272/"/>
    <url>/index.php/archives/272/</url>
    
    <content type="html"><![CDATA[<p>在 v 站上看一个自己非常喜欢的博客主题：<a href="https://meowv.com/">阿星Plus</a>，但是由于是用 .Net 写的，自己完全不熟悉 .Net，所以就准备自己按照他的博客风格写一份 typecho的主题。</p><p>我也没接触过 PHP，在安装环境这一步就把我难住了，历经磨难，最终选择了 XAMPP 来搭建 PHP 环境，在这里记下搭建的过程和遇到的坑。</p><p>我刚开始去搜索 「XAMPP 搭建 typecho」，然而由于 typecho 资料太少，根本搜不到，所以选择了搜索「XAMPP 搭建 wordpress」，然后才一步一步的安装好了 XAMPP。</p><h2 id="什么是-XAMPP"><a href="#什么是-XAMPP" class="headerlink" title="什么是 XAMPP"></a>什么是 XAMPP</h2><p>XAMPP（Apache+MySQL+PHP+PERL）是一个功能强大的建站集成软件包。</p><h2 id="安装-XAMPP"><a href="#安装-XAMPP" class="headerlink" title="安装 XAMPP"></a>安装 XAMPP</h2><p>首先要知道 XAMPP 有两中安装方式：</p><ul><li>第一种：OS X的XAMPP是OS X的本地安装程序。它将Apache，PHP和其他XAMPP组件直接安装在OS X系统的 <code>/Applications/XAMPP</code> 文件夹中。</li><li>第二种：XAMPP-VM是OS X的虚拟机，它包括Apache，PHP和其他XAMPP组件，并在OS X系统上的基于Linux的虚拟机中运行它们。</li></ul><p>这两种方式我都试过，相信我，采用第一种安装方式。</p><p>值得提醒的是在 <a href="https://www.apachefriends.org/index.html">XMAPP 首页</a>下载的是 OS X 的虚拟机的，下载的时候文件名称会有 vm ，要下载安装程序的，要去 <a href="https://www.apachefriends.org/download.html">Download 里面下载</a>，文件名称会有 installer 的字样。</p><h2 id="使用-XAMPP"><a href="#使用-XAMPP" class="headerlink" title="使用 XAMPP"></a>使用 XAMPP</h2><p>这里我写的会比较简单，自己随便看看就知道怎么用了。</p><p><img src="http://imgs.taoweng.site/2019-11-14-130817.png" alt="image-20191114210816014"></p><p>安装好了进入界面，直接点 <strong>Start All</strong>就行，如果上图中花框的灯是像我图中的绿色就代表启动成功，失败了就会是红色。</p><h2 id="安装-typecho"><a href="#安装-typecho" class="headerlink" title="安装 typecho"></a>安装 typecho</h2><ol><li>将官网下载的 typecho 安装包下载下来。</li><li>将安装包移动到 htdocs 文件夹下并解压，htdocs 文件夹路径如图，在应用程序 -&gt; XAMPP-&gt;htdocs</li></ol><p><img src="http://imgs.taoweng.site/2019-11-14-131204.png" alt="image-20191114211202385"></p><ol start="3"><li>访问 localhost/build 即可进入安装页面进行 typecho 的安装。</li></ol><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="1-XAMPP-mysql-无法启动的问题"><a href="#1-XAMPP-mysql-无法启动的问题" class="headerlink" title="1. XAMPP mysql 无法启动的问题"></a>1. XAMPP mysql 无法启动的问题</h3><p>我这里遇到问题是由于端口和我本地的 mysql 端口(3306)冲突了，解决的方法就是修改端口号：</p><p><img src="http://imgs.taoweng.site/2019-11-14-133917.png" alt="image-20191114213915631"></p><p>选中 mysql，然后再点击 configure，然后再将弹窗里面的 port 将 3306 改成其他的。</p><h3 id="2-安装-typecho-报：对不起-无法连接数据库-请先检查数据库配置再继续进行安装。"><a href="#2-安装-typecho-报：对不起-无法连接数据库-请先检查数据库配置再继续进行安装。" class="headerlink" title="2. 安装 typecho 报：对不起,无法连接数据库,请先检查数据库配置再继续进行安装。"></a>2. 安装 typecho 报：对不起,无法连接数据库,请先检查数据库配置再继续进行安装。</h3><p>问题肯定就是数据库的问题，需要在数据库里建立一个名为 <strong>typecho</strong>  的数据库，步骤如下：</p><ol><li>打开 phpmyadmin，地址是：<a href="http://localhost/phpmyadmin%E3%80%82">http://localhost/phpmyadmin。</a></li><li>新建数据库 名为 typecho 的数据库。</li><li>在安装界面数据库的密码不填，因为默认 phpmyadmin 的数据库是没有密码。</li></ol><p>经过上面三个步骤应该就可以安装成功了！</p><p>做完笔记我就要开始写我的主题了！</p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如果解决虚度时光，首先做到要事第一</title>
    <link href="/index.php/archives/270/"/>
    <url>/index.php/archives/270/</url>
    
    <content type="html"><![CDATA[<p>阅读文章之前你可以花半分钟想想你觉得你自己最虚度的时光是时候？</p><h2 id="夸自己"><a href="#夸自己" class="headerlink" title="夸自己"></a>夸自己</h2><p>可能在很多人的眼里，我以及算是一个努力、上进的人了，那是因为他们只看到了我努力的时候，没有看到我虚度的时候。</p><p>一般在工作日我还是非常的恪守自己的原则，在不上班的时候都会提升自己，比如看书、听课、阅读、写作等方式。跟一般的人比起来更努力的点就是早上我会先学习一个小时，我一般 7 点半就会起床，然后看书或者听课一小时后，也就是 8 点半的时候才会去洗漱，下班回来也很少除了和女朋友每天至少视频半小时外，其余时间用得都很充分(用的方向对不对先不谈)。</p><h2 id="虚度"><a href="#虚度" class="headerlink" title="虚度"></a>虚度</h2><p>接下来就说到重点了，虚度的时光。</p><p>我觉得我最虚度的时光就是周末，本来会有充足的时间来学习，但是当打开电脑突然不知道应该干什么(这个时候非常的难受，经常在这个时候想做人的意义是什么)，然后就去看书，看了一会儿还是会觉得无聊，然后就说打会儿游戏吧，我一般有个习惯就是一直会打到输才会停止，往往经常又是连赢好几把，导致有可能一打就是一上午或者一下午过去了，然后就去做饭吃。</p><p>一旦到晚上七八点的时候，那个时候突然又觉得学习的奋劲儿又来了，然后会认真看书，看课程写文章等自己觉得对的事儿。然后就开始感叹自己白天的时间又浪费了，晚上再来补，那我们重庆人的话来说就是：「早不忙，夜慌张」。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><p>很好奇的是为什么工作了才会出现这种情况，而在高中大学没有出现。</p><p>在高中的时候，我们大家的目标非常明确，就是考大学，每天要做的事情就是看书，做题就行，目的很明确，要做的事情非常的清晰，所以不会有这种不知道该干啥的情况。</p><p>到大学的时候我长期呆在实验室，每天 11 点才到寝室，然后觉得自己应该放松了，就玩玩手机，聊聊天是应该的，这在我的大脑里是应该做的，到了周末的时候，我也觉得应该放松，所以在放假之前已经给自己订好了周末要做的事情，会出去玩，或者打游戏等。</p><p>我觉得我就是没做好《高效能人士的七个习惯》里的<strong>要事第一</strong>。</p><blockquote><p>有兴趣的话我也可以写写这本书的读后感，这本书是今年我读的书里收益最大的书。</p></blockquote><p>相信要事第一还是不难理解，就是把最重要的事情先做。所以首先我应该找出对我来说最重要的事情，然后我没找出来，或者说我没去认真思考对于我来说最重要的事情是什么，导致我有空闲的时候不知道应该干什么，因为想干的事情太多，导致觉得都不重要，你想想你会不会有过这样的感受。</p><p>我再说一种情况，我觉得大部分人也有过这种经历，在工作日的时候想做的事情很多，然后把原因归结为上班太忙，所以在工作日不做，准备打算到周末去做，然而到周末了，往往又由于想做的事情太多，导致最后不做了。</p><p>然后我回想我工作以前为什么没有这种状态，感觉每天都知道自己应该干啥，就算是打游戏也知道自己该打游戏了。</p><h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>这些都是没有做到要事第一的第一步，找出最重要的事情。</p><p>那么如何找到最重要的事情呢，我觉得一个很好的方法就是「做减法」。做加法谁都会做，想到什么事情就忘自己的待办事项或者大脑里面加就行了，但是这样就会导致要做的事情越来越多，最后太多了，然后都不做了。</p><p>如果做减法我觉得可以用《搞定》书中的 GTD 方法来帮助我们完成，相信很多人对 GTD 的印象只是存在于写 Todo List，然后把做完的事情标记为完成。其实这只是其中的一个小步骤，GTD 最核心的思想是想<strong>通过工具把事情从我们的大脑里面清空，让我们的大脑能专注做一件事情</strong>，而不是在做某件事情的时候，又想到其他事情没做，这样就会分心，效率就会大大的降低。</p><p>GTD 会有五个核心步骤：收集、处理、组织、检查、做。其中收集的作用就是把你的想法从大脑清空，通过工具帮你把想法记下来，处理过程就是我们做减法的过程，将一些不重要的东西给丢掉。</p><blockquote><p>如果有兴趣，GTD 后面我专门写一篇文章来介绍，非常有效的一种习惯。</p></blockquote><p>丢掉之后还有一些你需要的做的事情，然后再把这些需要做的事情再去认真思考什么事情是最重要的，然后再去做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文章写了为什么会有虚度的感觉，然后为什么会产生虚度的感觉，然后结合 GTD 给出了解决方案，希望能给你带来启发。</p><p>希望你在留言区里留出你什么时候会最感觉自己虚度了，然后又是怎么去解决的呢？</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何让 useEffect 只在依赖变化的时候执行</title>
    <link href="/index.php/archives/271/"/>
    <url>/index.php/archives/271/</url>
    
    <content type="html"><![CDATA[<h2 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h2><p>今天遇到一个 <code>useEffect</code> 的问题，遇到一个问题：在 useEffect 里面发异步请求，然后第二个参数的依赖也是异步请求之后得到的结果，然后就导致最终结果会请求两次 useEffect 里的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">const</span> [metaKey, setMetaKey] = useState&lt;string[]&gt;([])<br><br> <span class="hljs-comment">// useEffect1</span><br> useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>   getServiceCoreIndexParam().then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>     setMetaKey(res.data.defaultValue)<br>     <span class="hljs-keyword">return</span> res.data<br>   &#125;)<br> &#125;, [])<br><br> <span class="hljs-comment">// useEffect2</span><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  getAdvisorIndexTable(&#123;<br>    <span class="hljs-attr">visitdate</span>: props.visitdate,<br>    <span class="hljs-attr">advisorSupervisor</span>: props.advisorSupervisor,<br>    <span class="hljs-attr">comparevisitdate</span>: props.comparevisitdate,<br>    <span class="hljs-attr">metaKeys</span>: metaKey || []<br>  &#125;).then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>    res.success &amp;&amp; setTable(res.data)<br>  &#125;)<br>&#125;, [props.visitdate, props.advisorSupervisor, metaKey, props.comparevisitdate])<br></code></pre></td></tr></table></figure><p>分析一下这段代码，首先在组件 mount 的时候，<code>useEffect2</code> 会调用一次 <code>getAdvisorIndexTable</code>，当 useEffect1 执行完毕之后 <code>setMetaKey</code> 后，由于 metaKey 发生改变，导致 <code>getAdvisorIndexTable</code> 还会调用一次，这很明显是我们不想看到的结果，因为这只是一个默认请求，然而发了两次请求。</p><p>其实最开始我以为 useEffect 如果有了第二个参数，在 mount 的时候并不会去调用回调，而仅仅是在依赖变化后才调用回调，后来发现我的依赖没有变，也调用了，所以我就写了个 demo 试了下，发现 useEffect 在 mount 的时候就会默认调用一次回调。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>那么遇到这种情况应该怎么才能让 useEffect 在只有依赖变化的时候才去执行呢？或者说如何让我这个代码只请求一次呢？</p><p><strong>方法一</strong></p><p>通过增加一个 mount 的一个 state，默认为 false，当 mount 过后就把这个 state 设置为 true，然后在 useEffect 内部去判断 mount 的逻辑和依赖更新的逻辑。</p><p>上面的代码就可以改成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> [metaKey, setMetaKey] = useState&lt;string[]&gt;([])<br><span class="hljs-keyword">const</span> [status, setStatus] = useState(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 是否 mount 过的状态</span><br><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  getServiceCoreIndexParam().then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>    setStatus(<span class="hljs-literal">true</span>)<br>    setMetaKey(res.data.defaultValue)<br>    <span class="hljs-keyword">return</span> res.data<br>  &#125;)<br>&#125;, [])<br><br>useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span>(status) &#123;<br>    getAdvisorIndexTable(&#123;<br>      <span class="hljs-attr">visitdate</span>: props.visitdate,<br>      <span class="hljs-attr">advisorSupervisor</span>: props.advisorSupervisor,<br>      <span class="hljs-attr">comparevisitdate</span>: props.comparevisitdate,<br>      <span class="hljs-attr">metaKeys</span>: metaKey || []<br>    &#125;).then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>      res.success &amp;&amp; setTable(res.data)<br>    &#125;)<br>  &#125;<br><br>&#125;, [props.visitdate, props.advisorSupervisor, metaKey, props.comparevisitdate])<br></code></pre></td></tr></table></figure><p>新增了一个 status 状态，用来标识是否 mount 过，在第一个 useEffect 里当异步方法请求完了之后回来再把 status 设置为 true，那么当第一次渲染的时候第二个 useEffect 里 status 是 false，里面的逻辑不会执行，当第一个 useEffect 异步请求回调回来的时候 setMetaKey 会更新组件，那么这个时候第二个 useEffect 里也会去再次调用 effect，而且这个时候 status 是 true 了，这样就达到了我们想要的效果。</p><p><strong>方法二</strong></p><p>可以写一个 mount 的时候不执行的 hooks。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useUpdateEffect</span>(<span class="hljs-params">cb: () =&gt; <span class="hljs-keyword">void</span>, depend: any[]</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> [status, setStatus] = useState(<span class="hljs-literal">false</span>)<br><br>    useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span>(status) &#123;<br>            cb()<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            setStatus(<span class="hljs-literal">true</span>)<br>        &#125;<br>    &#125;, depend)<br>&#125;<br><br> <span class="hljs-keyword">const</span> [metaKey, setMetaKey] = useState&lt;string[]&gt;([])<br><br> useEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>   getServiceCoreIndexParam().then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>     setMetaKey(res.data.defaultValue)<br>     <span class="hljs-keyword">return</span> res.data<br>   &#125;)<br> &#125;, [])<br><br>useUpdateEffect(<span class="hljs-function">() =&gt;</span> &#123;<br>  getAdvisorIndexTable(&#123;<br>    <span class="hljs-attr">visitdate</span>: props.visitdate,<br>    <span class="hljs-attr">advisorSupervisor</span>: props.advisorSupervisor,<br>    <span class="hljs-attr">comparevisitdate</span>: props.comparevisitdate,<br>    <span class="hljs-attr">metaKeys</span>: metaKey || []<br>  &#125;).then(<span class="hljs-function">(<span class="hljs-params">res: IResult</span>) =&gt;</span> &#123;<br>    res.success &amp;&amp; setTable(res.data)<br>  &#125;)<br>&#125;, [props.visitdate, props.advisorSupervisor, metaKey, props.comparevisitdate])<br><br></code></pre></td></tr></table></figure><p><code>useUpdateEffect</code> 就是相当于第一次调用 useEffect 的回调的时候不执行，第二次的时候才执行，基本上达到要求。</p><p><img src="http://www.taoweng.site/usr/uploads/2020/03/1113982871.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>看到这段话，真的觉得现在的读者要求比较高</title>
    <link href="/index.php/archives/255/"/>
    <url>/index.php/archives/255/</url>
    
    <content type="html"><![CDATA[<p>最近看到这样一段文字，然后掘金的运营还发了一个<a href="https://juejin.im/pin/5d73b51cf265da1975253cf1">沸点</a>，看了心理觉得真不是滋味呀。</p><p><img src="http://imgs.taoweng.site/2019-09-08-161633.jpg" alt="image-20190908235905303"></p><p>图片具体内容如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/7/16d0bfb71f60c0c4?w=990&h=2400&f=png&s=694482"></p><blockquote><p>如果你在阅读文章的过程中，觉得有不同意的，请憋住，把文章看完再说。</p></blockquote><p>现在的作者写个文章太难了呀。</p><p>写个文章还要被喷写得不好，写得不够有深度要被说没有干货；</p><p>写得有深度的又有人说看不懂，这怪作者吗？</p><p>咋不怪读者要求太多，自己看不适合自己的水平的文章，自己知道的东西就觉得人人都知道，却不知道在中国随便一个你觉得理所当然的小知识点，或者说常识，都会有至少 1 亿人不知道。</p><p>很多人在评论里说现在很多面试文章，或者 list 文章没啥质量，然后获赞很多，然后自己辛辛苦苦的写的干货没人点赞，在这个社会不是很正常么，想想马云工作的强度和在工地里工作的工人相比，工人不努力吗，难道不是辛辛苦苦吗？但是赚钱的差距就是这么大，这个社会就是这么现实，归根到底工人所做的工作价值太少了，为什么有些干货价值少，请继续阅读。</p><p>##面试题和 list 文章 VS “所谓的干货” </p><p>说说为什么面试题和 list 文章，面试题和 list 解决了什么问题？</p><p>为什么会有这么多人习惯给这些文章点赞，我觉得最主要的一个原因是<strong>缓解了读者的焦</strong>虑，第二个原因是仅仅是<strong>为了收藏</strong>。</p><p><strong>缓解了读者的焦虑</strong></p><p>对于面试，肯定是永恒的话题，总想着换个好公司，涨工资，但是自己又太菜，想着有没有什么捷径，想了想，刷面经吧，刷了就等于会了，会了就等于能进大公司了。这种心理就跟买课一样，买了就觉得会了，然后生怕错过什么技术，买了一大堆，结果每个课程就只看了前面的开篇就没下文了，你能说这些卖课的不对吗？是你自己不看，能怪别人么？</p><p>然后说道别人发面试题，就想分享给大家，毕竟面试题往往都是对于前端开发来说比较重要的东西，是可以给你不仅是面经方面的东西，而且对于刚入坑前端的来说，不知道应该学啥，什么东西重要，什么东西应该先学什么的一个方向。</p><p><strong>收藏</strong></p><p>list 愿意点赞的往往是想收藏，然后可能是设计的原因，不管是哪个平台都一样，把点赞这个功能做得特别的容易，而收藏就要繁琐或者说不那么让用户想去点。</p><p>然后给大家一个建议，收藏这功能真的比点赞好用，可以对文章进行分类，自己可以梳理你的知识体系，然后建好分类，然后再分类收藏文章，这比起你点赞了，然后后面想去看的时候发现太乱了，又不好找，就给你不看文章找了个借口，导致点赞了一大堆，最终有收获的并不多。</p><p>我觉得在收藏这方便来说，个人觉得思否做得比掘金好(思否小姐姐是不是要给我广告费了)。</p><p><strong>所谓的干货</strong></p><p><strong>干货</strong>这个词我的理解就是有价值，如果这篇文章对你有价值，那么就是干货，没有价值，你可能就会觉得是水文。</p><p>注意，我这里说的是对你有价值，才算是干货。因为一篇简单的文章，对于新手来说有价值，那么他觉得这篇文章就是干货，对于一个老手来说，几年前都会的东西，那么他可能就会觉得是水文。</p><p>所以，上面说到什么「浅谈」、「说说」都是没有干货的理论，根本是个人主观臆断，这些文章对于刚入门的同学来说，可能是带来了非常大的帮助。</p><p>注意，绝大部分人是知识的搬运工，传播者，而不是创造者，官网文档上有的东西，如果能用一种一部分人觉得通俗易懂的方式写出来也是有价值的，官方文章是普适的，但并不一定是最好的教程，而一些作者就是知识的传播者，可以理解为老师，把一些枯燥，正统的知识，通过一种针对特定人群的方式传达出来，然后学生能理解，那么就是一个好老师，好作者。这就跟你学牛顿三大定律不是去看他发布的论文一样。</p><p><strong>总结</strong></p><p>所以我觉得现在这样的面试题和 list 文章，并没有什么问题，有问题的是读者对于『点赞』可能理解得不够深刻以及没有正确的认识面试和 list 文章的价值。然后就是没有绝对的干货，一篇文章对于不同水平的人所得到的的价值是不一样的，当然我也更喜欢稀缺资源的文章，这样能给整个社区带来更大的价值。</p><blockquote><p>声明下，我基本上是不写面试题和 list 文章的，所以我并不是为了自己写了这种文章而强词夺理。</p></blockquote><h2 id="给掘金说的"><a href="#给掘金说的" class="headerlink" title="给掘金说的"></a>给掘金说的</h2><p>再给掘金提一点建议把，想让作者给你们带来更好的内容，这确实是双赢的局面。</p><p>你们对于用户的非常的关心，这是应该的， 但是，是不是应该给作者一些关心呢？</p><p>比如，对于评论的控制功能，对于投诉的功能，我看到有些作者写个文章被喷得很惨，心里真的很为她们难过，但是作为作者，一个删除评论的功能都没有，或者说不允许评论。</p><p>一些负面的评论真的会给作者带来很大影响，其实作为作者非常的希望大家友善的提出自己的建议，当有人说一些恶意伤人的话，有时候会影响到他上班工作的心情，甚至退出掘金平台，我已经看到过好几个优秀的作者，由于受不了掘金用户的评论，然后退出了掘金。</p><p>或者说除了赞，有一个踩的功能也挺好的，这样读者知道这篇文章写得不够好，然后自己会去改进，而不是一些「键盘侠」进行语言暴力。</p><p>作者和读者是一个双向的关系，维持双方的利益才是正确之道，不是作者把文章写的好就能改善整个社区的，反思的不仅仅是作者，用户也应该反省一下。</p><p>我见过最好的社区就是 Emacs 的社区，社区文章质量很高，社区里面基本上不会出现「娱乐化」，也没看到过「键盘侠」，也许是 Emcas 太难学了，导致过滤了很多不符合 Emcas 社区理念的人吧，所以 Emcas 社区不管是作者，还是仅仅是个社区的读者，都有非常高的素质，以至于社区环境很好。<strong>再次强调，不是作者写得好，社区就能搞得好的，好的作者也可能被读者被迫离开社区。</strong></p><p>由于我做公众号，也在掘金写文章，所以和很多的作者进行交流过，非常多的作者会以给读者带来了帮助而激发自己写更好、更多的文章，我觉得用户给到作者的不是<strong>意见</strong>而应该是<strong>建议</strong>。这样双方处于和谐、和平的状态，才更有利于社区的发展。</p><h2 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h2><p>说说这位掘金用户说的东西，我相信你的初心是让社区变得更好，您说的也没有毛病，我也很赞同。</p><p>不过您是站在道德的制高点去要求作者，要有深度，要有独立思考能力，要有干货等等<strong>要求</strong>，但是您又没有给作者钱，他并没有义务按照每个人的要求来写文章。</p><p>这不就是白嫖要求还多的表现么。难道您说的这些要求，难道写文章的作者不知道吗，别人也许只想写下来做个笔记，好心随便分享给大家看一下。</p><p>这就跟朋友请你到他家吃饭，亲手做菜给你吃，然后你嫌弃这个咸了，那个淡了，这个不好吃，那个卖相太丑了，白吃白喝还要色香味俱全。</p><p>在掘金这个平台上，除了小册，没人有责任和义务把文章写得要满足所有的读者。如果小册写得不好，那确实应该要求作者改改，毕竟你花了钱，你就是『爸爸』，你就是顾客，顾客是上帝。</p><p>所以，我觉得现在社区不仅要控制文章的质量，还要控制社员的质量，比如像之前创建小号来喷京东小姐姐刘小夕，以及小生方勤的，这种文章就不应该出现在首页，这样会给作者带来了巨大的创伤。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新手学习 React 迷惑的点</title>
    <link href="/index.php/archives/257/"/>
    <url>/index.php/archives/257/</url>
    
    <content type="html"><![CDATA[<p>网上各种言论说 React 上手比 Vue 难，可能难就难不能深刻理解 JSX，或者对 ES6 的一些特性理解得不够深刻，导致觉得有些点难以理解，然后说 React 比较难上手，还反人类啥的，所以我打算写两篇文章来讲新手学习 React 的时候容易迷惑的点写出来，如果你还以其他的对于学习 React 很迷惑的点，可以在留言区里给我留言。</p><h2 id="为什么要引入-React"><a href="#为什么要引入-React" class="headerlink" title="为什么要引入 React"></a>为什么要引入 React</h2><p>在写 React 的时候，你可能会写类似这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...other code</span><br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>前端桃园<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>你肯定疑惑过，下面的代码都没有用到 React，为什么要引入 React 呢？</p><p>如果你把 <code>import React from ‘react’</code> 删掉，还会报下面这样的错误：</p><p><img src="http://imgs.taoweng.site/2019-09-01-150624.jpg" alt="7F6E506E-3025-401D-A492-3B501F8081C6"></p><p>那么究竟是哪里用到了这个 React，导致我们引入 React 会报错呢，不懂这个原因，那么就是 JSX 没有搞得太明白。</p><p>你可以讲上面的代码(忽略导入语句)放到<a href="https://www.babeljs.cn/repl">在线 babel</a> 里进行转化一下，发现 babel 会把上面的代码转化成:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...other code</span><br>  <span class="hljs-keyword">return</span> React.createElement(<span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;前端桃园&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>因为从本质上讲，JSX 只是为 <code>React.createElement(component, props, ...children)</code> 函数提供的语法糖。</p><h2 id="为什么要用-className-而不用-class"><a href="#为什么要用-className-而不用-class" class="headerlink" title="为什么要用 className 而不用 class"></a>为什么要用 className 而不用 class</h2><ol><li><p>React 一开始的理念是想与浏览器的 DOM API 保持一直而不是 HTML，因为 JSX 是 JS 的扩展，而不是用来代替 HTML 的，这样会和元素的创建更为接近。在元素上设置 <code>class</code> 需要使用 <code>className</code> 这个 API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&quot;div&quot;</span>)<br>element.className = <span class="hljs-string">&quot;hello&quot;</span> <br></code></pre></td></tr></table></figure></li><li><p>浏览器问题，ES5 之前，在对象中不能使用保留字。以下代码在 IE8 中将会抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = &#123;<br>  <span class="hljs-attr">attributes</span>: &#123;<br>    <span class="hljs-attr">class</span>: <span class="hljs-string">&quot;hello&quot;</span><br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure></li><li><p>解构问题，当你在解构属性的时候，如果分配一个 <code>class</code> 变量会出问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; <span class="hljs-class"><span class="hljs-keyword">class</span> &#125; </span>= &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125; <span class="hljs-comment">// Uncaught SyntaxError: Unexpected token &#125;</span><br><span class="hljs-keyword">const</span> &#123; className &#125; = &#123; <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125; <br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">class</span>: className &#125; = &#123; <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;foo&#x27;</span> &#125; <br></code></pre></td></tr></table></figure></li></ol><p>其他讨论可见：<a href="https://www.jackpu.com/you-qu-de-hua-ti-wei-shi-yao-jsxyong-classnameer-bu-shi-class/">有趣的话题，为什么jsx用className而不是class</a></p><h2 id="为什么属性要用小驼峰"><a href="#为什么属性要用小驼峰" class="headerlink" title="为什么属性要用小驼峰"></a>为什么属性要用小驼峰</h2><p>因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。</p><p>来自 <a href="https://zh-hans.reactjs.org/docs/introducing-jsx.html">JSX 简介</a></p><h2 id="为什么-constructor-里要调用-super-和传递-props"><a href="#为什么-constructor-里要调用-super-和传递-props" class="headerlink" title="为什么 constructor 里要调用 super 和传递 props"></a>为什么 constructor 里要调用 super 和传递 props</h2><p>这是官网的一段代码，具体见：<a href="http://react.html.cn/docs/state-and-lifecycle.html">状态(State) 和 生命周期</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而且有这么一段话，不仅让我们调用 <code>super</code> 还要把 <code>props</code> 传递进去，但是没有告诉我们为什么要这么做。<img src="http://imgs.taoweng.site/2019-09-01-150613.png" alt="image-20190901222456704"></p><p>不知道你有没有疑惑过为什么要调用 <code>super</code> 和传递 <code>props</code>，接下来我们来解开谜题吧。</p><p><strong>为什么要调用 super</strong></p><p>其实这不是 React 的限制，这是 JavaScript 的限制，在构造函数里如果要调用 this，那么提前就要调用 super，在 React 里，我们常常会在构造函数里初始化 state，<code>this.state = xxx</code> ，所以需要调用 super。</p><p><strong>为什么要传递 props</strong></p><p>你可能以为必须给 <code>super</code> 传入 <code>props</code>，否则 <code>React.Component</code> 就没法初始化 <code>this.props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.props = props;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不过，如果你不小心漏传了 <code>props</code>，直接调用了 <code>super()</code>，你仍然可以在 <code>render</code> 和其他方法中访问 <code>this.props</code>（不信的话可以试试嘛）。</p><p>为啥这样也行？因为<strong>React 会在构造函数被调用之后，会把 props 赋值给刚刚创建的实例对象：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> YourComponent(props);<br>instance.props = props;<br></code></pre></td></tr></table></figure><p><code>props</code> 不传也能用，是有原因的。</p><p>但这意味着你在使用 React 时，可以用 <code>super()</code> 代替 <code>super(props)</code> 了么？</p><p>那还是不行的，不然官网也不会建议你调用 props 了，虽然 React 会在构造函数运行之后，为 <code>this.props</code> 赋值，但在 <code>super()</code> 调用之后与构造函数结束之前， <code>this.props</code> 仍然是没法用的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Inside React</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.props = props;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Inside your code</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(); <span class="hljs-comment">//  忘了传入 props</span><br>    <span class="hljs-built_in">console</span>.log(props); <span class="hljs-comment">//  &#123;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.props); <span class="hljs-comment">//  undefined</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>要是构造函数中调用了某个访问 <code>props</code> 的方法，那这个 bug 就更难定位了。<strong>因此我强烈建议始终使用super(props)，即使这不是必须的：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props); <span class="hljs-comment">//  We passed props</span><br>    <span class="hljs-built_in">console</span>.log(props); <span class="hljs-comment">//  &#123;&#125;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.props); <span class="hljs-comment">//  &#123;&#125;</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码确保 <code>this.props</code> 始终是有值的。</p><p>如果你想避免以上的问题，你可以通过<a href="https://github.com/tc39/proposal-class-fields">class 属性提案</a> 来简化代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更详细的内容可见<a href="https://overreacted.io/why-do-we-write-super-props/">Dan 的博客</a></p><h2 id="为什么组件用大写开头"><a href="#为什么组件用大写开头" class="headerlink" title="为什么组件用大写开头"></a>为什么组件用大写开头</h2><p>前面以及说过了，JSX 是 <code>React.createElement(component, props, …children)</code> 提供的语法糖，component 的类型是：<code>string/ReactClass type</code>，我们具体看一下在什么情况下会用到 string 类型，什么情况下用到 ReactClass type 类型</p><ul><li>string 类型react会觉得他是一个原生dom节点</li><li>ReactClass type 类型 自定义组件</li></ul><p>例如（string）：在 jsx 中我们写一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs react">&lt;div&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>转换为js的时候就变成了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">React.createElement(<span class="hljs-string">&quot;div&quot;</span>, <span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure><p>例如（ReactClass type）：在jsx中我们写一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs react">function MyDiv() &#123;<br>    return (&lt;div&gt;&lt;div&gt;)<br>&#125;<br>&lt;MyDiv&gt;&lt;/MyDiv&gt;<br></code></pre></td></tr></table></figure><p>转换为js的时候就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs react">function MyDiv() &#123;<br>  return React.createElement(&quot;div&quot;, null);<br>&#125;<br><br>React.createElement(MyDiv, null);<br></code></pre></td></tr></table></figure><p>上边的例子中如果将MyDiv中的首字母小写，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs react">function myDiv() &#123;<br>    return (&lt;div&gt;&lt;div&gt;)<br>&#125;<br>&lt;myDiv&gt;&lt;/myDiv&gt;<br></code></pre></td></tr></table></figure><p>转换为 js 的时候就变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs react">function MyDiv() &#123;<br>  return React.createElement(&quot;div&quot;, null);<br>&#125;<br><br>React.createElement(&quot;myDiv&quot;, null);<br><br></code></pre></td></tr></table></figure><p>由于找不到 myDiv 这个 dom，所以就会报错。</p><h2 id="为什么调用方法要-bind-this"><a href="#为什么调用方法要-bind-this" class="headerlink" title="为什么调用方法要 bind this"></a>为什么调用方法要 bind this</h2><p><strong>前提知识：</strong>深刻的理解 JavaScript 中的 this</p><p>相信刚写 React 的时候，很多朋友可能会写类似这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现会报 <code>this</code> 是 <code>undefined</code> 的错，然后可能对事件处理比较疑惑，然后去看官网的<a href="https://zh-hans.reactjs.org/docs/handling-events.html">事件处理</a>有下面一段话：</p><blockquote><p>你必须谨慎对待 JSX 回调函数中的 <code>this</code>，在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a><code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p><p>这并不是 React 特有的行为；这其实与 <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/">JavaScript 函数工作原理</a>有关。通常情况下，如果你没有在方法后面添加 <code>()</code>，例如 <code>onClick=&#123;this.handleClick&#125;</code>，你应该为这个方法绑定 <code>this</code>。</p></blockquote><p>然后你看了官网的例子和建议之后，知道需要为事件处理函数绑定 <code>this</code>就能解决，想下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是可能你没有去思考过为什么需要 bind this？如果你不能理解的话，还是 js 的基础没有打好。</p><p><strong>React 是如何处理事件的？</strong></p><p>咱们先来了解一下 React 是如何处理事件的。</p><p>React 的事件是合成事件， 内部原理非常复杂，我这里只把关键性，可以用来解答这个问题的原理部分进行介绍即可(后面应该会写一篇 react 的事件原理，敬请期待)。</p><p>上篇文章已经说过，jsx 实际上是 <code>React.createElement(component, props, …children)</code> 函数提供的语法糖，那么这段 jsx 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleClick&#125;&gt;<br>    Click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure><p>会被转化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">React.createElement(<span class="hljs-string">&quot;button&quot;</span>, &#123;<br>     <span class="hljs-attr">onClick</span>: <span class="hljs-built_in">this</span>.handleClick<br>&#125;, <span class="hljs-string">&quot;Click me&quot;</span>)<br></code></pre></td></tr></table></figure><p>了解了上面的，然后简单的理解 react 如何处理事件的，React 在组件加载(<code>mount</code>)和更新(<code>update</code>)时，将事件通过 <code>addEventListener</code>  统一注册到 <code>document</code> 上，然后会有一个事件池存储了所有的事件，当事件触发的时候，通过 <code>dispatchEvent</code> 进行事件分发。</p><p>所以你可以简单的理解为，最终 <code>this.handleClick</code> 会作为一个回调函数调用。</p><p>理解了这个，然后再来看看回调函数为什么就会丢失 <code>this</code>。</p><p><strong>this 简单回顾</strong></p><blockquote><p>在函数内部，<code>this</code>的值取决于函数被调用的方式。</p></blockquote><p>如果你不能理解上面那句话，那么你可能需要停下来阅读文章，去查一下相关资料，否则你可能看不懂下面的，如果你懒的话，就看为你准备好的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">MDN</a> 吧。</p><p>通过上面对事件处理的介绍，来模拟一下在类组件的 render 函数中， 有点类似于做了这样的操作:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>sayThis () &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 这里的 `this` 指向谁？</span><br> &#125;<br><br> exec (cb) &#123;<br> cb();<br> &#125;<br><br>render () &#123;<br> <span class="hljs-built_in">this</span>.exec(<span class="hljs-built_in">this</span>.sayThis);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo();<br>foo.render(); <span class="hljs-comment">// 输出结果是什么？</span><br></code></pre></td></tr></table></figure><p>你会发现最终结果输出的是 <code>undefined</code>，如果你不理解为什么输出的是 <code>undefined</code>，那么还是上面说的，需要去深刻的理解 this 的原理。如果你能理解输出的是 <code>undefined</code>，那么我觉得你就可以理解为什么需要 bind this 了。</p><p>那么你可能会问：**为什么React没有自动的把 bind 集成到 render 方法中呢?**在 exec 调用回调的时候绑定进去，像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>sayThis () &#123;<br> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 这里的 `this` 指向谁？</span><br> &#125;<br><br> exec (cb) &#123;<br> cb().bind(<span class="hljs-built_in">this</span>);<br> &#125;<br><br>render () &#123;<br> <span class="hljs-built_in">this</span>.exec(<span class="hljs-built_in">this</span>.sayThis);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo();<br>foo.render(); <span class="hljs-comment">// 输出结果是什么？</span><br></code></pre></td></tr></table></figure><p><strong>因为 render 多次调用每次都要 bind 会影响性能，所以官方建议你自己在 constructor 中手动 bind 达到性能优化。</strong></p><h3 id="四种事件处理对比"><a href="#四种事件处理对比" class="headerlink" title="四种事件处理对比"></a>四种事件处理对比</h3><p>对于事件处理的写法也有好几种，咱们来进行对比一下：</p><p><strong>1. 直接 bind this 型</strong></p><p>就是像文章开始的那样，直接在事件那里 bind this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点</strong>：写起来顺手，一口气就能把这个逻辑写完，不用移动光标到其他地方。</p><p><strong>缺点</strong>：性能不太好，这种方式跟 react 内部帮你 bind 一样的，每次 render 都会进行 bind，而且如果有两个元素的事件处理函数式同一个，也还是要进行 bind，这样会多写点代码，而且进行两次 bind，性能不是太好。(其实这点性能往往不会是性能瓶颈的地方，如果你觉得顺手，这样写完全没问题)</p><p><strong>2. constuctor 手动 bind 型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constuctor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props)<br>    <span class="hljs-built_in">this</span>.handleClick = <span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>)<br>  &#125;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>相比于第一种性能更好，因为构造函数只执行一次，那么只会 bind 一次，而且如果有多个元素都需要调用这个函数，也不需要重复 bind，基本上解决了第一种的两个缺点。</p><p><strong>缺点：</strong>没有明显缺点，硬要说的话就是太丑了，然后不顺手(我觉得丑，你觉得不丑就这么写就行了)。</p><p><strong>3. 箭头函数型</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> this.handleClick(e)&#125;&gt;</span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>顺手，好看。</p><p><strong>缺点：</strong>每次 render 都会重复创建函数，性能会差一点。</p><p><strong>4. public class fields 型</strong></p><p>这种 <code>class fields </code>还处于实验阶段，据我所知目前还没有被纳入标准，具体可见<a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties">这里</a>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>好看，性能好。</p><p><strong>缺点：</strong>没有明显缺点，如果硬要说可能就是要多装一个 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-class-properties">babel 插件</a>来支持这种语法。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我平时用的就这四种写法，我这边从代码的美观性、性能以及是否顺手方便对各种写法做了简单的对比。其实每种方法在项目里用都是没什么问题的，性能方面基本上可以忽略，对于美观性和顺手比较主观，所以总体来说就是看大家的偏好咯，如果硬要推荐的话，我还是比较推荐第四种写法，美观而且不影响性能。</p><h2 id="为什么要-setState，而不是直接-this-state-xx-oo"><a href="#为什么要-setState，而不是直接-this-state-xx-oo" class="headerlink" title="为什么要 setState，而不是直接 this.state.xx = oo"></a>为什么要 setState，而不是直接 this.state.xx = oo</h2><p>这个问题是我们公司后端写 React 的时候提出的问题，为啥不能直接修改 state，要 setState 一下。我在想，从 vue 转到 React 可能也会有这种疑问，因为 vue 修改状态都是直接改的。</p><p>如果我们了解 setState 的原理的话，可能就能解答这个问题了，setState 做的事情不仅仅只是修改了 <code>this.state</code> 的值，另外最重要的是它会触发 React 的更新机制，会进行 diff ，然后将 patch 部分更新到真实 dom 里。</p><p>如果你直接 <code>this.state.xx == oo</code> 的话，state 的值确实会改，但是改了不会触发 UI 的更新，那就不是数据驱动了。</p><p>那为什么 Vue 直接修改 data 可以触发 UI 的更新呢？因为 Vue 在创建 UI 的时候会把这些 data 给收集起来，并且在这些 data 的访问器属性 setter 进行了重写，在这个重写的方法里会去触发 UI 的更新。如果你想更多的了解 vue 的原理，可以去购买染陌大佬的<a href="https://juejin.im/book/5a36661851882538e2259c0f">剖析 Vue.js 内部运行机制</a>。</p><blockquote><p>不明白访问器属性的可以看这篇文章：<a href="https://rainzhaojy.github.io/2015/js_object.html">深入理解JS里的对象</a></p></blockquote><h2 id="setState-是同步还是异步相关问题"><a href="#setState-是同步还是异步相关问题" class="headerlink" title="setState 是同步还是异步相关问题"></a>setState 是同步还是异步相关问题</h2><p><strong>1. setState 是同步还是异步？</strong></p><p>我的回答是执行过程代码同步的，<strong>只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”</strong>，所以<strong>表现出来</strong>有时是同步，有时是“异步”。</p><p><strong>2. 何时是同步，何时是异步呢？</strong></p><p>只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout/setInterval等原生 API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。</p><p><strong>3. 那为什么会出现异步的情况呢？</strong></p><p>为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。</p><p><strong>4. 那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？</strong></p><p>通过第二个参数 <code>setState(partialState, callback)</code> 中的 callback 拿到更新后的结果。</p><p>或者可以通过给 setState 传递函数来表现出同步的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">val</span>: newVal &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><strong>5. 那表现出异步的原理是怎么样的呢？</strong></p><p>直接讲源码肯定篇幅不够，可以看这篇文章：<a href="https://juejin.im/post/5b45c57c51882519790c7441#heading-0">你真的理解setState吗？</a>。</p><p>我这里还是用最简单的语言让你理解：在 React 的 setState 函数实现中，会根据 isBatchingUpdates(默认是 false) 变量判断是否直接更新 this.state 还是放到队列中稍后更新。然后有一个 batchedUpdate 函数，可以修改 isBatchingUpdates 为 true，当 React 调用事件处理函数之前，或者生命周期函数之前就会调用 batchedUpdate 函数，这样的话，setState 就不会同步更新 this.state，而是放到更新队列里面后续更新。</p><p>这样你就可以理解为什么原生事件和 setTimeout/setinterval 里面调用 this.state 会同步更新了吧，因为通过这些函数调用的 React 没办法去调用 batchedUpdate 函数将 isBatchingUpdates 设置为 true，那么这个时候 setState 的时候默认就是 false，那么就会同步更新。</p><p><strong>最后</strong></p><p>setState 是 React 非常重要的一个方法，值得大家好好去研究一下他的原理。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>上一篇发出之后，有很多小伙伴留言说想看关于 hooks 相关的问题，毕竟 hooks 出来没多久，有很多疑问很正常，下一篇估计就专门写 hooks 相关的吧。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://www.cnblogs.com/eret9616/p/9944224.html">React 中为什么要 bind this</a></li><li>《React 状态管理与同构实践》</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级程序员与初级程序员差别在哪里？</title>
    <link href="/index.php/archives/258/"/>
    <url>/index.php/archives/258/</url>
    
    <content type="html"><![CDATA[<p>之前在公众号里有个读者给我留言：</p><blockquote><p>请教个问题，公司高职级和初中级，都是写业务代码，那么高职级的价值在哪里呢？</p></blockquote><p>由于公众号回复留言的限制，当时我就简单的回复了如下的几个点：</p><ul><li>  初级多在写代码，高级多在设计代码；</li><li>  初级多在解决一个问题，高级多在解决一类问题；</li><li>  初级多在考虑技术问题，高级还要参与业务上的需求；</li><li>  初级工程师只管接需求，导致自己忙不过来，高级工程师会砍需求， 用自己得经验告诉产品这个需求不需要，告诉设计师这个交互没必要；</li><li>  初级工程师可能做完一个项目就完了，高级工程师可能会封装几个组件，整理一个脚手架出来。</li></ul><p>还有很多很多，初级工程师和高级工程师差距不仅仅是代码质量上，而且其他能力上，解决问题的能力，抽象问题的能力！</p><p>今天有时间，想详细的跟大家谈谈我所遇到的、见到的厉害的程序员，同样是写业务代码，为什么会比初级程序员拿的工资高？</p><h2 id="初级多在写代码，高级多在设计代码"><a href="#初级多在写代码，高级多在设计代码" class="headerlink" title="初级多在写代码，高级多在设计代码"></a>初级多在写代码，高级多在设计代码</h2><p>一般人可能拿到需求，就开始写代码了，写着写着由于页面功能越来越多，感觉代码越来越复杂，自己都会觉得难以维护了。</p><p>我拿我自己举个例子，之前有一次我写完一个页面之后，然后给另外一个同事(可以理解为高级程序员)让他帮我 Review 代码，看到我的代码之后就觉得这个写得不对呀，怎么会这么去<strong>设计</strong>呢？</p><p>然后他给我理了下整个页面应该如何去设计，一个页面分为哪些块，有哪些事件，每个事件应该 <code>dispatch</code> 哪些 <code>action</code>，然后整个模块有哪些数据放在 <code>store</code> 里，哪些模块放在 <code>state</code> 里，当时反正听他理完之后，感觉自己写的代码真的很垃圾，然后花了两天时间把上周写的代码重写了一边。</p><blockquote><p>注意，这里是重写，不是重构，重构是对软件内部结构的一种调转，目的是不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。那么如果保证不改变软件可观察行为呢？就需要写测试用例，保证测试用例能跑通的情况下进行重新构造代码才是重构的第一步，没有测试用例的重构就是耍流氓。</p></blockquote><p><strong>那么如何提高设计代码的能力呢？</strong></p><p>我觉得有一个方法对于提高设计代码的能力非常有帮助，那就是采用 TDD(测试驱动开发)。</p><blockquote><p>TDD 的原理是在开发功能代码之前，先编写单元测试用例代码，测试代码确定需要编写什么产品代码。 –来源百度百科</p></blockquote><p>为什么 TDD 会提高设计代码的能力呢？可以看到 TDD 的原理是要在写代码之前就要写测试用例，在写测试用例的时候你必然得去思考你的每个函数，每个模块，每个组件应该如何去设计才能使得易于测试，往往易于测试的代码都比较好维护。</p><p>这就可以达到在写代码之前先去设计代码，然后才写代码，也就是先思考，后行动。</p><blockquote><p>我只是说 TDD 可以提高设计代码的能力，并没有说我就特别提倡 TDD，说 TDD 很麻烦，难以实施的人就不要跟我讨论了。</p></blockquote><h2 id="初级多在考虑技术问题，高级还要思考业务上的需求"><a href="#初级多在考虑技术问题，高级还要思考业务上的需求" class="headerlink" title="初级多在考虑技术问题，高级还要思考业务上的需求"></a>初级多在考虑技术问题，高级还要思考业务上的需求</h2><p>我们要知道，<strong>技术是为业务服务的，没有业务谈技术的好坏都是瞎扯淡！</strong></p><p>常常可以看到很多实习生，或者刚来的应届生会吐槽以前的老代码用的框架老，用的技术旧，然后就去改成新的，自己觉得牛逼的，然后没有多个环境测试，发上线就挂了，这种例子很多很多，别说我们公司，就连我们组都出现过好几次这样的情况了。</p><p>这种就是只考虑技术问题的，而没有去考虑为什么以前前人要这么写，前人没有用这些东西，难道仅仅是因为那个时候没有新东西，或者说认为前人比你差。</p><p>很可能就是他们考虑到了业务上的需求，比如要兼容 IE、或者比如考虑到了有很多用户用 iOS，Safari 不支持 webp ，或者比如考虑到很多用户是低端机，性能不好，不能用一些新特性等等问题。</p><p>对于老板来说，他根本不管你用什么新技术，新特性，也许你用了新特性确实让代码更简洁了，但是，但是，但是，发到线上挂了，那么你写的东西就是垃圾，连最基础的稳定性都保证不了，更别说流畅性，高并发。</p><h2 id="初级工程师只管接需求，高级工程师会砍需求"><a href="#初级工程师只管接需求，高级工程师会砍需求" class="headerlink" title="初级工程师只管接需求，高级工程师会砍需求"></a>初级工程师只管接需求，高级工程师会砍需求</h2><p>经常看到很多初级工程师就是，不管产品、运营甚至后端提出一些需求，他也很友好，只要是需求，他都接，然后整天忙忙碌碌，还经常加班，但是实际上，很多需求做了没有什么价值，也许还有些是重复工作，还把自己搞得很辛苦，这种情况真的很多很多。</p><p>然后还有一种情况是有一个产品需求来了，然后 balabala 一顿需求讨论之后，产品给出一个期限，初级工程师满打满算，可能能完成，然后就说能行，结果要么对自己能力估算错误，要么很多突发情况，然后不能按时上线。</p><p>而高级工程师基本上不会出现不能按时上线的情况，我思考了几点原因：</p><ol><li> 会给自己留 buffer，来避免突发情况导致时间的耽搁。</li><li> 在需求分析的时候会思考每个需求是否有必要，如果有些需求觉得没必要，会和产品讨论，拿出<strong>充分的理由</strong>将需求砍掉。如果都有必要，然后时间又不太够，会去和产品谈是否能使交互简单一下，一期先出个什么样子，下一期再做完整一点。</li><li> 对需求的评估以及自己能力的评估更准确。</li></ol><p>这里我想要表达，不是所有的需求都是有必要的，不要每个需求都去接。</p><p><strong>那么如果来判断一个需求是否应该接呢？</strong></p><p>我觉得主要是去思考他背后的价值，为什么要做这个东西，做了能达到什么样的效果，如果产品说不出来价值，或者说产生的价值与你花费的时间不匹配，那么这个需求就是有待商讨的。</p><h2 id="初级多在解决一个问题，高级多在解决一类问题"><a href="#初级多在解决一个问题，高级多在解决一类问题" class="headerlink" title="初级多在解决一个问题，高级多在解决一类问题"></a>初级多在解决一个问题，高级多在解决一类问题</h2><p>很多初级工程师可能昨晚一个项目就完了，还觉得很 OK 呀，然后也把在项目中的问题一个一个的解决了，按时按量的完成了任务。</p><p>对，这就是初级工程师的标准，能完成一个项目。</p><p>那么对于高级工程师除了完成项目还会做什么呢？</p><p>也许会封装几个公用组件发到 npm 上大家都可以用。</p><p>也许会整理一个脚手架出来大家用，比如以前公司没有用 TS，那么用 TS 写完项目之后，踩了很多坑，你就可以整理出一个脚手架，然后把踩得坑记录下来，方便后面想用 TS 的人用。</p><p>也许发现前端工程师还原 UI 搞是一件枯燥无味，而且没有技术含量的事儿，我司有个大佬就写了一个 UI2Code 的工具，可以将 Sketch 文件转化为 html 代码。</p><p>也许高级工程师发现一上线一个功能，小程序和 H5 都要写一套一模一样的，然后我司大佬就写了一个可以将 vue 代码转换为小程序的框架，一套 vue 代码，h5 和小程序都能用。</p><p>这些都是我身边的例子，可以看到高级工程师经常解决的不是一个问题，而是解决一类通用的问题，然后给出解决方案，并且得以实施，从来不会认为吧项目做完了就完了，没有一点产出，也许你做这个项目是对自己太大的帮助，成长的。</p><h2 id="初级程序员经常犯的错误集锦"><a href="#初级程序员经常犯的错误集锦" class="headerlink" title="初级程序员经常犯的错误集锦"></a>初级程序员经常犯的错误集锦</h2><p>然后我在知乎上看到了一个初级程序员经常犯的错误集锦，我觉得非常大家都可以看看，自己有没有这些毛病。</p><p>1 命名不规范</p><p>2 日志不规范</p><p>3 拒绝写接口和假数据</p><p>4 不写单元测试</p><p>5 盲目集成</p><p>6 逻辑不清</p><p>7 不做方案</p><p>8 不关注性能</p><p>9 害怕重构</p><p>10 做出来就好，不考虑优雅的方案</p><p>11 不考虑未来需求的变化</p><p>12 遇到问题的时候不会试错</p><p>13 不会写伪代码</p><p>14 不做数据量的预估</p><p>15 提交代码不规范</p><p>16 不喜欢打Tag</p><p>17 不遵守发布流程</p><p>18 不知道Bug修复的优先级</p><p>19 总喜欢手动修改线上代码</p><p>20 不做数据备份</p><p>21 不做自测</p><p>22 不尽力模仿真实数据，测试数据很随意</p><p>23 不抽取公共代码</p><p>24 不认真听需求讲解</p><p>25 不看验收标准</p><p>26 不主动推进项目进度</p><p>27 遇到难题不主动反馈</p><blockquote><p>作者：暗灭链接：<a href="https://www.zhihu.com/question/33578621/answer/451931102"></a><a href="https://www.zhihu.com/question/33578621/answer/451931102">https://www.zhihu.com/question/33578621/answer/451931102</a></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>初级程序员主要是体现在目光短浅，缺乏思考，做完东西没有成果，不积极主动。</p><p>而高级程序员不仅仅是代码写得好，写得快，确实思考得更长远，做的东西更有用。</p><p>我列举我身边所遇到的高级程序员所做的事，我觉得更有说服力，不是空谈大道理，都是我从身边的大佬们身上学到的，希望能给刚入职场，或者感觉自己是个初级程序员的程序员们一些警惕。</p><p>当然，上面所说的高级工程师所拥有的优点和初级工程师的缺点，都不是所有高级工程师都会有所有的这些优点，也不是所有的初级工程师都具有这些缺点，这是没办法进行定量的。</p><p>你们身边还遇到什么高级工程师的特点，或者初级工程师的缺点，欢迎在评论区里面留言。</p><blockquote><p>最后欢迎大家关注我的公众号「前端桃园」</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep In React 之详谈 React 16 Diff 策略(二)</title>
    <link href="/index.php/archives/261/"/>
    <url>/index.php/archives/261/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章首发于<a href="http://www.taoweng.site/">个人博客</a></p></blockquote><p>这是我 Deep In React 系列的第二篇文章，如果还没有读过的强烈建议你先读第一篇：<a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A"><strong>详谈 React Fiber 架构(1)</strong></a>。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我相信在看这篇文章的读者一般都已经了解过 React 16 以前的 Diff 算法了，这个算法也算是 React 跨时代或者说最有影响力的一点了，使 React 在保持了可维护性的基础上性能大大的提高，但 Diff 过程不仅不是免费的，而且对性能影响很大，有时候更新页面的时候往往 Diff 所花的时间 js 运行时间比 Rendering 和 Painting 花费更多的时间，所以我一直传达的观念是 React 或者说框架的意义是<strong>为了提高代码的可维护性</strong>，而<strong>不是为了提高性能</strong>的，现在所做的提升性能的操作，只是在可维护性的基础上对性能的优化。具体可以参考我公众号以前发的这两篇文章：</p><ul><li><p><a href="https://mp.weixin.qq.com/s/XR3-3MNCYY2pg6yVwVQohQ">别再说虚拟 DOM 快了，要被打脸的</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/cz5DBpqFiadL4IQofiWY3A">深入理解虚拟 DOM，它真的不快</a></p></li></ul><blockquote><p>如果你对标题不满意，请把文章看完，至少也得把文章最后的结论好好看下</p></blockquote><p>在上一篇将 React Fiber 架构中，已经说到过，React 现在将整体的数据结构从树改为了链表结构。所以相应的 Diff 算法也得改变，以为以前的 Diff 算法就是基于树的。</p><p>老的 Diff 算法提出了三个策略来保证整体界面构建的性能，具体是：</p><ol><li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li><li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li></ol><p>基于以上三个前提策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化。</p><p>具体老的算法可以见这篇文章：<a href="https://zhuanlan.zhihu.com/p/20346379">React 源码剖析系列 － 不可思议的 react diff</a></p><p>说实话，老的 Diff 算法还是挺复杂的，你仅仅看上面这篇文章估计一时半会都不能理解，更别说看源码了。对于 React 16 的 Diff 算法(我觉得都不能把它称作算法，最多叫个 Diff 策略)其实还是蛮简单的，React 16 是整个调度流程感觉比较难，我在前面将 Fiber 的文章已经简单的梳理过了，后面也会慢慢的逐个攻破。</p><p>接下来就开始正式的讲解 React 16 的 Diff 策略吧！</p><h2 id="Diff-简介"><a href="#Diff-简介" class="headerlink" title="Diff 简介"></a>Diff 简介</h2><p><strong>做 Diff 的目的就是为了复用节点。</strong></p><p>链表的每一个节点是 Fiber，而不是在 16 之前的虚拟DOM 节点。</p><blockquote><p>我这里说的虚拟 DOM 节点是指 React.createElement 方法所产生的节点。虚拟 DOM tree 只维护了组件状态以及组件与 DOM 树的关系，Fiber Node 承载的东西比 虚拟 DOM 节点多很多。</p></blockquote><p>Diff 就是新旧节点的对比，在<a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A">上一篇</a>中也说道了，这里面的 Diff 主要是构建 currentInWorkProgress 的过程，同时得到 Effect List，给下一个阶段 commit 做准备。</p><p>React16 的 diff 策略采用从链表头部开始比较的算法，是<strong>层次遍历</strong>，算法是建立在一个节点的插入、删除、移动等操作都是在节点树的<strong>同一层级</strong>中进行的。</p><p>对于 Diff， 新老节点的对比，我们以新节点为标准，然后来构建整个 currentInWorkProgress，对于新的 children 会有四种情况。</p><ul><li>TextNode(包含字符串和数字)</li><li>单个 React Element(通过该节点是否有 $$typeof 区分)</li><li>数组</li><li>可迭代的 children，跟数组的处理方式差不多</li></ul><p>那么我们就来一步一步的看这四种类型是如何进行 diff 的。</p><h2 id="前置知识介绍"><a href="#前置知识介绍" class="headerlink" title="前置知识介绍"></a>前置知识介绍</h2><p> 这篇文章主要是从 React 的源码的逻辑出发介绍的，所以介绍之前了解下只怎么进入到这个 diff 函数的，react 的 diff 算法是从 <code>reconcileChildren</code> 开始的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildren</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  current: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  workInProgress: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  nextChildren: any,</span></span><br><span class="hljs-params"><span class="hljs-function">  renderExpirationTime: ExpirationTime,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (current === <span class="hljs-literal">null</span>) &#123;<br>    workInProgress.child = mountChildFibers(<br>      workInProgress,<br>      <span class="hljs-literal">null</span>,<br>      nextChildren,<br>      renderExpirationTime,<br>    );<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    workInProgress.child = reconcileChildFibers(<br>      workInProgress,<br>      current.child,<br>      nextChildren,<br>      renderExpirationTime,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>reconcileChildren</code> 只是一个入口函数，如果首次渲染，current 空 null，就通过 <code>mountChildFibers</code> 创建子节点的 Fiber 实例。如果不是首次渲染，就调用 <code>reconcileChildFibers</code>去做 diff，然后得出 effect list。</p><p>接下来再看看 mountChildFibers 和 reconcileChildFibers 有什么区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mountChildFibers = ChildReconciler(<span class="hljs-literal">false</span>);<br><br></code></pre></td></tr></table></figure><p>他们都是通过 <code>ChildReconciler</code> 函数来的，只是传递的参数不同而已。这个参数叫<code>shouldTrackSideEffects</code>，他的作用是判断是否要增加一些<code>effectTag</code>，主要是用来优化初次渲染的，因为初次渲染没有更新操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reconcileChildFibers</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  returnFiber: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function">  currentFirstChild: Fiber | <span class="hljs-literal">null</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  newChild: any,</span></span><br><span class="hljs-params"><span class="hljs-function">  expirationTime: ExpirationTime,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Fiber</span> | <span class="hljs-title">null</span> </span>&#123;<br>  <span class="hljs-comment">// 主要的 Diff 逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>reconcileChildFibers</code> 就是 Diff 部分的主体代码，这个函数超级长，是一个包装函数，下面所有的 diff 代码都在这里面，详细的源码注释可以见<a href="https://github.com/crazylxr/deep-in-react/blob/master/analysis/06-rencocilerChildren.md">这里</a>。</p><p><strong>参数介绍</strong></p><ul><li><code>returnFiber</code> 是即将 Diff 的这层的父节点。</li><li><code>currentFirstChild</code>是当前层的第一个 Fiber 节点。</li><li><code>newChild</code> 是即将更新的 vdom 节点(可能是 TextNode、可能是 ReactElement，可能是数组)，不是 Fiber 节点</li><li><code>expirationTime</code> 是过期时间，这个参数是跟调度有关系的，本系列还没讲解，当然跟 Diff 也没有关系。</li></ul><blockquote><p>再次提醒，reconcileChildFibers 是 reconcile(diff) 的一层。</p></blockquote><p>前置知识介绍完毕，就开始详细介绍每一种节点是如何进行 Diff 的。</p><h2 id="Diff-TextNode"><a href="#Diff-TextNode" class="headerlink" title="Diff TextNode"></a>Diff TextNode</h2><p>首先看 TextNode，因为它是最简单的，担心直接看到难的，然后就打击你的信心。</p><p>看下面两个小 demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// demo1：当前 ui 对应的节点的 jsx</span><br><span class="hljs-keyword">return</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  // ...</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">xxx</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">xxx</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">xxx</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  //...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br><br><span class="hljs-comment">// demo2：更新成功后的节点对应的 jsx</span><br><br><span class="hljs-keyword">return</span> (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  // ...</span><br><span class="xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  前端桃园</span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">  //...</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>)<br><br></code></pre></td></tr></table></figure><p>对应的单链表结构图：</p><p><img src="http://imgs.taoweng.site/2019-07-28-134126.png" alt="image-20190714223931338"></p><p>对于 diff TextNode 会有两种情况。</p><ol><li>currentFirstNode 是 TextNode</li><li>currentFirstNode 不是 TextNode</li></ol><blockquote><p>currentFirstNode 是当前该层的第一个节点，reconcileChildFibers 传进来的参数。</p></blockquote><p><strong>为什么要分两种情况呢？</strong>原因就是为了复用节点</p><p><strong>第一种情况</strong>。xxx 是一个 TextNode，那么就代表这这个节点可以复用，有复用的节点，对性能优化很有帮助。既然新的 child 只有一个 TextNode，那么复用节点之后，就把剩下的 aaa 节点就可以删掉了，那么 div 的 child 就可以添加到 workInProgress 中去了。</p><p>源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (currentFirstChild !== <span class="hljs-literal">null</span> &amp;&amp; currentFirstChild.tag === HostText) &#123;<br>      <span class="hljs-comment">// We already have an existing node so let&#x27;s just update it and delete</span><br>      <span class="hljs-comment">// the rest.</span><br>      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);<br>      <span class="hljs-keyword">const</span> existing = useFiber(currentFirstChild, textContent, expirationTime);<br>      existing.return = returnFiber;<br>      <span class="hljs-keyword">return</span> existing;<br>&#125;<br></code></pre></td></tr></table></figure><p>在源码里 <code>useFiber</code> 就是复用节点的方法，<code>deleteRemainingChildren</code> 就是删除剩余节点的方法，这里是从 <code>currentFirstChild.sibling</code> 开始删除的。</p><p><strong>第二种情况。</strong>xxx 不是一个 TextNode，那么就代表这个节点不能复用，所以就从 <code>currentFirstChild</code>开始删掉剩余的节点，对应到上面的图中就是删除掉 xxx 节点和 aaa 节点。</p><p>对于源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">deleteRemainingChildren(returnFiber, currentFirstChild);<br><span class="hljs-keyword">const</span> created = createFiberFromText(<br>    textContent,<br>    returnFiber.mode,<br>    expirationTime,<br>);<br>created.return = returnFiber;<br></code></pre></td></tr></table></figure><p>其中 <code>createFiberFromText</code> 就是根据 <code>textContent</code> 来创建节点的方法。</p><blockquote><p>注意：删除节点不会真的从链表里面把节点删除，只是打一个 delete 的 tag，当 commit 的时候才会真正的去删除。</p></blockquote><h2 id="Diff-React-Element"><a href="#Diff-React-Element" class="headerlink" title="Diff React Element"></a>Diff React Element</h2><p>有了上面 TextNode 的 Diff 经验，那么来理解 React Element 的 Diff 就比较简单了，因为他们的思路是一致的：先找有没有可以复用的节点，如果没有就另外创建一个。</p><p>那么就有一个问题，<strong>如何判断这个节点是否可以复用呢？</strong></p><p>有两个点：1. key 相同。 2. 节点的类型相同。</p><p>如果以上两点相同，就代表这个节点只是变化了内容，不需要创建新的节点，可以复用的。</p><p>对应的源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (child.key === key) &#123;<br>  <span class="hljs-keyword">if</span> (<br>    child.tag === Fragment<br>    ? element.type === REACT_FRAGMENT_TYPE<br>    : child.elementType === element.type<br>  ) &#123;<br>    <span class="hljs-comment">// 为什么要删除老的节点的兄弟节点？</span><br>    <span class="hljs-comment">// 因为当前节点是只有一个节点，而老的如果是有兄弟节点是要删除的，是多于的。删掉了之后就可以复用老的节点了</span><br>    deleteRemainingChildren(returnFiber, child.sibling);<br>    <span class="hljs-comment">// 复用当前节点</span><br>    <span class="hljs-keyword">const</span> existing = useFiber(<br>      child,<br>      element.type === REACT_FRAGMENT_TYPE<br>      ? element.props.children<br>      : element.props,<br>      expirationTime,<br>    );<br>    existing.ref = coerceRef(returnFiber, child, element);<br>    existing.return = returnFiber;<br>    <span class="hljs-keyword">return</span> existing;<br>&#125;<br></code></pre></td></tr></table></figure><p>相信这些代码都很好理解了，除了判断条件跟前面 TextNode 的判断条件不一样，其余的基本都一样，只是 React Element 多了一个跟新 ref 的过程。</p><p>同样，如果节点的类型不相同，就将节点从当前节点开始把剩余的都删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">deleteRemainingChildren(returnFiber, child);<br></code></pre></td></tr></table></figure><p>到这里，可能你们就会觉得接下来应该就是讲解当没有可以复用的节点的时候是如果创建节点的。</p><p>不过可惜你们猜错了。因为 Facebook 的工程师很厉害，另外还做了一个工作来优化，来找到复用的节点。</p><p>我们现在来看这种情况：</p><p><img src="http://imgs.taoweng.site/2019-07-28-134319.jpg" alt="image-20190714232052778"></p><p>这种情况就是有可能更新的时候删除了一个节点，但是另外的节点还留着。</p><p>那么在对比 xxx 节点和 AAA 节点的时候，它们的节点类型是不一样，按照我们上面的逻辑，还是应该把 xxx 和 AAA 节点删除，然后创建一个 AAA 节点。</p><p>但是你看，明明 xxx 的 slibling 有一个 AAA 节点可以复用，但是被删了，多浪费呀。所以还有另外有一个策略来找 xxx 的所有兄弟节点中有没有可以复用的节点。</p><p>这种策略就是从 div 下面的所有子节点去找有没有可以复用的节点，而不是像 TextNode 一样，只是找第一个 child 是否可以复用，如果当前节点的 key 不同，就代表肯定不是同一个节点，所以把当前节点删除，然后再去找当前节点的兄弟节点，直到找到 key 相同，并且节点的类型相同，否则就删除所有的子节点。</p><blockquote><p>你有木有这样的问题：为什么 TextNode 不采用这样的循环策略来找可以复用的节点呢？这个问题留给你思考，欢迎在评论区留下你的答案。</p></blockquote><p>对应的源码逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 找到 key 相同的节点，就会复用当前节点</span><br><span class="hljs-keyword">while</span> (child !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-keyword">if</span> (child.key === key) &#123;<br>    <span class="hljs-keyword">if</span> (<br>      child.tag === Fragment<br>      ? element.type === REACT_FRAGMENT_TYPE<br>      : child.elementType === element.type<br>    ) &#123;<br>      <span class="hljs-comment">// 复用节点逻辑，省略该部分代码，和上面复用节点的代码相同</span><br>      <span class="hljs-comment">// code ...</span><br>      <span class="hljs-keyword">return</span> existing;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      deleteRemainingChildren(returnFiber, child);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果没有可以复用的节点，就把这个节点删除</span><br>    deleteChild(returnFiber, child);<br>  &#125;<br>  child = child.sibling;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这段代码我们需要注意的是，当 key 相同，React 会认为是同一个节点，所以当 key 相同，节点类型不同的时候，React 会认为你已经把这个节点重新覆盖了，所以就不会再去找剩余的节点是否可以复用。只有在 key 不同的时候，才会去找兄弟节点是否可以复用。</p><p>接下来才是我们前面说的，如果没有找到可以复用的节点，然后就重新创建节点，源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前面的循环已经把该删除的已经删除了，接下来就开始创建新的节点了</span><br><span class="hljs-keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;<br>  <span class="hljs-keyword">const</span> created = createFiberFromFragment(<br>    element.props.children,<br>    returnFiber.mode,<br>    expirationTime,<br>    element.key,<br>  );<br>  created.return = returnFiber;<br>  <span class="hljs-keyword">return</span> created;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">const</span> created = createFiberFromElement(<br>    element,<br>    returnFiber.mode,<br>    expirationTime,<br>  );<br>  created.ref = coerceRef(returnFiber, currentFirstChild, element);<br>  created.return = returnFiber;<br>  <span class="hljs-keyword">return</span> created;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Fragment 节点和一般的 Element 节点创建的方式不同，因为 Fragment 本来就是一个无意义的节点，他真正需要创建 Fiber 的是它的 children，而不是它自己，所以 <code>createFiberFromFragment</code> 传递的不是 <code>element </code>，而是 <code>element.props.children</code>。</p><h2 id="Diff-Array"><a href="#Diff-Array" class="headerlink" title="Diff Array"></a>Diff Array</h2><p>Diff Array 算是 Diff 中最难的一部分了，比较的复杂，因为做了很多的优化，不过请你放心，认真看完我的讲解，最难的也会很容易理解，废话不多说，开始吧！</p><p>因为 Fiber 树是单链表结构，没有子节点数组这样的数据结构，也就没有可以供两端同时比较的尾部游标。所以React的这个算法是一个简化的两端比较法，只从头部开始比较。</p><p>前面已经说了，Diff 的目的就是为了复用，对于 Array 就不能像之前的节点那样，仅仅对比一下元素的 key 或者 元素类型就行，因为数组里面是好多个元素。你可以在头脑里思考两分钟如何进行复用节点，再看 React 是怎么做的，然后对比一下孰优孰劣。</p><h3 id="1-相同位置-index-进行比较"><a href="#1-相同位置-index-进行比较" class="headerlink" title="1. 相同位置(index)进行比较"></a>1. 相同位置(index)进行比较</h3><p>相同位置进行对比，这个是比较容易想到的一种方式，还是举个例子加深一下印象。</p><p><img src="http://imgs.taoweng.site/2019-07-28-134317.jpg" alt="image-20190721212259855"></p><p>这已经是一个非常简单的例子了，div 的 child 是一个数组，有 AAA、BBB 然后还有其他的兄弟节点，在做 diff 的时候就可以从新旧的数组中按照索引一一对比，如果可以复用，就把这个节点从老的链表里面删除，不能复用的话再进行其他的复用策略。</p><p>那如果判断节点是否可以复用呢？有了前面的 ReactElement 和 TextNode 复用的经验，这个也类似，因为是一一对比嘛，相当于是一个节点一个节点的对比。</p><p>不过对于 newChild 可能会有很多种类型，简单的看下源码是如何进行判断的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> key = oldFiber !== <span class="hljs-literal">null</span> ? oldFiber.key : <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>前面的经验可得，判断是否可以复用，常常会根据 key 是否相同来决定，所以首先获取了老节点的 key 是否存在。如果不存在老节点很可能是 TextNode 或者是 Fragment。</p><p>接下来再看 newChild 为不同类型的时候是如何进行处理的。</p><p><strong>当 newChild 是 TextNode 的时候</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;string&#x27;</span> || <span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>  <span class="hljs-comment">// 对于新的节点如果是 string 或者 number，那么都是没有 key 的，</span><br>  <span class="hljs-comment">// 所有如果老的节点有 key 的话，就不能复用，直接返回 null。</span><br>  <span class="hljs-comment">// 老的节点 key 为 null 的话，代表老的节点是文本节点，就可以复用</span><br>  <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> updateTextNode(<br>    returnFiber,<br>    oldFiber,<br>    <span class="hljs-string">&#x27;&#x27;</span> + newChild,<br>    expirationTime,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 key 不为 null，那么就代表老节点不是 TextNode，而新节点又是 TextNode，所以返回 null，不能复用，反之则可以复用，调用 <code>updateTextNode</code> 方法。</p><blockquote><p>注意，updateTextNode 里面包含了首次渲染的时候的逻辑，首次渲染的时候回插入一个 TextNode，而不是复用。</p></blockquote><p><strong>当 newChild 是 Object 的时候</strong></p><p>newChild 是 Object 的时候基本上走的就是 ReactElement 的逻辑了，判断 key 和 元素的类型是否相等来判断是否可以复用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> newChild === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// 有 $$typeof 代表就是 ReactElement</span><br>  <span class="hljs-keyword">switch</span> (newChild.$$typeof) &#123;<br>    <span class="hljs-keyword">case</span> REACT_ELEMENT_TYPE: &#123;<br><span class="hljs-comment">// ReactElement 的逻辑 </span><br>    &#125;<br>    <span class="hljs-keyword">case</span> REACT_PORTAL_TYPE: &#123;<br><span class="hljs-comment">// 调用 updatePortal</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isArray(newChild) || getIteratorFn(newChild)) &#123;<br>    <span class="hljs-keyword">if</span> (key !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> updateFragment(<br>      returnFiber,<br>      oldFiber,<br>      newChild,<br>      expirationTime,<br>      <span class="hljs-literal">null</span>,<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是否是对象，用的是 <code>typeof newChild === &#39;object&#39; &amp;&amp; newChild !== null</code> ，注意要加 <code>!== null</code>，因为 <code>typeof null</code> 也是 object。</p><p>然后通过 $$typeof 判断是 REACT_ELEMENT_TYPE 还是 REACT_PORTAL_TYPE，分别调用不同的复用逻辑，然后由于数组也是 Object ，所以这个 if 里面也有数组的复用逻辑。</p><p>我相信到这里应该对于应该对于如何相同位置的节点如何对比有清晰的认识了。另外还有问题，那就是如何循环一个一个对比呢？</p><p>这里要注意，新的节点的 children 是虚拟 DOM，所以这个 children 是一个数组，而对于之前提到的老的节点树是链表。</p><p>那么循环一个一个对比，就是遍历数组的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> newIdx = <span class="hljs-number">0</span> <span class="hljs-comment">// 新数组的索引</span><br><span class="hljs-keyword">for</span> (; oldFiber !== <span class="hljs-literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;<br>  <span class="hljs-comment">// 遍历老的节点</span><br>  nextOldFiber = oldFiber.sibling; <br>  <span class="hljs-comment">// 返回复用节点的函数，newFiber 就是复用的节点。</span><br>  <span class="hljs-comment">// 如果为空，就代表同位置对比已经不能复用了，循环结束。</span><br>  <span class="hljs-keyword">const</span> newFiber = updateSlot(<br>    returnFiber,<br>    oldFiber,<br>    newChildren[newIdx],<br>    expirationTime,<br>  );<br>  <br>  <span class="hljs-keyword">if</span> (newFiber === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 其他 code，比如删除复用的节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这并不是源码的全部源码，我只是把思路给贴出来了。</p><p>这是第一次遍历新数组，通过调用 <code>updateSlot</code> 来对比新老元素，前面介绍的如何对比新老节点的代码都是在这个函数里。这个循环会把所以的从前面开始能复用的节点，都复用到。比如上面我们画的图，如果两个链表里面的 <strong>？？？</strong>节点，不相同，那么 newFiber 为 null，这个循环就会跳出。</p><p>跳出来了，就会有两种情况。</p><ul><li>新节点已经遍历完毕</li><li>老节点已经遍历完毕</li></ul><h3 id="2-新节点已经遍历完毕"><a href="#2-新节点已经遍历完毕" class="headerlink" title="2. 新节点已经遍历完毕"></a>2. 新节点已经遍历完毕</h3><p>如果新节点已经遍历完毕的话，也就是没有要更新的了，这种情况一般就是从原来的数组里面删除了元素，那么直接把剩下的老节点删除了就行了。还是拿上面的图的例子举例，老的链表里<strong>？？？</strong>还有很多节点，而新的链表<strong>？？？</strong>已经没有节点了，所以老的链表<strong>？？？</strong>不管是有多少节点，都不能复用了，所以没用了，直接删除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (newIdx === newChildren.length) &#123;<br>  <span class="hljs-comment">// 新的 children 长度已经够了，所以把剩下的删除掉</span><br>  deleteRemainingChildren(returnFiber, oldFiber);<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里是直接 <code>return</code> 了哦，没有继续往下执行了。</p><h3 id="3-老节点已经遍历完毕"><a href="#3-老节点已经遍历完毕" class="headerlink" title="3. 老节点已经遍历完毕"></a>3. 老节点已经遍历完毕</h3><p>如果老的节点在第一次循环的时候就被复用完了，新的节点还有，很有可能就是新增了节点的情况。那么这个时候只需要根据把剩余新的节点直接创建 <strong>Fiber</strong> 就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (oldFiber === <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// 如果老的节点已经被复用完了，对剩下的新节点进行操作</span><br>  <span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;<br>    <span class="hljs-keyword">const</span> newFiber = createChild(<br>      returnFiber,<br>      newChildren[newIdx],<br>      expirationTime,<br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> resultingFirstChild;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>oldFiber === null</code> 就是用来判断老的 Fiber 节点变量完了的代码，Fiber 链表是一个单向链表，所以为 null 的时候代表已经结束了。所以就直接把剩余的 newChild 通过循环创建 Fiber。</p><p>到这里，目前简单的对数组进行增、删节点的对比还是比较简单，接下来就是移动的情况是如何进行复用的呢？</p><h3 id="4-移动的情况如何进行节点复用"><a href="#4-移动的情况如何进行节点复用" class="headerlink" title="4. 移动的情况如何进行节点复用"></a>4. 移动的情况如何进行节点复用</h3><p>对于移动的情况，首先要思考，怎么能判断数组是否发生过移动操作呢？</p><p>如果给你两个数组，你是否能判断出来数组是否发生过移动。</p><p>答案是：老的数组和新的数组里面都有这个元素，而且位置不相同。</p><p>从两个数组中找到相同元素(是指可复用的节点)，方法有很多种，来看看 React 是如何高效的找出来的。</p><p><strong>把所有老数组元素按 key 或者是 index 放 Map 里，然后遍历新数组，根据新数组的 key 或者 index 快速找到老数组里面是否有可复用的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mapRemainingChildren</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function"> returnFiber: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function"> currentFirstChild: Fiber,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Map</span>&lt;<span class="hljs-title">string</span> | <span class="hljs-title">number</span>, <span class="hljs-title">Fiber</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> existingChildren: <span class="hljs-built_in">Map</span>&lt;string | number, Fiber&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><br>  <span class="hljs-keyword">let</span> existingChild = currentFirstChild; <span class="hljs-comment">// currentFirstChild 是老数组链表的第一个元素</span><br>  <span class="hljs-keyword">while</span> (existingChild !== <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-comment">// 看到这里可能会疑惑怎么在 Map 里面的key 是 fiber 的key 还是 fiber 的 index 呢？</span><br>  <span class="hljs-comment">// 我觉得是根据数据类型，fiber 的key 是字符串，而 index 是数字，这样就能区分了</span><br>  <span class="hljs-comment">// 所以这里是用的 map，而不是对象，如果是对象的key 就不能区分 字符串类型和数字类型了。</span><br>    <span class="hljs-keyword">if</span> (existingChild.key !== <span class="hljs-literal">null</span>) &#123;<br>      existingChildren.set(existingChild.key, existingChild);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      existingChildren.set(existingChild.index, existingChild);<br>    &#125;<br>    existingChild = existingChild.sibling;<br>&#125;<br><span class="hljs-keyword">return</span> existingChildren;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个 <code>mapRemainingChildren</code> 就是将老数组存放到 Map 里面。元素有 key 就 Map 的键就存 key，没有 key 就存 index，key 一定是字符串，index 一定是 number，所以取的时候是能区分的，所以这里用的是 Map，而不是对象，如果是对象，属性是字符串，就没办法区别是 key 还是 index 了。</p><p>现在有了这个 Map，剩下的就是循环新数组，找到 Map 里面可以复用的节点，如果找不到就创建，这个逻辑基本上跟 <code>updateSlot</code> 的复用逻辑很像，一个是从老数组链表中获取节点对比，一个是从 Map 里获取节点对比。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 如果前面的算法有复用，那么 newIdx 就不从 0 开始</span><br><span class="hljs-keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;<br>  <span class="hljs-keyword">const</span> newFiber = updateFromMap(<br>    existingChildren,<br>    returnFiber,<br>    newIdx,<br>    newChildren[newIdx],<br>    expirationTime,<br>  );<br> <span class="hljs-comment">// 省略删除 existingChildren 中的元素和添加 Placement 副作用的情况</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>到这里新数组遍历完毕，也就是<strong>同一层</strong>的 Diff 过程完毕，接下来进行总结一下。</p><h3 id="效果演示"><a href="#效果演示" class="headerlink" title="效果演示"></a>效果演示</h3><p>以下效果动态演示来自于文章：<a href="https://slane.cn/2018/08/09/react-diff-yuan-ma-fen-xi/">React Diff 源码分析</a>，我觉得这个演示非常的形象，有助于理解。</p><p>这里渲染一个可输入的数组。<br><img src="http://imgs.taoweng.site/2019-07-28-134128.png" alt="1"></p><p>当第一种情况，新数组遍历完了，老数组剩余直接删除（12345→1234 删除 5）：</p><p><img src="http://imgs.taoweng.site/2019-07-28-134130.gif" alt="img"></p><p>新数组没完，老数组完了（1234→1234567 插入 567）：</p><p><img src="http://imgs.taoweng.site/2019-07-28-134136.gif" alt="img"></p><p>移动的情况，即之前就存在这个元素，后续只是顺序改变（123 → 4321 插入4，移动2 1）：</p><p><img src="http://imgs.taoweng.site/2019-07-28-134140.gif" alt="img"></p><p>最后删除没有涉及的元素。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于数组的 diff 策略，相对比较复杂，最后来梳理一下这个策略，其实还是很简单，只是看源码的时候比较难懂。</p><p>我们可以把整个过程分为三个阶段：</p><ol><li>第一遍历新数组，新老数组相同 index 进行对比，通过 <code>updateSlot</code>方法找到可以复用的节点，直到找到不可以复用的节点就退出循环。</li><li>第一遍历完之后，删除剩余的老节点，追加剩余的新节点的过程。如果是新节点已遍历完成，就将剩余的老节点批量删除；如果是老节点遍历完成仍有新节点剩余，则将新节点直接插入。</li><li>把所有老数组元素按 key 或 index 放 Map 里，然后遍历新数组，插入老数组的元素，这是移动的情况。</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>刚开始阅读源码的过程是非常的痛苦的，但是当你一遍一遍的把作者想要表达的理解了，为什么要这么写 理解了，会感到作者的设计是如此的精妙绝伦，每一个变量，每一行代码感觉都是精心设计过的，然后感受到自己与大牛的差距，激发自己的动力。</p><p>更多的对于 React 原理相关，源码相关的内容，请关注我的 github：<a href="https://github.com/crazylxr/deep-in-react">Deep In React</a> 或者 个人博客：<a href="http://www.taoweng.site/">桃园</a></p><p>我是桃翁，一个爱思考的前端er，想了解关于更多的前端相关的，请关注我的公号：「前端桃园」</p><p><img src="http://imgs.taoweng.site/2019-07-28-134144.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Deep In React 之浅谈 React Fiber 架构（一）</title>
    <link href="/index.php/archives/262/"/>
    <url>/index.php/archives/262/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章首发于<a href="http://taoweng.site/">个人博客</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2016 年都已经透露出来的概念，这都 9102 年了，我才开始写 Fiber 的文章，表示惭愧呀。不过现在好的是关于 Fiber 的资料已经很丰富了，在写文章的时候参考资料比较多，比较容易深刻的理解。</p><p>React 作为我最喜欢的框架，没有之一，我愿意花很多时间来好好的学习他，我发现对于学习一门框架会有四种感受，刚开始没使用过，可能有一种很神奇的感觉；然后接触了，遇到了不熟悉的语法，感觉这是什么垃圾东西，这不是反人类么；然后当你熟悉了之后，真香，设计得挺好的，这个时候它已经改变了你编程的思维方式了；再到后来，看过他的源码，理解他的设计之后，设计得确实好，感觉自己也能写一个的样子。</p><p>所以我<strong>今年</strong>(对，没错，就是一年)就是想完全的学透 React，所以开了一个 <strong>Deep In React</strong> 的系列，把一些新手在使用 API 的时候不知道为什么的点，以及一些为什么有些东西要这么设计写出来，与大家共同探讨 React 的奥秘。</p><p>我的思路是自上而下的介绍，先理解整体的 Fiber 架构，然后再细挖每一个点，所以这篇文章主要是谈 Fiber 架构的。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在详细介绍 Fiber 之前，先了解一下 Fiber 是什么，以及为什么 React 团队要话两年时间重构协调算法。</p><h3 id="React-的核心思想"><a href="#React-的核心思想" class="headerlink" title="React 的核心思想"></a>React 的核心思想</h3><p><strong>内存中维护一颗虚拟DOM树，数据变化时（setState），自动更新虚拟 DOM，得到一颗新树，然后 Diff 新老虚拟 DOM 树，找到有变化的部分，得到一个 Change(Patch)，将这个 Patch 加入队列，最终批量更新这些 Patch 到 DOM 中</strong>。</p><h3 id="React-16-之前的不足"><a href="#React-16-之前的不足" class="headerlink" title="React 16 之前的不足"></a>React 16 之前的不足</h3><p>首先我们了解一下 React 的工作过程，当我们通过<code>render() </code>和 <code>setState()</code> 进行组件渲染和更新的时候，React 主要有两个阶段：</p><p><img src="http://imgs.taoweng.site/2019-06-25-151228.png"></p><p><strong>调和阶段(Reconciler)：</strong><a href="https://zh-hans.reactjs.org/docs/reconciliation.html">官方解释</a>。React 会自顶向下通过递归，遍历新数据生成新的 Virtual DOM，然后通过 Diff 算法，找到需要变更的元素(Patch)，放到更新队列里面去。</p><p>**渲染阶段(Renderer)**：遍历更新队列，通过调用宿主环境的API，实际更新渲染对应元素。宿主环境，比如 DOM、Native、WebGL 等。</p><p>在协调阶段阶段，由于是采用的递归的遍历方式，这种也被成为 <strong>Stack Reconciler</strong>，主要是为了区别 <strong>Fiber Reconciler</strong> 取的一个名字。这种方式有一个特点：一旦任务开始进行，就<strong>无法中断</strong>，那么 js 将一直占用主线程， 一直要等到整棵 Virtual DOM 树计算完成之后，才能把执行权交给渲染引擎，那么这就会导致一些用户交互、动画等任务无法立即得到处理，就会有卡顿，非常的影响用户体验。</p><h3 id="如何解决之前的不足"><a href="#如何解决之前的不足" class="headerlink" title="如何解决之前的不足"></a>如何解决之前的不足</h3><blockquote><p>之前的问题主要的问题是任务一旦执行，就无法中断，js 线程一直占用主线程，导致卡顿。</p></blockquote><p>可能有些接触前端不久的不是特别理解上面为什么 js 一直占用主线程就会卡顿，我这里还是简单的普及一下。</p><h4 id="浏览器每一帧都需要完成哪些工作？"><a href="#浏览器每一帧都需要完成哪些工作？" class="headerlink" title="浏览器每一帧都需要完成哪些工作？"></a>浏览器每一帧都需要完成哪些工作？</h4><p>页面是一帧一帧绘制出来的，当每秒绘制的帧数（FPS）达到 60 时，页面是流畅的，小于这个值时，用户会感觉到卡顿。</p><p>1s 60 帧，所以每一帧分到的时间是 1000/60 ≈ 16 ms。所以我们书写代码时力求不让一帧的工作量超过 16ms。</p><p><img src="http://imgs.taoweng.site/2019-06-25-151230.png" alt="image-20190603163205451"></p><p><em>浏览器一帧内的工作</em></p><p>通过上图可看到，一帧内需要完成如下六个步骤的任务：</p><ul><li>处理用户的交互</li><li>JS 解析执行</li><li>帧开始。窗口尺寸变更，页面滚去等的处理</li><li>rAF(requestAnimationFrame)</li><li>布局</li><li>绘制</li></ul><p>如果这六个步骤中，任意一个步骤所占用的时间过长，总时间超过 16ms 了之后，用户也许就能看到卡顿。</p><p>而在上一小节提到的<strong>调和阶段</strong>花的时间过长，也就是 js 执行的时间过长，那么就有可能在用户有交互的时候，本来应该是渲染下一帧了，但是在当前一帧里还在执行 JS，就导致用户交互不能麻烦得到反馈，从而产生卡顿感。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>把渲染更新过程拆分成多个子任务，每次只做一小部分，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。</strong>这种策略叫做 <a href="https://www.w3.org/TR/requestidlecallback/">Cooperative Scheduling（合作式调度）</a>，操作系统常用任务调度策略之一。</p><blockquote><p><strong>补充知识</strong>，操作系统常用任务调度策略：先来先服务（FCFS）调度算法、短作业（进程）优先调度算法（SJ/PF）、最高优先权优先调度算法（FPF）、高响应比优先调度算法（HRN）、时间片轮转法（RR）、多级队列反馈法。</p></blockquote><p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 <strong>Scheduler</strong> 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了<code>requestIdelCallback</code>API。对于不支持这个API 的浏览器，React 会加上 pollyfill。</p><p>在上面我们已经知道浏览器是一帧一帧执行的，在两个执行帧之间，主线程通常会有一小段空闲时间，<code>requestIdleCallback</code>可以在这个<strong>空闲期（Idle Period）调用空闲期回调（Idle Callback）</strong>，执行一些任务。</p><p><img src="http://imgs.taoweng.site/2019-06-25-151231.png" alt="image-20190625225130226"></p><ul><li><p>低优先级任务由<code>requestIdleCallback</code>处理；</p></li><li><p>高优先级任务，如动画相关的由<code>requestAnimationFrame</code>处理；</p></li><li><p><code>requestIdleCallback </code>可以在多个空闲期调用空闲期回调，执行任务；</p></li><li><p><code>requestIdleCallback </code>方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</p></li></ul><p>这个方案看似确实不错，但是怎么实现可能会遇到几个问题：</p><ul><li>如何拆分成子任务？</li><li>一个子任务多大合适？</li><li>怎么判断是否还有剩余时间？</li><li>有剩余时间怎么去调度应该执行哪一个任务？</li><li>没有剩余时间之前的任务怎么办？</li></ul><p>接下里整个 Fiber 架构就是来解决这些问题的。</p><h2 id="什么是-Fiber"><a href="#什么是-Fiber" class="headerlink" title="什么是 Fiber"></a>什么是 Fiber</h2><p>为了解决之前提到解决方案遇到的问题，提出了以下几个目标：</p><ul><li>暂停工作，稍后再回来。</li><li>为不同类型的工作分配优先权。</li><li>重用以前完成的工作。</li><li>如果不再需要，则中止工作。</li></ul><p>为了做到这些，我们首先需要一种方法将任务分解为单元。从某种意义上说，这就是 Fiber，Fiber 代表一种<strong>工作单元</strong>。</p><p>但是仅仅是分解为单元也无法做到中断任务，因为函数调用栈就是这样，每个函数为一个工作，每个工作被称为<strong>堆栈帧</strong>，它会一直工作，直到堆栈为空，无法中断。</p><p>所以我们需要一种增量渲染的调度，那么就需要重新实现一个堆栈帧的调度，这个堆栈帧可以按照自己的调度算法执行他们。另外由于这些堆栈是可以自己控制的，所以可以加入并发或者错误边界等功能。</p><p>因此 Fiber 就是重新实现的堆栈帧，本质上 Fiber 也可以理解为是一个<strong>虚拟的堆栈帧</strong>，将可中断的任务拆分成多个子任务，通过按照优先级来自由调度子任务，分段更新，从而将之前的同步渲染改为异步渲染。</p><p>所以我们可以说 Fiber 是一种数据结构(堆栈帧)，也可以说是一种解决可中断的调用任务的一种解决方案，它的特性就是**时间分片(time slicing)<strong>和</strong>暂停(supense)**。</p><blockquote><p>如果了解<strong>协程</strong>的可能会觉得 Fiber 的这种解决方案，跟协程有点像(区别还是很大的)，是可以中断的，可以控制执行顺序。在 JS 里的 generator 其实就是一种协程的使用方式，不过颗粒度更小，可以控制函数里面的代码调用的顺序，也可以中断。</p></blockquote><h2 id="Fiber-是如何工作的"><a href="#Fiber-是如何工作的" class="headerlink" title="Fiber 是如何工作的"></a>Fiber 是如何工作的</h2><ol><li><code>ReactDOM.render()</code> 和 <code>setState</code> 的时候开始创建更新。</li><li>将创建的更新加入任务队列，等待调度。</li><li>在 requestIdleCallback 空闲时执行任务。</li><li>从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。</li><li>生成 effectList。</li><li>根据 EffectList 更新 DOM。</li></ol><p>下面是一个详细的执行过程图：</p><p><img src="http://imgs.taoweng.site/2019-06-25-151232.png"></p><ol><li>第一部分从 <code>ReactDOM.render()</code> 方法开始，把接收的 React Element 转换为 Fiber 节点，并为其设置优先级，创建 Update，加入到更新队列，这部分主要是做一些初始数据的准备。</li><li>第二部分主要是三个函数：<code>scheduleWork</code>、<code>requestWork</code>、<code>performWork</code>，即安排工作、申请工作、正式工作三部曲，React 16 新增的异步调用的功能则在这部分实现，这部分就是 <strong>Schedule 阶段</strong>，前面介绍的 Cooperative Scheduling 就是在这个阶段，只有在这个解决获取到可执行的时间片，第三部分才会继续执行。具体是如何调度的，后面文章再介绍，这是 React 调度的关键过程。</li><li>第三部分是一个大循环，遍历所有的 Fiber 节点，通过 Diff 算法计算所有更新工作，产出 EffectList 给到 commit 阶段使用，这部分的核心是 beginWork 函数，这部分基本就是 <strong>Fiber Reconciler ，包括 reconciliation 和 commit 阶段</strong>。</li></ol><h3 id="Fiber-Node"><a href="#Fiber-Node" class="headerlink" title="Fiber Node"></a>Fiber Node</h3><p>FIber Node，承载了非常关键的上下文信息，可以说是贯彻整个创建和更新的流程，下来分组列了一些重要的 Fiber 字段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  ...<br>  <span class="hljs-comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span><br>  <span class="hljs-attr">stateNode</span>: any,<br>    <br>    <span class="hljs-comment">// 单链表树结构</span><br>  <span class="hljs-attr">return</span>: Fiber | <span class="hljs-literal">null</span>,<span class="hljs-comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span><br>  <span class="hljs-attr">child</span>: Fiber | <span class="hljs-literal">null</span>,<span class="hljs-comment">// 指向自己的第一个子节点</span><br>  <span class="hljs-attr">sibling</span>: Fiber | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span><br><br>  <span class="hljs-comment">// 更新相关</span><br>  <span class="hljs-attr">pendingProps</span>: any,  <span class="hljs-comment">// 新的变动带来的新的props</span><br>  <span class="hljs-attr">memoizedProps</span>: any,  <span class="hljs-comment">// 上一次渲染完成之后的props</span><br>  <span class="hljs-attr">updateQueue</span>: UpdateQueue&lt;any&gt; | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span><br>  <span class="hljs-attr">memoizedState</span>: any, <span class="hljs-comment">// 上一次渲染的时候的state</span><br>    <br>  <span class="hljs-comment">// Scheduler 相关</span><br>  <span class="hljs-attr">expirationTime</span>: ExpirationTime,  <span class="hljs-comment">// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务</span><br>  <span class="hljs-comment">// 快速确定子树中是否有不在等待的变化</span><br>  <span class="hljs-attr">childExpirationTime</span>: ExpirationTime,<br>    <br> <span class="hljs-comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span><br>  <span class="hljs-comment">// 我们称他为`current &lt;==&gt; workInProgress`</span><br>  <span class="hljs-comment">// 在渲染完成之后他们会交换位置</span><br>  <span class="hljs-attr">alternate</span>: Fiber | <span class="hljs-literal">null</span>,<br><br>  <span class="hljs-comment">// Effect 相关的</span><br>  <span class="hljs-attr">effectTag</span>: SideEffectTag, <span class="hljs-comment">// 用来记录Side Effect</span><br>  <span class="hljs-attr">nextEffect</span>: Fiber | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 单链表用来快速查找下一个side effect</span><br>  <span class="hljs-attr">firstEffect</span>: Fiber | <span class="hljs-literal">null</span>,  <span class="hljs-comment">// 子树中第一个side effect</span><br>  <span class="hljs-attr">lastEffect</span>: Fiber | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 子树中最后一个side effect</span><br>  ....<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Fiber-Reconciler"><a href="#Fiber-Reconciler" class="headerlink" title="Fiber Reconciler"></a>Fiber Reconciler</h3><p>在第二部分，进行 Schedule 完，获取到时间片之后，就开始进行 reconcile。</p><p>Fiber Reconciler 是 React 里的调和器，这也是任务调度完成之后，如何去执行每个任务，如何去更新每一个节点的过程，对应上面的第三部分。</p><p>reconcile 过程分为2个阶段（phase）：</p><ol><li>（可中断）render/reconciliation 通过构造 WorkInProgress Tree 得出 Change。</li><li>（不可中断）commit 应用这些DOM change。</li></ol><h4 id="reconciliation-阶段"><a href="#reconciliation-阶段" class="headerlink" title="reconciliation 阶段"></a>reconciliation 阶段</h4><p>在 reconciliation 阶段的每个工作循环中，每次处理一个 Fiber，处理完可以中断/挂起整个工作循环。通过每个节点更新结束时向上归并 <strong>Effect List</strong> 来收集任务结果，reconciliation 结束后，<strong>根节点</strong>的 Effect List里记录了包括 DOM change 在内的所有 <strong>Side Effect</strong>。</p><p>render 阶段可以理解为就是 Diff 的过程，得出 Change(Effect List)，会执行声明如下的声明周期方法：</p><ul><li>[UNSAFE_]componentWillMount（弃用）</li><li>[UNSAFE_]componentWillReceiveProps（弃用）</li><li>getDerivedStateFromProps</li><li>shouldComponentUpdate</li><li>[UNSAFE_]componentWillUpdate（弃用）</li><li>render</li></ul><p>由于 reconciliation 阶段是可中断的，一旦中断之后恢复的时候又会重新执行，所以很可能 reconciliation 阶段的生命周期方法会被多次调用，所以在 reconciliation 阶段的生命周期的方法是不稳定的，我想这也是 React 为什么要废弃 <code>componentWillMount</code> 和 <code>componentWillReceiveProps</code>方法而改为静态方法 <code>getDerivedStateFromProps</code> 的原因吧。</p><h4 id="commit-阶段"><a href="#commit-阶段" class="headerlink" title="commit 阶段"></a>commit 阶段</h4><p>commit 阶段可以理解为就是将 Diff 的结果反映到真实 DOM 的过程。</p><p>在 commit 阶段，在 commitRoot 里会根据 <code>effect </code>的 <code>effectTag</code>，具体 effectTag 见<a href="https://github.com/facebook/react/blob/504576306461a5ff339dc99691842f0f35a8bf4c/packages/shared/ReactSideEffectTags.js">源码</a> ，进行对应的插入、更新、删除操作，根据 <code>tag</code> 不同，调用不同的更新方法。</p><p>commit 阶段会执行如下的声明周期方法：</p><ul><li>getSnapshotBeforeUpdate</li><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><blockquote><p>P.S：注意区别 reconciler、reconcile 和 reconciliation，reconciler 是调和器，是一个名词，可以说是 React 工作的一个模块，协调模块；reconcile 是调和器调和的动作，是一个动词；而 reconciliation 只是 reconcile 过程的第一个阶段。</p></blockquote><h3 id="Fiber-Tree-和-WorkInProgress-Tree"><a href="#Fiber-Tree-和-WorkInProgress-Tree" class="headerlink" title="Fiber Tree 和 WorkInProgress Tree"></a>Fiber Tree 和 WorkInProgress Tree</h3><p>React 在 render 第一次渲染时，会通过 React.createElement 创建一颗 Element 树，可以称之为 <strong>Virtual DOM Tree</strong>，由于要记录上下文信息，加入了 Fiber，每一个 Element 会对应一个 Fiber Node，将 Fiber Node 链接起来的结构成为 <strong>Fiber Tree</strong>。它反映了用于渲染 UI 的应用程序的状态。这棵树通常被称为 <strong>current 树（当前树，记录当前页面的状态）。</strong></p><p>在后续的更新过程中（setState），每次重新渲染都会重新创建 Element, 但是 Fiber 不会，Fiber 只会使用对应的 Element 中的数据来更新自己必要的属性，</p><p>Fiber Tree 一个重要的特点是链表结构，将递归遍历编程循环遍历，然后配合 requestIdleCallback API, 实现任务拆分、中断与恢复。</p><p>这个链接的结构是怎么构成的呢，这就要主要到之前 Fiber Node 的节点的这几个字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单链表树结构</span><br>&#123;<br>   <span class="hljs-attr">return</span>: Fiber | <span class="hljs-literal">null</span>, <span class="hljs-comment">// 指向父节点</span><br>   <span class="hljs-attr">child</span>: Fiber | <span class="hljs-literal">null</span>,<span class="hljs-comment">// 指向自己的第一个子节点</span><br>   <span class="hljs-attr">sibling</span>: Fiber | <span class="hljs-literal">null</span>,<span class="hljs-comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每一个 Fiber Node 节点与 Virtual Dom 一一对应，所有 Fiber Node 连接起来形成 Fiber tree, 是个单链表树结构，如下图所示：</p><p><img src="http://imgs.taoweng.site/2019-06-25-151232.jpg"></p><p>对照图来看，是不是可以知道 Fiber Node 是如何联系起来的呢，Fiber Tree 就是这样一个单链表。</p><p><strong>当 render 的时候有了这么一条单链表，当调用 <code>setState</code> 的时候又是如何 Diff 得到 change 的呢？</strong></p><p>采用的是一种叫<strong>双缓冲技术（double buffering）</strong>，这个时候就需要另外一颗树：WorkInProgress Tree，它反映了要刷新到屏幕的未来状态。</p><p>WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree，然后喜新厌旧（把 current 指针指向WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。</p><p>这样做的好处：</p><ul><li>能够复用内部对象（fiber）</li><li>节省内存分配、GC的时间开销</li><li>就算运行中有错误，也不会影响 View 上的数据</li></ul><p>每个 Fiber上都有个<code>alternate</code>属性，也指向一个 Fiber，创建 WorkInProgress 节点时优先取<code>alternate</code>，没有的话就创建一个。</p><p>创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 Effect List，这个 Effect List 就是最终 Commit 阶段用来处理副作用的阶段。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本开始想一篇文章把 Fiber 讲透的，但是写着写着发现确实太多了，想写详细，估计要写几万字，所以我这篇文章的目的仅仅是在没有涉及到源码的情况下梳理了大致 React 的工作流程，对于细节，比如如何调度异步任务、如何去做 Diff 等等细节将以小节的方式一个个的结合源码进行分析。</p><p>说实话，自己不是特别满意这篇，感觉头重脚轻，在讲协调之前写得还挺好的，但是在讲协调这块文字反而变少了，因为我是专门想写一篇文章讲协调的，所以这篇仅仅用来梳理整个流程。</p><p>但是梳理整个流程又发现 Schedule 这块基本没什么体现，哎，不想写了，这篇文章拖太久了，请继续后续的文章。</p><p>可以关注我的 github：<a href="https://github.com/crazylxr/deep-in-react">Deep In React</a></p><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><p>接下来留一些思考题。</p><ul><li><p>如何去划分任务优先级？</p></li><li><p>在 reconcile 过程的 render 阶段是如何去遍历链表，如何去构建 workInProgress 的？</p></li><li><p>当任务被打断，如何恢复？</p></li><li><p>如何去收集 EffectList？</p></li><li><p>针对不同的组件类型如何进行更新？</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="%5Bhttp://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4%5D(http://www.ayqy.net/blog/dive-into-react-fiber/#articleHeader4)">完全理解 React Fiber</a></li><li><a href="https://happy-alex.github.io/js/react/fiber/">Fiber</a></li><li><a href="https://github.com/HuJiaoHJ/blog/issues/7#">React16源码之React Fiber架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>针对华为事件，我思考了四点</title>
    <link href="/index.php/archives/263/"/>
    <url>/index.php/archives/263/</url>
    
    <content type="html"><![CDATA[<p>本来我是不喜欢追热点的，不过今天有个群友在群里发了这样一段话。</p><p><img src="http://imgs.taoweng.site/2019-05-30-153543.jpg"></p><p>结果被我怼了：<br><img src="http://imgs.taoweng.site/2019-05-30-153551.jpg"></p><p><img src="http://imgs.taoweng.site/2019-05-30-153552.jpg"></p><p>后面的我就不截图了，反正我提倡的是，随时我们能做的是<strong>好好的提升自己</strong>，只有提升自己才是最重要的。</p><p>有些人同意我的看法，有些人不同意我的看法，这都不是我今天说的重点，只是这个导火线引发的我的一些思考。</p><h2 id="不要让别人的文章限制了你的思维"><a href="#不要让别人的文章限制了你的思维" class="headerlink" title="不要让别人的文章限制了你的思维"></a>不要让别人的文章限制了你的思维</h2><p><img src="http://imgs.taoweng.site/2019-05-30-153553.jpg"></p><p>这是我后来跟那个在群里发文章的那个老哥说的话，但是他也没有回我，这都不重要，重要的是我想表达的观点。</p><p><strong>不要让网上的文章限制了你的思维</strong>。现在网上很多自媒体都是无脑夸华为牛逼，世界第一，美国傻逼，你转发他的文章代表你就是爱国的。你的这些感受都是作者想看到的，都是作者设计好的，你可以去看现在线上的一些写作课程，理论上都会有一些技巧是如何调动读者的情绪，引发共鸣等。</p><p>我不是说这种技巧不对，反而我觉得他写得很棒，他做到了他想要的结果。这样的小编很棒，我也希望我能写出这样的文章，双十万加(阅读量和点赞超十万)。</p><p>而是作为新时代的读者，我们不仅应该有爱国情怀，更应该有自己的想法，不要局限于作者的思路，应该以更大的视角，更全的视角去看待问题。</p><p>在《少数人走的路》里面就提到一条，思考是需要整体的，一旦你整体的去思考这个问题，就会产生矛盾，有了矛盾，才会使我们更深刻的去思考问题。</p><p>所以我们不要无脑的觉得转个文章，留个言这就是爱国，真正的爱国是什么：知道自己的技术不足，好好的搞技术，知道自己能力差，好好的提升能力。这才是支持国家，为国家做贡献了。</p><p><strong>穷者独善其身，达者兼济天下。</strong>我们连独善其身都没做到，就有一股兼济天下的冲动。我还是之前在我看 996 那篇文章中提到的，一般人我们能做的就是好好的提升自己，等你有能力了，有钱了，给贫穷山区盖个小学，给慈善基金捐点钱这就是算开始兼济天下了。</p><p>另外一个群友发表了一个观点，我觉得还是有点用吧。</p><p><img src="http://imgs.taoweng.site/2019-05-30-153554.jpg"></p><p>连马云这种等级的人都觉得自己的事儿忙不过来，何况一般人呢？</p><p>最后，如果想有更大的视角去看待华为，可以看看这些文字，视角不同，也许会改变你现在的想法：</p><ul><li>  <a href="https://mp.weixin.qq.com/s/kzzXEhDH_qSYF_9k8c5lwQ">任正非回应美国封杀：不要煽动民族情绪，不能狭隘认为爱华为就用华为手机</a></li><li>  <a href="https://mp.weixin.qq.com/s/diEQpu6euKZh67xJ0Y7Qwg">重磅！任正非最新万字访谈，回应关于华为的一切 | 深网</a></li></ul><p>真的，老爷子的这番采访我特别的佩服，建议每个人看个一两遍。</p><h2 id="不要总想着自己能得到什么，而是你能给公司-其他人-带来什么好处"><a href="#不要总想着自己能得到什么，而是你能给公司-其他人-带来什么好处" class="headerlink" title="不要总想着自己能得到什么，而是你能给公司(其他人)带来什么好处"></a>不要总想着自己能得到什么，而是你能给公司(其他人)带来什么好处</h2><p>这点我是在任老爷子采访里面这段话突然想到的。</p><p><img src="http://imgs.taoweng.site/2019-05-30-153555.jpg"></p><p>可以看到，华为之所以这么牛逼，不是靠每天员工们 965 ，上班划划水，喊喊口号就能这么牛逼的，都是加班加出来的，一般人有他们辛苦吗？虽然别人公司顶着那么好看的光环，都是员工们努力、奋斗，用汗水换的。</p><p>很多人就是，又想公司强，又想工资高，又不想加班。当你站在公司外的角度的时候，又希望公司强，能抵制一切风险，工资高。但是作为员工，又不喜欢加班来使公司更强，总希望做受益者而不愿意去做点事情。</p><p>我们在与别人合作的时候也是这样，在去和别人合作的时候，请教别人问题的时候，别人能有什么好处呢？没有好处为什么要帮你呢？他又不是你的父母，无条件帮你解决一切能解决的事儿。</p><p>合作都是一个双赢的事儿，不要总想着占便宜，占便宜的事儿百分之百干不久的。</p><p>很多人在问问题的时候也是有问题的，本来群主有个技术交流群，不在群里问，非得去私聊群主(我已经听到很多群主抱怨过这个问题了)，不知道是因为觉得群里问效率低，怕浪费时间，还是觉得自己问的问题蠢，怕被别人嘲笑。其实这都是不太好的一种做法，不然群主创建交流群来干啥呢？不就是想大家一起交流，别啥事儿都问他么。</p><p>如果你是觉得问问题怕浪费时间，那别人回答问题就不花费时间吗？如果你确实着急，那你二话不说，红包先上，肯定有效。别上去就是：“在吗；有空吗”，这会体现一个人不会用微信聊天。</p><p>我在一个星球里看到这样一段话：</p><ul><li>  和别人交流时，先搞清楚一个问题，这是交流还是请教，如果要谈的话题，你已经掌握了 90%的知识，这个叫交流；如果不到 90%，这个叫请教。无论哪种，都会花费别人时间。所以无论是否对你有帮助，都应该首先发红包。</li></ul><p>我在之前的文章也说过，发红包不是因为回答的人差你这点红包，而是这是一种礼仪，知道你是麻烦了别人，表示一点心意。</p><h2 id="不要想着总能说服别人"><a href="#不要想着总能说服别人" class="headerlink" title="不要想着总能说服别人"></a>不要想着总能说服别人</h2><p>有这么一个故事：孔子的有一个弟子有一天跟一个人争论，争论啥呢？一年是三季还是四季的问题，然后这个弟子说服不了那个人，然后就带着他找孔子，弟子把事情说清楚了之后，孔子最后说的是一年只有三季。后来弟子就很疑惑，一年不是有四季吗，为什么你要跟他说三季？孔子就说，他一年只有三季了，你还跟他争论什么。</p><p><img src="http://imgs.taoweng.site/2019-05-30-153556.jpg"></p><p>我当时在群里说了这么一段话，然后就有一个小伙伴不同意我的观点。</p><p><img src="http://imgs.taoweng.site/2019-05-30-153558.jpg"></p><p>后面想了想，我也没跟他争辩，有可能我是错的，也有可能我是对的，我想了下，我没办法说服他，我就没有回复他。</p><p>我没有说这个小伙伴就是孔子故事里面那个三季的人，而是想表达当一个人所掌握的知识跟你差太远的时候，你没办法去说服他，他也没办法说服你，这个时候自己持有自己的观点就好，慢慢的，时间长了，学到的知识多了，见识广了，就能判断对与错了。</p><h2 id="不要轻易相信别人的结论"><a href="#不要轻易相信别人的结论" class="headerlink" title="不要轻易相信别人的结论"></a>不要轻易相信别人的结论</h2><p>吴军老师在得到课程《硅谷来信》里说过：科学是用来怀疑的，而不是用来信仰的。科学看重的是方法和过程，而不是结果。另外，科学的结论也未必等于正确的结论。</p><p>你可能会说，不是说不要轻易相信别人的结论，为啥你就觉得吴军老师说的这个话就是对的呢，岂不是和你说的互相矛盾吗？</p><p>我相信吴军老师说的结论，是因为他在课中所分析的逻辑，举的例子令我信服。所以我才相信他的结论。具体逻辑可以看《硅谷来信》的第 36 封信|科学的结论未必是正确的。</p><p>所以，我上面说的结论，也都有可能是错的，就连科学家得出的结论都有可能是错的。那我们应该怎么办呢？</p><p>我们在看有观点的文章的时候，应该注重得出观点的逻辑是否正确，而不是直接去判断观点。观点这种东西人人都能说，我说明天股票会涨，他说会跌。但是，说出一个合理的解释，这就不是每个人都能做到的。作为一个合格的读者，我们应该有自己的思想，自己的判断逻辑，而不是一味的去接收观点。</p><p>然后随便我们扯到学技术吧，我们在学习框架的时候，所有的大牛都会推荐你去学习框架、库的原理，而不仅仅是 api。原理就是上面说道的底层逻辑，而 api 只是最终的一个结果。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每个前端工程师都应该了解的图片知识</title>
    <link href="/index.php/archives/264/"/>
    <url>/index.php/archives/264/</url>
    
    <content type="html"><![CDATA[<!-- index-menu --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着web的发展，网站资源的流量也变得越来越大。据统计，60% 的网站流量均来自网站图片，可见对图片合理优化可以大幅影响网站流量，减小带宽消耗和服务器压力。</p><p>有时候你花大力气去配置 webpack 使打包体积减少，不如好好优化几张图片，这篇文章就是让你明白如何选择正确的图片，并且让你明白这么多图片格式，在什么场景下使用什么格式，如果想看答案，那么直接滑到文末看图即可。</p><p>我的更多文章可以看 <a href="https://github.com/crazylxr/blog/blob/master/README.md">GitHub博客</a>,</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在进入正题之前，先聊聊一些图片相关的基本概念。</p><p>一张照片（位图）不断放大之后，会看到一个个小格子，这些小格子，叫像素。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075228.jpg"></p><p>一个格子（像素），在计算机中，用二进制来表示，使用的二进制位数越多，像素的色彩就越丰富。</p><p>举个例子，如果一个像素用一位二进制数表示，能有多少种颜色呢？</p><blockquote><p>两种，一个二进制位，要不放 0（表示黑色），要不放 1（表示白色）</p></blockquote><p>下图展示了一个像素二进制的位数最多可以展示多少种颜色。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075229.jpg"></p><p>在对图片有了基本的了解之后，接下来对图片进行分下类，有利于理解各种格式图片的特点。</p><h3 id="根据图的类型分类"><a href="#根据图的类型分类" class="headerlink" title="根据图的类型分类"></a>根据图的类型分类</h3><ul><li>点阵图(位图)</li><li>矢量图</li></ul><h4 id="位图-点阵图"><a href="#位图-点阵图" class="headerlink" title="位图(点阵图)"></a>位图(点阵图)</h4><p>位图，也叫做点阵图，像素图。构成点阵图的最小单位是像素，位图就是由像素阵列的排列来实现其显示效果的，<strong>每个像素有自己的颜色信息</strong>，在对位图图像进行编辑操作的时候，可操作的对象是每个像素，我们可以改变图像的色相、饱和度、透明度，从而改变图像的显示效果。</p><p>前面介绍中的那种不断放大会有小格子的图就是属于位图。</p><p>常见的比如：jpg、png、webp等，我们平时遇到的大多数都是<strong>位图</strong>。</p><h4 id="矢量图"><a href="#矢量图" class="headerlink" title="矢量图"></a>矢量图</h4><p>矢量图，也叫做向量图。矢量图并不纪录画面上每一点的信息，而是纪录了元素形状及颜色的算法，当你打开一幅矢量图的时候，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看。</p><p>无论显示画面是大还是小，画面上的对象对应的算法是不变的，所以，即使对画面进行倍数相当大的缩放，其显示效果仍然相同(不失真)。</p><p>常见的就是 <strong>svg</strong> 格式的。</p><h3 id="根据压缩分类"><a href="#根据压缩分类" class="headerlink" title="根据压缩分类"></a>根据压缩分类</h3><ul><li>无压缩。</li><li>无损压缩。</li><li>有损压缩。</li></ul><h4 id="无压缩"><a href="#无压缩" class="headerlink" title="无压缩"></a>无压缩</h4><p>无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP 格式就是其中之一。</p><h4 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h4><p>指在压缩文件大小的过程中，损失了一部分图片的信息，也即降低了图片的质量，并且这种损失是不可逆的，我们不可能从有一个有损压缩过的图片中恢复出原来的图片。</p><p>常见的有损压缩手段，是按照一定的算法将临近的像素点进行合并。压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是 jpg。</p><h4 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h4><p>在压缩图片的过程中，图片的质量没有任何损耗。我们任何时候都可以从无损压缩过的图片中恢复出原来的信息。</p><p>压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。</p><p>png 是其中的代表。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li><strong>使用有损压缩处理图像，是去除某些像素数据，无法找回原图。</strong></li><li><strong>使用无损处理图像，是对像素数据进行压缩，可以找回原图。</strong></li></ul><h2 id="常见的图片格式解析"><a href="#常见的图片格式解析" class="headerlink" title="常见的图片格式解析"></a>常见的图片格式解析</h2><h3 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h3><p><strong>关键词</strong>：无损压缩、索引色、透明、动画</p><p>GIF(Graphics Interchange Format) 的原义是“图像互换格式”，是一种基于 <a href="https://zh.wikipedia.org/wiki/LZW">LZW</a> 算法连续色调的无损的基于索引色的压缩格式。其压缩率一般在 <code>50%</code> 左右，它不属于任何应用程序所以几乎所有相关软件都支持它，公共领域有大量的软件在使用 GIF 图像文件。</p><blockquote><p>GIF 是一种无损压缩，所以它只是对像素数据进行压缩，其实 LZW 算法只是一个压缩数据的算法，如果你懂哈夫曼算法的话，可能就比较好理解压缩数据是怎么回事儿了。</p></blockquote><p>GIF 的特性是<strong>帧动画</strong>。</p><p>相比古老的bmp格式，尺寸较小，而且支持透明(不支持半透明，因为不支持 Alpha 透明通道 )和动画。</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li>优秀的压缩算法使其在一定程度上保证图像质量的同时将体积变得很小。</li><li>可插入多帧，从而实现动画效果。</li><li>可设置透明色以产生对象浮现于背景之上的效果。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>由于采用了 8 位压缩，最多只能处理 256 种颜色，故不宜应用于<strong>真彩色</strong>(文末的附录有解释)图片。</p><h4 id="适合场景"><a href="#适合场景" class="headerlink" title="适合场景"></a>适合场景</h4><p>色彩简单的 logo、icon、线框图、文字输出等</p><h3 id="JPG-JPEG"><a href="#JPG-JPEG" class="headerlink" title="JPG/JPEG"></a>JPG/JPEG</h3><p><strong>关键词</strong>：有损压缩、直接色、适合大图、体积小</p><p>JPEG 格式是最常见的一种图像格式，文件后辍名为“.JPEG”或“.jpg”，JPEG 可以说是人们最熟悉的图档格式，相信在数字相机普及的现在，几乎每台数字相机、照相手机都可以（甚至只能）输出 JPEG 格式的图档。</p><p>JPEG 是一种很典型的使用有损压缩图像格式，也就是说使用者每次进行 JPEG 的存档动作后，图档的一些内容细节都会遭到永久性的破坏，尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量明显降低，如果追求高品质图像，不宜采用过高压缩比例。</p><p>JPEG 图片格式的设计目标，是在不影响人类可分辨的图片质量的前提下，尽可能的压缩文件大小。</p><h4 id="Baseline-JPEG-和-Progressive-JPEG"><a href="#Baseline-JPEG-和-Progressive-JPEG" class="headerlink" title="Baseline JPEG 和 Progressive JPEG"></a>Baseline JPEG 和 Progressive JPEG</h4><p>JPEG 有两种保存方式：Baseline JPEG（标准型）、Progressive JPEG（渐进式）。两种格式有相同尺寸以及图像数据，他们的扩展名也是相同的，唯一的区别是二者显示的方式不同。</p><p><strong>Baseline JPEG</strong></p><p>Baseline JPEG 文件存储方式是按从上到下的扫描方式，把每一行顺序的保存在 JPEG 文件中。打开这个文件显示它的内容时，数据将按照存储时的顺序从上到下一行一行的被显示出来，直到所有的数据都被读完，就完成了整张图片的显示。如果文件较大或者网络下载速度较慢，那么就会看到图片被一行行加载的效果，这种格式的JPEG没有什么优点，因此，一般都推荐使用Progressive JPEG。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075230.gif"></p><p><strong>Progressive JPEG</strong></p><p>和 Baseline 一遍扫描不同，Progressive JPEG 文件包含多次扫描，这些扫描顺寻的存储在 JPEG 文件中。打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰。这种格式的主要优点是在网络较慢的情况下，可以看到图片的轮廓知道正在加载的图片大概是什么。在一些网站打开较大图片时，你就会注意到这种技术。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075231.gif"></p><p>渐进式图片带来的好处是可以让用户在没有下载完图片就可以看到最终图像的大致轮廓，一定程度上可以提升用户体验（瀑布留的网站建议还是使用标准型的）。</p><p>更多关于 Baseline JPEG 和 Progressive JPEG 请看这篇文章：<a href="https://www.biaodianfu.com/progressive-jpeg.html">使用渐进式JPEG来提升用户体验</a>。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以支持 24bit 真彩色，普遍应用于需要连续色调的图像如色彩丰富的图片、照片等；</li><li>可利用可变的压缩比以控制文件大小；</li><li>支持交错（对于渐近式 JPEG 文件）；</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>JPEG 不适合用来存储企业 Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</li><li>有损耗压缩会使原始图片数据质量下降。</li><li>JPEG 图像<strong>不支持透明度处理</strong>，透明图片需要召唤 PNG 来呈现。</li></ul><h4 id="适合场景-1"><a href="#适合场景-1" class="headerlink" title="适合场景"></a>适合场景</h4><p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。</p><h4 id="GIF-vs-JPEG"><a href="#GIF-vs-JPEG" class="headerlink" title="GIF vs JPEG"></a>GIF vs JPEG</h4><p>由于 GIF 与 JPEG 有着如此不同的特性，因此我们可以很轻易的选择何时该用哪一种格式来输出我们需要的图档：当图片拥有<strong>丰富的色彩</strong>时，并且<strong>没有明显锐利反差的边缘线条</strong>时，选择 JPEG 可以得到最好的输出结果，照片就是最好的例子；当图片是拥有明确边缘的线条图、没有使用太多色彩、甚至可能需要透明背景时，GIF 是很好的选择，档案小、画质又精美。</p><h3 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h3><p><strong>关键词</strong>：无损压缩、索引色、支持透明、体积大</p><p>便携式网络图形（简称 PNG，英语全称：Portable Network Graphics）。PNG 能够提供长度比 GIF 小30%的无损压缩图像文件。它同时提供 24 位和 32 位真彩色图像支持以及其他诸多技术性支持。由于PNG 优秀的特点，PNG 格式图片可以称为“网页设计专用格式”。PNG 最初的开发目的是为了作为 GIF 的替代方案的，作为做新开发的影像传输文件格式，PNG 同样使用了无损压缩格式，事实上 PNG 的开发就是因为 GIF 所使用的无损压缩格式专利问题而诞生的。</p><p>PNG 有三种形式，下面分别介绍一下他们的区别。</p><h4 id="PNG-8"><a href="#PNG-8" class="headerlink" title="PNG-8"></a>PNG-8</h4><p>PNG-8 是 PNG 的索引色版本。PNG-8 是无损的、使用索引色的、点阵图。</p><p>PNG-8 是非常好的 GIF 替代者，在可能的情况下，应该尽可能的使用 PNG-8 而不是 GIF，因为在相同的图片效果下，PNG-8 具有<strong>更小的文件体积</strong>。除此之外，PNG-8 还支持<strong>透明度的调节</strong>，而 GIF 并不支持。 现在，除非需要动画的支持，否则我们没有理由使用 GIF 而不是 PNG-8。</p><h4 id="PNG-24"><a href="#PNG-24" class="headerlink" title="PNG-24"></a>PNG-24</h4><p>PNG-24 是 PNG 的直接色版本。PNG-24 是无损的、使用直接色的、点阵图。</p><p>无损的、使用直接色的点阵图，听起来非常像 BMP，是的，从显示效果上来看，PNG-24 跟 BMP 没有不同。PNG-24 的优点在于，它压缩了图片的数据，使得同样效果的图片，PNG-24 格式的文件大小要比 BMP 小得多。当然，PNG24 的图片还是要比 JPEG、GIF、PNG-8 大得多。</p><p>虽然 PNG-24 的一个很大的目标，是替换 JPEG 的使用。但一般而言，PNG-24 的文件大小是 JPEG 的五倍之多，而显示效果则通常只能获得一点点提升。所以，只有在你不在乎图片的文件体积，而想要最好的显示效果时，才应该使用 PNG-24 格式。</p><p>另外，PNG-24 是不支持透明的。</p><p>理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。</p><p>实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。</p><h4 id="PNG-32"><a href="#PNG-32" class="headerlink" title="PNG-32"></a>PNG-32</h4><p>PNG-32 跟 PNG-24 的区别就是多了一个 Alpha 通道，用来支持半透明，其他的跟 PNG-24 基本一样。</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>支持高级别无损耗压缩；</li><li>支持 alpha 通道透明度；</li><li>支持 256 色<a href="https://zh.wikipedia.org/w/index.php?title=%E8%B0%83%E8%89%B2%E6%9D%BF%E6%8A%80%E6%9C%AF&action=edit&redlink=1">调色板技术</a>以产生小体积文件</li><li>最高支持 24 位<a href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%BD%A9%E8%89%B2">真彩色</a>图像以及 8 位<a href="https://zh.wikipedia.org/wiki/%E7%81%B0%E5%BA%A6%E5%9B%BE%E5%83%8F">灰度图像</a>。</li><li>支持图像亮度的<a href="https://zh.wikipedia.org/wiki/Gamma%E6%A0%A1%E5%87%86"> Gamma 校准</a>信息。</li><li>支持存储附加文本信息，以保留图像名称、作者、著作权、创作时间、注释等信息。</li><li>渐近显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>较旧的浏览器 IE6- 和程序可能不支持 PNG 文件；</li><li>与 JPEG 的有损耗压缩相比，PNG 提供的压缩量较少；</li><li>与 GIF 格式相比，对多图像文件或动画文件不提供任何支持。</li></ul><h4 id="适合场景-2"><a href="#适合场景-2" class="headerlink" title="适合场景"></a>适合场景</h4><p>呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</p><h4 id="关于-PNG-的小知识点"><a href="#关于-PNG-的小知识点" class="headerlink" title="关于 PNG 的小知识点"></a>关于 PNG 的小知识点</h4><p>PNG 分为两种，一种是 Index，一种是 RGB。Index 记录同一种颜色的值和出现的位置（简单地说，比如一个 <code>2px*2px</code> 的超级小图，从左往右从上往下依次的颜色是红，白，白，红，那么记录的方法就是“红-1,4；白-2,3”）；而 RGB 图则把所有像素的色值依次记录下来（即“红，白，白红”）。对于相同的图片，Index 格式的尺寸总是小于 RGB。</p><p>其中 PNG-8 就是 Index，称作为索引色，而 PNG-24 和 PNG-32 是 RGB 形式，也可称作为直接色。</p><p>因为 PNG 是无损压缩，保留了图片需要的所有信息，所以索引色是可以转化为直接色的。</p><h3 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h3><p><strong>关键词</strong>：年轻、有损、无损、兼容性</p><p>WebP 是谷歌开发的一种新图片格式，WebP 是同时支持有损和无损压缩的、使用直接色的、点阵图。</p><p>从名字就可以看出来它是为 Web 而生的，什么叫为 Web 而生呢？就是说相同质量的图片，WebP 具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。</p><ul><li>在无损压缩的情况下，相同质量的 WebP 图片，文件大小要比 PNG 小26%；</li><li>在有损压缩的情况下，具有相同图片精度的 WebP 图片，文件大小要比 JPEG 小 25%~34%；</li><li>WebP 图片格式支持图片透明度，一个无损压缩的 WebP 图片，如果要支持透明度只需要 22% 的格外文件大小。</li></ul><p>可以看到 WebP <strong>集多种图片文件格式的优点于一身</strong>，所以在图片的质量和性能上，WebP 无疑是赢家。</p><p>不过 WebP 有有一个缺点，导致还不能大规模使用，那就是兼容性。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075232.jpg"></p><p>这是我 2019 年 5 月截的图，可以看到 IE 和 Safari 所有的版本都是不支持的(这是硬伤)， 火狐也是最新的几个版本才开始支持，年轻有年轻的代价。</p><p>此外，WebP 与 JPG 相比较，编码速度慢 10 倍，解码速度慢 1.5 倍，而绝大部分的网络应用中，图片都是静态文件，所以对于用户使用只需要关心解码速度即可。但实际上，WebP 虽然会增加额外的解码时间，但是由于减少了文件体积，缩短了加载的时间，实际上文件的渲染速度反而变快了。</p><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>**WebP **集多种图片文件格式的优点于一身，所以基本上适合各种场景，但是由于兼容性不好，所以我们如果大规模的适用 WebP，一定要在 Safari 和 IE 里面施行降级。</p><p><img src="http://imgs.taoweng.site/2019-06-08-075233.jpg"></p><p>这是淘宝商品图片是我在 Chrome 打开的例子，可以看到图片的后缀是 <code>.jpg_.webp</code>，如果这张图片在 Safari 打开后缀就变为了 <code>.jpg</code>，这是一种降级方案，其他的方案请读者自行研究，不在本文讨论中。</p><h3 id="APNG"><a href="#APNG" class="headerlink" title="APNG"></a>APNG</h3><p>APNG（Animated Portable Network Graphics）顾名思义是基于 PNG 格式扩展的一种动画格式，增加了对动画图像的支持，同时加入了 24 位图像和 8 位 Alpha 透明度的支持，这意味着动画将拥有更好的质量，其诞生的目的是为了替代老旧的 GIF 格式，但它目前并没有获得 PNG 组织官方的认可。</p><p>APNG 第1帧为标准 PNG 图像，剩余的动画和帧速等数据放在 PNG 扩展数据块，因此只支持原版 PNG 的软件会正确显示第 1 帧。</p><p><img src="http://imgs.taoweng.site/2019-06-08-75234.jpg"></p><p>在兼容性方面绝大部分浏览器都还是支持的，如果以前是因为动画的原因用 GIF 的，现在用 APNG 是一个不错的选择，其他的特性是跟 PNG 样的，因为 APNG 只是一个 PNG 的扩展。</p><blockquote><p>更多 APNG 相关的可以看 <a href="https://aotu.io/notes/2016/11/07/apng/index.html">APNG 那些事</a></p></blockquote><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p><strong>关键词</strong>：无损、矢量图、体积小、不失真、兼容性好</p><p>**可缩放矢量图形 **英文 Scalable Vector Graphics(SVG)，是无损的、矢量图。</p><p>SVG是一种用 XML 定义的语言，用来描述二维矢量及矢量/栅格图形。SVG提供了3种类型的图形对象：矢量图形（vectorgraphicshape例如：由直线和曲线组成的路径）、图象(image)、文本(text)。图形对象还可进行分组、添加样式、变换、组合等操作，特征集包括嵌套变换（nestedtransformations）、剪切路径（clippingpaths）、alpha 蒙板（alphamasks）、滤镜效果（filtereffects）、模板对象（templateobjects）和其它扩展（extensibility）。</p><p>SVG 跟上面这些图片格式最大的不同，是 SVG 是矢量图。这意味着 SVG 图片由直线和曲线以及绘制它们的方法组成。当你放大一个 SVG 图片的时候，你看到的还是线和曲线，而不会出现像素点。这意味着 SVG 图片在放大时，不会失真，所以它非常适合用来绘制企业 Logo、Icon 等。</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>SVG 可被非常多的工具读取和修改（比如记事本）。</li><li>SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。</li><li>SVG 是可伸缩的。</li><li>SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图）。</li><li>SVG 可以与 JavaScript 技术一起运行</li><li>SVG图形格式支持多种滤镜和特殊效果，在不改变图像内容的前提下可以实现位图格式中类似文字阴影的效果。</li><li>SVG图形格式可以用来动态生成图形。例如，可用 SVG 动态生成具有交互功能的地图，嵌入网页中，并显示给终端用户。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>渲染成本比较高，对于性能有影响。</li><li>SVG 的学习成本比较高，因为它是可编程的。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>1、高保真度复杂矢量文档已是并将继续是 SVG 的最佳点。它非常详细，适用于查看和打印，可以是独立的，也可以嵌入到网页中<br>2、在WEB项目中的平面图绘制，如需要绘制线，多边形，图片等。<br>3、数据可视化。</p><blockquote><p>SVG 只是 Web 开发常用的一种矢量图，其实矢量图常见还有几种格式：BW 格式、AI 格式、CDR 格式、ICO 格式。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文详细的介绍了常见的图片格式：GIF、JPEG、PNG、WebP、APNG、SVG，介绍了他们是什么，有什么用，优点和缺点，以及使用场景。由于图片相关的知识确实太多了，我只是把一些我觉得必要的写出来，下面在网上找到了一个选择图片过程的表格和图，下次不知道选择什么图片格式，直接看图就行。</p><p>其中 APNG 和 WebP 格式出现的较晚，尚未被 Web 标准所采纳，只有在特定平台或浏览器环境可以预知的情况下加以采用。图片格式选择过程如下：</p><table><thead><tr><th align="left">图片格式</th><th align="left">支持透明</th><th align="left">动画支持</th><th align="left">压缩方式</th><th align="left">浏览器支持</th><th align="left">相对原图大小</th><th align="left">适应场景</th></tr></thead><tbody><tr><td align="left">baseline-jpeg</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">有损</td><td align="left">所有</td><td align="left">由画质决定</td><td align="left">所有通用场景</td></tr><tr><td align="left">progressive-jpeg</td><td align="left">不支持</td><td align="left">不支持</td><td align="left">有损</td><td align="left">所有</td><td align="left">由画质决定</td><td align="left">所有通用场景, 渐进式加载</td></tr><tr><td align="left">gif</td><td align="left">支持</td><td align="left">支持</td><td align="left">无损</td><td align="left">所有</td><td align="left">由帧数和每帧图片大小决定</td><td align="left">简单颜色，动画</td></tr><tr><td align="left">png</td><td align="left">支持</td><td align="left">不支持</td><td align="left">无损</td><td align="left">所有</td><td align="left">由png色值位数决定</td><td align="left">需要透明时</td></tr><tr><td align="left">webp</td><td align="left">支持</td><td align="left">不支持</td><td align="left">有损和无损</td><td align="left">所有(除IE和Safari)</td><td align="left">由压缩率决定</td><td align="left">复杂颜色及形状，浏览器平台可预知</td></tr><tr><td align="left">apng</td><td align="left">支持</td><td align="left">支持</td><td align="left">无损</td><td align="left">所有(除IE 和Opera)</td><td align="left">由每帧图片决定</td><td align="left">需要半透明效果的动画</td></tr><tr><td align="left">svg</td><td align="left">支持</td><td align="left">支持</td><td align="left">无损</td><td align="left">所有(IE8以上)</td><td align="left">由内容和特效复杂度决定</td><td align="left">简单图形，需要良好的放缩体验，需要动态控制图片特效</td></tr></tbody></table><p><img src="http://imgs.taoweng.site/2019-06-08-075234.jpg"></p><h2 id="附加内容"><a href="#附加内容" class="headerlink" title="附加内容"></a>附加内容</h2><p>以下内容大多来自于网络，由于我在写这篇文章的过程中看到了这些，我觉得有必要了解一下，所以我将这些贴出来，跟文章内容关系不大，可以不看。</p><h3 id="位图图像属性"><a href="#位图图像属性" class="headerlink" title="位图图像属性"></a>位图图像属性</h3><p><strong>索引颜色/颜色表</strong></p><p>位图常用的一种压缩方法。从位图图片中选择最有代表性的若干种颜色（通常不超过256种）编制成颜色表，然后将图片中原有颜色用颜色表的索引来表示。这样原图片可以被大幅度有损压缩。适合于压缩网页图形等颜色数较少的图形，不适合压缩照片等色彩丰富的图形。</p><p><strong>Alpha通道</strong></p><p>在原有的图片编码方法基础上，增加像素的透明度信息。图形处理中，通常把 RGB 三种颜色信息称为红通道、绿通道和蓝通道，相应的把透明度称为 Alpha 通道。多数使用颜色表的位图格式都支持 Alpha 通道。</p><p><strong>色彩深度</strong></p><p>色彩深度又叫色彩位数，即位图中要用多少个二进制位来表示每个点的颜色，是分辨率的一个重要指标。常用有1位（单色），2位（4色，CGA），4位（16色，VGA），8位（256色），16位（增强色），24位（真彩色）和32位等。色深16位以上的位图还可以根据其中分别表示RGB三原色或CMYK四原色（有的还包括Alpha通道）的位数进一步分类，如16位位图图片还可分为R5G6B5，R5G5B5X1（有1位不携带信息），R5G5B5A1，R4G4B4A4等等。</p><ul><li>8位色，所谓8位色并不是图像只有8种颜色，而是2^8，即256种颜色，8位图指的是用8个bits来表示颜色；</li><li>16位色，2^16，从人眼的感觉来说，16位色基本可以满足视觉需要了；</li><li>24位色，又称为“真彩色”。大概有1600万之多，这个数字几乎是人类视觉可分辨颜色的极限；</li><li>32位色，并非 2^32, 其实也是 2^24 种颜色，不过它增加了2^8 阶颜色的灰度，也就是8位透明度，因此规定它为32位色。</li></ul><p>在制作网站页面图片的时候，设计者一般选择 24 位图像。32 位图像虽然质量更好，但同时也带来更大的图像体积（事实上，一般肉眼也很难分辨 24 位图和 32 位图的区别）。此外将原始位图放大与缩小都会使图像效果失真，这是因为它们减小了图像中有效像素的数量或密度的缘故，所以在制作过程中应尽量避免图片被编辑的次数。</p><h3 id="真彩色与伪彩色、直接色"><a href="#真彩色与伪彩色、直接色" class="headerlink" title="真彩色与伪彩色、直接色"></a>真彩色与伪彩色、直接色</h3><p> 描述一幅图像需要使用图像的属性。图像的属性包含分辨率、像素深度、真/伪彩色、图像的表示法和种类等。本节介绍前面三个特性。</p><p> 搞清真彩色、伪彩色与直接色的含义，对于编写图像显示程序、理解图像文件的存储格式有直接的指导意义，也不会对出现诸如这样的现象感到困惑：本来是用真彩色表示的图像，但在VGA显示器上显示的图像颜色却不是原来图像的颜色。</p><p>我这里就不以图形学的方式介绍各种花里胡哨的概念，我就用最简单的，作为一个程序员的角度来理解就行了。</p><p><strong>真彩色</strong></p><p>真彩色图像是一种用三个或更多字节描述像素的计算机图像存储方式。</p><p>一般来说，前三个通道都会各用一个字节表示，如红绿蓝（RGB）或者蓝绿红（BGR）。如果存在第四个字节，则表示该图像采用了 Alpha 通道。然而，实际系统往往用多于 8 位（即1字节）表达一个通道，如一个 48 位的<a href="https://baike.baidu.com/item/%E6%89%AB%E6%8F%8F%E4%BB%AA">扫描仪</a>等。这样的系统都统称为真彩色系统。</p><p><strong>伪彩色</strong></p><p>对于伪彩色图像其实可以理解为<strong>索引图像</strong>，他的每个像素值存储的不是直接的基色强度，而是存储的索引。就跟 js 里面的引用变量一样，变量只是个地址，变量所指向的值才是真正的值。</p><p>对于伪彩色图像会有一个<strong>颜色表</strong>，是一个[3，255] 的数组，分别对应 0~255 个灰度值的RGB值，对照原理如下：</p><p><img src="http://imgs.taoweng.site/2019-06-08-075236.jpg"></p><p>可以看到上图，像素值存储的只是索引号 128，根据索引找到的 RGB 值才是真正的基色强度。</p><p><strong>直接色</strong></p><p>直接色又称假彩色。它和伪彩色的区别就是，前者的每个基色强度都要通过索引找到真正的基色强度。</p><p><strong>小结</strong></p><p>直接色系统产生颜色与真彩色系统相比，相同之处是都采用R，G，B分量决定基色强度，不同之处是前者的基色强度直接用R，G，B决定，而后者的基色强度由R，G，B经变换后决定。因而这两种系统产生的颜色就有差别。试验结果表明，使用直接色在显示器上显示的彩色图像看起来真实、很自然。</p><p> 直接色系统与伪彩色系统相比，相同之处是都采用查找表，不同之处是前者对 R，G，B分量分别进行变换，后者是把整个像素当作查找表的索引值进行彩色变换。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.zhihu.com/question/20028452">图片格式 jpg、png、gif各有什么优缺点？什么情况下用什么格式的图片呢？</a></li><li><a href="https://blog.csdn.net/u013203733/article/details/73868180">真彩色与伪彩色、直接色的区别</a></li><li><a href="https://juejin.im/entry/58f8eb56b123db00623a6af8">10 个免费的图像压缩优化工具和脚本</a></li><li><a href="https://www.itcodemonkey.com/article/3002.html">网页中图片格式的选择</a></li></ul><p>最后欢迎大家关注我的公众号-「前端桃园」，我是桃翁。</p><p><img src="http://imgs.taoweng.site/2019-06-08-75237.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中肯的看待 996</title>
    <link href="/index.php/archives/267/"/>
    <url>/index.php/archives/267/</url>
    
    <content type="html"><![CDATA[<p>最近 <strong><a href="http://996.icu/">996.ICU</a></strong> 太火了。我本来不太想蹭这个热点，因为我的观念与很多人可能不相同，所以担心被骂，最近有读者问我为啥最近没有更新，最近我在准备晋升的事儿，所以也没怎么准备技术上的内容，但是对于 996 这件事儿上，我最近还是有很多想法，跟大家交流下吧！</p><blockquote><p> 后面我会将最近晋升的一些心得总结出来跟大家交流一下，毕竟涨工资呀，所以希望对大家有帮助。</p></blockquote><h2 id="一、反对-996-的本质原因"><a href="#一、反对-996-的本质原因" class="headerlink" title="一、反对 996 的本质原因"></a>一、反对 996 的本质原因</h2><p>为什么要反对 996，说到底，<strong>就是钱给的不够</strong>。</p><p>这句话可能说到了心坎里去，咱们来理一理这个逻辑。</p><p>如果，发工资不按照一个月一个月发，不按照一天一天的算，而是按照小时、或者分钟、甚至秒来算，你会不会愿意每天多工作一阵子。<br>加入你现在工资每个月 10000，那么每天的日薪差不多是 480 左右，一天八小时，时薪就是 60。你每多工作一小时就可以多得 60 块，如果你不是三和大神(不知道三和大神的搜索一下，不然你可能不太好理解)的话，你大概率不会只工作 8 个小时。</p><p>所以，我觉得说到底，反对的就是企业搞 996，加班不给加班工资导致的问题。</p><p>对于头条，阿里这样的企业，虽然知道他们加班很严重，但是工资高呀，所以很多人拼了命的想去。</p><blockquote><p>今天我在<strong>小道消息</strong>里看到这样一个观点，加班的时候不愿意加，看到别人拿年终奖拿得多又羡慕；自己体会这句话吧。</p></blockquote><h2 id="二、我的一些观点"><a href="#二、我的一些观点" class="headerlink" title="二、我的一些观点"></a>二、我的一些观点</h2><p>讨论完了本质，我再说一下我的一些观点。</p><p><strong>首先声明，我是极力反对 996 的。</strong>但是对于现在很多人的行为不是太赞同，所以写出来跟大家讨论下。</p><h3 id="1-不喜欢就走"><a href="#1-不喜欢就走" class="headerlink" title="1. 不喜欢就走"></a>1. 不喜欢就走</h3><p>在这场革命(说得似乎有点严重了)中，不少人想到终于有机会吐槽自己的公司了，垃圾公司，压迫员工，还搞 996。</p><p>对于这种行为我的观点是既然觉得在公司干得不爽，为何不走呢？</p><p>心里可能想着：我也想走呀，但是没其他公司要我咋办。</p><p>这种想法我感觉是一种弱者的态度，即表现出了自己弱，然后又抱怨现状。这种行为就像这样一群人，整天自己不努力，然后抱怨世界不公平，为什么我的爸爸不是王健林；为什么同一个老师教的，他的成绩那么好；为什么同一个班的，他的工作那么高；为什么一起进公司的，他为什么涨工资。</p><p>如果你有能力，不喜欢这个公司的制度，不能忍受 996，选择离开就行了呗。</p><blockquote><p>所以，提升自己，让自己变得更强，不喜欢就走。</p></blockquote><h3 id="2-其实我们已经很幸运了"><a href="#2-其实我们已经很幸运了" class="headerlink" title="2. 其实我们已经很幸运了"></a>2. 其实我们已经很幸运了</h3><p>作为程序员的我们，其实已经很幸运了，还有假期，还有双休，已经很不错了。有很多行业，根本没有休息，一年可能就只有过年的那几天会放，没错，我爸爸的职业就是这样，建筑工人，他们没有周末，没有节假日。</p><p>另外你在外面看到的环卫工人，外面开早餐店，饭店的，有过双休吗？</p><p>我说这点其实主要是想表达，我们应该少点抱怨，我们还是不错了，咱们让自己变得更强，多为社会做点有价值的事儿，让更多的人拥有双休，拥有节假日。这肯定不是取去革命能解决的事儿，不是去抵制资本家能干的事儿。</p><h3 id="3-多花时间来提升自己的工作效率"><a href="#3-多花时间来提升自己的工作效率" class="headerlink" title="3. 多花时间来提升自己的工作效率"></a>3. 多花时间来提升自己的工作效率</h3><p>说实话，大部分人工作时间的三分之一都没有为公司产生价值。</p><p>这三分之一的时间你可能会早上用来刷下咨询，各大群水一下，看看各大新闻网站等待。也许还会去抽抽烟，跟同事聊聊天，以及有一些时间你无法专心工作等。</p><p>当然，不可能有人做到每天都百分之百的投入，但是投入的比例就是人与人之间的差距，这是一个影响效率的地方。</p><p>众所周知，在公司级别比你高的，经验比你丰富的，代码敲得比你快，完成任务比你好，这肯定嘛，别人工资拿得也高，所以干活也多。反过来也成立，活干得多，工资拿得高。你给公司创造的价值越大，那么你就应该拿更多的工资，后面我将晋升也会说到这个。</p><p>所以我们已经想办法提高自己的工作效率，在一定的事件内干更多的活，那么你就需要提高自己的能力，这样你就能在规定的事件内完成任务，当然就不需要加班了。</p><p>可能有人说，公司就是给你的任务是无论怎么做都做不完的，那么这种公司对于资源不合理安排，你可以选择第一点，不喜欢，咱就走。</p><h2 id="三、这件事情我思考了哪些？"><a href="#三、这件事情我思考了哪些？" class="headerlink" title="三、这件事情我思考了哪些？"></a>三、这件事情我思考了哪些？</h2><p>我在跟我周围讨论相关话题的时候，我感觉我思考的问题跟他们不同。比如：</p><ol><li>为什么这个仓库，或者说这个网站会传播得这么快？在最开始的几十，几百颗 star 是怎么来的？为什么同样类似的项目，godie996(方应杭的项目，地址是：<a href="https://godie996.com)没有火起来呢？当时我们讨论了两个原因：一个是各大群的宣传，另一个是">https://godie996.com)没有火起来呢？当时我们讨论了两个原因：一个是各大群的宣传，另一个是</a> 996.ICU 界面做得好看。另外的原因供大家思考，欢迎在评论区给出你的答案。</li><li>为什么那么多人不满意自己的公司，而不选择离开呢？</li><li>为什么会这么多公司会搞 996 呢？</li><li>同样是互联网公司，为什么国外的大厂不搞 996 呢？</li></ol><p>等等很多问题我觉得才是我们应该去思考的地方，我们只有去思源，才能从根本上解决问题，从表面现象去解决问题很多时候会走很多弯路。</p><p>对于这个我举个例子，古代的铁匠都知道<strong>百炼成钢</strong>，把铁红了，然后拿出来锤，然后又拿进去烧，反复几次，就会发现做出来的铁具很硬，但是不知道为什么，其实就是因为铁里面融入了炭。所以近现代的就直接在熔铁的过程中加入炭，就不需要反复锤炼了。</p><p>我们如果掌握不了一个东西的本质，掌握不了终极大道，就会在表面兜圈子。</p><p>本文完，希望能与君共勉，能给你带来启发。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么现在面试都是面试造火箭</title>
    <link href="/index.php/archives/268/"/>
    <url>/index.php/archives/268/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章首发于个人网站：<a href="http://www.taoweng.site/index.php/">前端桃园</a></p></blockquote><p>很多人总是抱怨面试官问一些平时不常用的知识点，比如算法呀，网络(TCP)等等，也就是大家常说的：面试造火箭，工作拧螺丝。</p><p>但是有没有想过为什么整个前端圈，或者绝大部分面试，不仅是前端，各种职位都是这样呢？难道就没人来解决这个问题吗？</p><p>我觉得，事实上，这是一种合理的行为，并不是因为存在即合理，而是本来就应该这样，接下来我以两个方面阐述我的观点。</p><h2 id="一、-考验对专业知识的掌握的扎实程度"><a href="#一、-考验对专业知识的掌握的扎实程度" class="headerlink" title="一、 考验对专业知识的掌握的扎实程度"></a>一、 考验对专业知识的掌握的扎实程度</h2><p>在张鑫旭的<a href="%5Bhttps://www.zhangxinxu.com/wordpress/2017/06/ten-question-about-frontend-zhihu/%5D(https://www.zhangxinxu.com/wordpress/2017/06/ten-question-about-frontend-zhihu/)">十问十答</a>里的一个问题是，「前端开发基础扎实的标准是什么？」</p><p>这里面他对「扎实」的解释我觉得很适合来答这个问题。</p><p>「扎」其实可以理解为深度，你可以想象一个用一根针，扎你的皮肤，对一个点的压力，可以让你痛不欲生。</p><p>那么如何理解知识的深度呢？</p><p>我还是拿前端面试来举例，比如考一个快速排序，很多人就觉得这有什么好考的嘛，平时又用不到，引擎底层已经写好了 sort 方法，什么数量级用什么排序底层也已经实现好了，没必要考了呀。</p><p>但是其实面试官并不是想考你快排的代码是如何写的，说实话，花个十分钟，最多半小时，一个快排的代码你肯定可以记住。但是其实考察快排的真正原因可能不仅仅是考察代码，而是考察它的思想，分而治之(分治法)，划分算法的运用。</p><p>另外可能会再问你，它的时间复杂度是多少，如何计算等这些问题，这些问题也不是来考你这一个算法的计算，而是通过这一个算法来看你知道怎么算时间复杂度不？以此来引导你为什么快速排序快，为什么同样是分治法的归并排序没有这么快。等等相关的算法方面的知识。</p><p>面试官所考察的问题只是各种底层思想的一个运用，通过这个实例应用来考察对底层思想的理解程度。所以很多时候大厂的面试总是从浅入深的问问题，直到把你问到不知道为止。</p><p>再谈谈「实」，实则可以理解为满，考察知识的广度。</p><p>想象一下什么样的情况你才会说一个东西实，给你一晚装满的米饭，并且还压一压，再放进去一些米饭，直到压不下去了为止，这个时候你会说满满的一晚米饭，很实在。</p><p>所以对「实」的理解就可以理解为满，全。</p><p>如何来体现你对知识的广度呢，也就是实。</p><p>比如可以考察一些你平时不常用的，但是你也许会用到的知识点。比如一些简单的算法和数据结构，链表呀，网络里面的 tcp/ip 协议族呀，函数式编程呀等等，一些 html5 的特性(比如 web-compoennt)等等。</p><p>你可能在平时编程中没用到，或者大多数前端工程师平时不会用到，但是这些是基本功是需要知道的，比如 React 源码中就用到一些简单的数据结构，链表(Fiber 树就是用链表的结构存的，是一个单链表，以及里面还有循环列表的增删改查)，如果不知道树可以用链表存，如何对链表进行操作，那么可能你看源码就很成问题。里面还有一些位运算等，位运算平时也不常用吧，但是 fb 的工程师就用它来解决实际问题。</p><p>再比如 web-component，这已经是 w3c 提出的一个前端组件化的标准了，我国也有大佬用 web-component 实现了一些库，比如腾讯出的 OMI。</p><blockquote><p>地址： <a href="https://github.com/Tencent/omi">https://github.com/Tencent/omi</a></p></blockquote><p>所以狼叔在 「2019 大前端技术趋势深度解读」里提到可能他是下一代框架的标准。</p><p>我们前端变化得快，新东西也多，如何不跟上时代，多了解(主要了解，不是每个新东西都要去深究，因为你没那么多时间，大多数时间还是要用在平时用得到的地方)一些新东西。跟不上时代，也行就会慢慢的被淘汰，所以现在前端招聘基本上都会需要你会一门框架，不管是 React 、Vue、Angular，这些都是趋势，数据驱动，不再是以前拿起 jQuery 就是干了。</p><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>在工作中常用的知识点，那些是最重要的，那么大家都会这些，<strong>如果你不知道点，别人不知道的东西，这些东西比别人掌握得更深一点，面试官为什么要你？</strong>也许你还是个双非（非982、211）。</p><p>我觉得在任何领域都适合一个定律，就是「T」字形发展，先把专业搞深一点，然后往两边扩展。</p><h2 id="二、醉翁之意不在题"><a href="#二、醉翁之意不在题" class="headerlink" title="二、醉翁之意不在题"></a>二、醉翁之意不在题</h2><p>另外面试官也许会考你一些软技能，考你的不仅仅是面试题完成了那么简单。这点注意，<strong>越简单的题越不简单</strong>(好好理解这句话)。</p><p>我拿我自己的经历来举例，之前做小米的笔试题(是那种把题目发给你，两天内做好了发给他)的时候，有一道题是：求最大公约数的题目。</p><p>很多人看到这道题觉得很简单嘛，几行代码就搞定了，当时跟我一起做笔试题的几位竞争者也是，他们就写了一个算法。</p><p>而我当时想到，我觉得面试官在检查这道题的时候如果看代码还是有点麻烦，所以我就写了一个界面，界面上提供了可以点击的数字，还有输入框，还有几个计算按钮，一个结果框，用户可以通过点击数字，或者在输入框里输入数字进行计算最大公约数，还做了一些错误提示等。</p><p>这相当于做了一个应用，一个可以给用户使用的应用，所以最后因为这道题，我被录取了。</p><blockquote><p>我被录取的原因，这些都是进去之后，老大告诉我的，当时很惊讶，竟然是因为这个。</p></blockquote><p>所以之后我就越来越注重用户体验，多一些思考，让别人用自己做的东西的时候更舒服，更方便。</p><h2 id="我期望的面试官"><a href="#我期望的面试官" class="headerlink" title="我期望的面试官"></a>我期望的面试官</h2><blockquote><p>声明：我没当过面试官，所以以上内容大多是我思考(猜测)的，也可以用说用一种合理的解释，来解释了现在这种现象。</p></blockquote><p>我期望的面试官是这样的，或者说如果我以后当了面试官我会怎么做。</p><ol><li>作为面试官不是把面试者考倒，而是尽量挖掘面试者擅长的地方，然后去打破砂锅问到底的看对擅长的地方研究有多深，考察深度。</li><li>在考察的时候先考察广度，再考察深度，从广度的问题中提取擅长的点，然后再问下去。</li></ol><h2 id="一些小提示"><a href="#一些小提示" class="headerlink" title="一些小提示"></a>一些小提示</h2><ol><li>一般面试官不会因为你某道题没答出来就否定你的。</li><li>面试官不喜欢简历上写的啥都会，一问每个知识点都掌握得很浅。</li><li>对于平时常用的框架，至少要知道核心原理。</li></ol><p>这些是之前我们组面试官在讨论的时候提到的，希望能给大家帮助。</p><p>我是桃翁，一个爱思考的前端er，想了解关于更多的面试相关的，请关注我的公号：前端桃园</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程之组合</title>
    <link href="/index.php/archives/253/"/>
    <url>/index.php/archives/253/</url>
    
    <content type="html"><![CDATA[<blockquote><p>该系列文章不是针对前端新手，需要有一定的编程经验，而且了解 JavaScript 里面作用域，闭包等概念</p></blockquote><h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><p>组合是一种为软件的行为，进行清晰建模的一种简单、优雅而富于表现力的方式。通过组合小的、确定性的函数，来创建更大的软件组件和功能的过程，会生成更容易组织、理解、调试、扩展、测试和维护的软件。</p><p>对于组合，我觉得是函数式编程里面最<strong>精髓</strong>的地方之一，所以我迫不及待的把这个概念拿出来先介绍，因为在整个学习函数式编程里，所遇到的基本上都是以组合的方式来编写代码，这也是改变你从一个面向对象，或者结构化编程思想的一个关键点。</p><p>我这里也不去证明组合比继承好，也不说组合的方式写代码有多好，我希望你看了这篇文章能知道<strong>以组合的方式去抽象代码</strong>，这会扩展你的视野，在你想重构你的代码，或者想写出更易于维护的代码的时候，提供一种思路。</p><p>组合的概念是非常直观的，并不是函数式编程独有的，在我们生活中或者前端开发中处处可见。</p><p>比如我们现在流行的 SPA (单页面应用)，都会有组件的概念，为什么要有组件的概念呢，因为它的目的就是想让你<strong>把一些通用的功能或者元素组合抽象成可重用的组件</strong>，就算不通用，你在构建一个复杂页面的时候也可以拆分成一个个具有简单功能的组件，然后再组合成你满足各种需求的页面。</p><p>其实我们函数式编程里面的组合也是类似，函数组合<strong>就是一种将已被分解的简单任务组织成复杂的整体过程</strong>。</p><p>现在我们有这样一个需求：给你一个字符串，将这个字符串转化成大写，然后逆序。</p><p>你可能会这么写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 例 1.1</span><br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;function program&#x27;</span><br><br><span class="hljs-comment">// 一行代码搞定</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">oneLine</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> res = str.toUpperCase().split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 或者 按要求一步一步来，先转成大写，然后逆序</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiLine</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> upperStr = str.toUpperCase()<br>    <span class="hljs-keyword">var</span> res = upperStr.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(oneLine(str)) <span class="hljs-comment">// MARGORP NOITCNUF</span><br><span class="hljs-built_in">console</span>.log(multiLine(str)) <span class="hljs-comment">// MARGORP NOITCNUF</span><br></code></pre></td></tr></table></figure><p>可能看到这里你并没有觉得有什么不对的，但是现在产品又突发奇想，改了下需求，把字符串大写之后，把每个字符拆开之后组装成一个数组，比如 ’aaa‘ 最终会变成 [A, A, A]。</p><p>那么这个时候我们就需要更改我们之前我们封装的函数。这就修改了以前封装的代码，其实在设计模式里面就是破坏了开闭原则。</p><p>那么我们如果把最开始的需求代码写成这个样子，以函数式编程的方式来写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 例 1.2</span><br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;function program&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToUpper</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toUpperCase()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringReverse</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> toUpperAndReverse = 组合(stringReverse, stringToUpper)<br><span class="hljs-keyword">var</span> res = toUpperAndReverse(str)<br></code></pre></td></tr></table></figure><p>那么当我们需求变化的时候，我们根本不需要修改之前封装过的东西。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 例 2</span><br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;function program&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToUpper</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toUpperCase()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringReverse</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">// var toUpperAndReverse = 组合(stringReverse, stringToUpper)</span><br><span class="hljs-comment">// var res = toUpperAndReverse(str)</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToArray</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> toUpperAndArray = 组合(stringReverse, stringToUpper)<br>toUpperAndArray(str)<br></code></pre></td></tr></table></figure><p>可以看到当变更需求的时候，我们没有打破以前封装的代码，只是新增了函数功能，然后把函数进行重新组合。</p><blockquote><p>这里可能会有人说，需求修改，肯定要更改代码呀，你这不是也删除了以前的代码么，也不是算破坏了开闭原则么。我这里声明一下，开闭原则是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。是针对我们封装，抽象出来的代码，而是调用逻辑。所以这样写并不算破坏开闭原则。</p></blockquote><p>突然产品又灵光一闪，又想改一下需求，把字符串大写之后，再翻转，再转成数组。</p><p>要是你按照以前的思考，没有进行抽象，你肯定心理一万只草泥马在奔腾，但是如果你抽象了，你完全可以不慌。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 例 3</span><br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;function program&#x27;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToUpper</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toUpperCase()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringReverse</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToArray</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> strUpperAndReverseAndArray = 组合(stringToArray, stringReverse, stringToUpper)<br>strUpperAndReverseAndArray(str)<br></code></pre></td></tr></table></figure><p>发现并没有更换你之前封装的代码，只是更换了函数的组合方式。可以看到，组合的方式是真的就是抽象单一功能的函数，然后再组成复杂功能。这种方式既锻炼了你的抽象能力，也给维护带来巨大的方便。</p><p>但是上面的组合我只是用汉字来代替的，我们应该如何去实现这个组合呢。首先我们可以知道，这是一个函数，同时参数也是函数，返回值也是函数。</p><p>我们看到例 2， 怎么将两个函数进行组合呢，根据上面说的，参数和返回值都是函数，那么我们可以确定函数的基本结构如下(顺便把组合换成英文的 compose)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoFuntionCompose</span>(<span class="hljs-params">fn1, fn2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// code</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再思考一下，如果我们不用 compose 这个函数，在例 2 中怎么将两个函数合成呢，我们是不是也可以这么做来达到组合的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> res = stringReverse(stringToUpper(str))<br></code></pre></td></tr></table></figure><p>那么按照这个逻辑是不是我们就可以写出 <code>twoFuntonCompose</code> 的实现了，就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoFuntonCompose</span>(<span class="hljs-params">fn1, fn2</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> fn1(fn2(arg))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同理我们也可以写出三个函数的组合函数，四个函数的组合函数，无非就是一直嵌套多层嘛，变成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiFuntionCompose</span>(<span class="hljs-params">fn1, fn2, .., fnn</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> fnn(...(fn1(fn2(arg))))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种恶心的方式很显然不是我们程序员应该做的，然后我们也可以看到一些规律，无非就是把前一个函数的返回值作为后一个返回值的参数，当直接到最后一个函数的时候，就返回。</p><p>所以按照正常的思维就会这么写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">aCompose</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> length = args.length<br>    <span class="hljs-keyword">let</span> count = length - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> result<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span> (<span class="hljs-params">...arg1</span>) </span>&#123;<br>        result = args[count].apply(<span class="hljs-built_in">this</span>, arg1)<br>        <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>          count = length - <span class="hljs-number">1</span><br>          <span class="hljs-keyword">return</span> result<br>        &#125;<br>        count--<br>        <span class="hljs-keyword">return</span> f1.call(<span class="hljs-literal">null</span>, result)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写没问题，underscore 也是这么写的，不过里面还有很多健壮性的处理，核心大概就是这样。</p><p>但是作为一个函数式爱好者，尽量还是以函数式的方式去思考，所以就用 reduceRight 写出如下代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> args.reduceRight(<span class="hljs-function">(<span class="hljs-params">result, fn</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> fn(result)<br>        &#125;, result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然对于 compose 的实现还有很多种方式，在这篇<a href="https://segmentfault.com/a/1190000011447164">实现 compose 的五种思路</a>中还给出了另外脑洞大开的实现方式，在我看这篇文章之前，另外三种我是没想到的，不过感觉也不是太有用，但是可以扩展我们的思路，有兴趣的同学可以看一看。</p><blockquote><p>注意：要传给 compose 函数是有规范的，首先函数的执行是从最后一个参数开始执行，一直执行到第一个，而且对于传给 compose 作为参数的函数也是有要求的，必须只有一个形参，而且函数的返回值是下一个函数的实参。</p></blockquote><p>对于 compose 从最后一个函数开始求值的方式如果你不是很适应的话，你可以通过 pipe 函数来从左到右的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pipe</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">result, fn</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">return</span> fn(result)<br>        &#125;, result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现跟 compose 差不多，只是把参数的遍历方式从右到左(<strong>reduceRight</strong>)改为从左到右(<strong>reduce</strong>)。</p><p>之前是不是看过很多文章写过如何实现 compose，或者柯里化，部分应用等函数，但是你可能不知道是用来干啥的，也没用过，所以记了又忘，忘了又记，看了这篇文章之后我希望这些你都可以轻松实现。后面会继续讲到柯里化和部分应用的实现。</p><h2 id="point-free"><a href="#point-free" class="headerlink" title="point-free"></a>point-free</h2><p>在函数式编程的世界中，有这样一种很流行的编程风格。这种风格被称为 <strong>tacit programming</strong>，也被称作为 <strong>point-free</strong>，point 表示的就是形参，意思大概就是没有形参的编程风格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这就是有参的，因为 word 这个形参</span><br><span class="hljs-keyword">var</span> snakeCase = <span class="hljs-function"><span class="hljs-params">word</span> =&gt;</span> word.toLowerCase().replace(<span class="hljs-regexp">/\s+/ig</span>, <span class="hljs-string">&#x27;_&#x27;</span>);<br><br><span class="hljs-comment">// 这是 pointfree，没有任何形参</span><br><span class="hljs-keyword">var</span> snakeCase = compose(replace(<span class="hljs-regexp">/\s+/ig</span>, <span class="hljs-string">&#x27;_&#x27;</span>), toLowerCase);<br></code></pre></td></tr></table></figure><p>有参的函数的目的是得到一个数据，而 pointfree 的函数的目的是得到另一个函数。</p><p>那这 pointfree 有什么用？ 它可以让我们把注意力集中在函数上，参数命名的麻烦肯定是省了，代码也更简洁优雅。 需要注意的是，一个 pointfree 的函数可能是由众多非 pointfree 的函数组成的，也就是说底层的基础函数大都是有参的，pointfree 体现在用基础函数组合而成的高级函数上，这些高级函数往往可以作为我们的业务函数，通过组合不同的基础函数构成我们的复制的业务逻辑。</p><p>可以说 pointfree 使我们的编程看起来更美，更具有声明式，这种风格算是函数式编程里面的一种追求，一种标准，我们可以尽量的写成 pointfree，但是不要过度的使用，任何模式的过度使用都是不对的。</p><p>另外可以看到通过 compose 组合而成的基础函数都是只有一个参数的，但是往往我们的基础函数参数很可能不止一个，这个时候就会用到一个神奇的函数(柯里化函数)。</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>在维基百科里面是这么定义柯里化的：</p><blockquote><p> 在计算机科学，<strong>柯里化</strong>（英语：Currying），又译为<strong>卡瑞化</strong>或<strong>加里化</strong>，是把接受多个<a href="https://zh.wikipedia.org/w/index.php?title=%E5%BD%A2%E5%BC%8F%E5%8F%82%E6%95%B0&action=edit&redlink=1">参数</a>的<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>变换成<strong>接受一个单一参数（最初函数的第一个参数）的函数</strong>，并且返回接受余下的参数而且<strong>返回结果的新函数</strong>的技术。</p></blockquote><p>在定义中获取两个比较重要的信息：</p><ul><li>接受一个单一参数</li><li>返回结果是函数</li></ul><p>这两个要点不是 compose 函数参数的要求么，而且可以将多个参数的函数转换成接受单一参数的函数，岂不是可以解决我们再上面提到的基础函数如果是多个参数不能用的问题，所以这就很清楚了柯里化函数的作用了。</p><p>柯里化函数可以使我们更好的去追求 pointfree，让我们代码写得更优美！</p><p>接下来我们具体看一个例子来理解柯里化吧：</p><p>比如你有一间士多店并且你想给你优惠的顾客给个 10% 的折扣（即打九折）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discount</span>(<span class="hljs-params">price, discount</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> price * discount<br>&#125;<br></code></pre></td></tr></table></figure><p>当一位优惠的顾客买了一间价值$500的物品，你给他打折：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">500</span>, <span class="hljs-number">0.10</span>); <span class="hljs-comment">// $50 </span><br></code></pre></td></tr></table></figure><p>你可以预见，从长远来看，我们会发现自己每天都在计算 10% 的折扣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">1500</span>,<span class="hljs-number">0.10</span>); <span class="hljs-comment">// $150</span><br><span class="hljs-keyword">const</span> price = discount(<span class="hljs-number">2000</span>,<span class="hljs-number">0.10</span>); <span class="hljs-comment">// $200</span><br><span class="hljs-comment">// ... 等等很多</span><br></code></pre></td></tr></table></figure><p>我们可以将 discount 函数柯里化，这样我们就不用总是每次增加这 0.01 的折扣。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个就是一个柯里化函数，将本来两个参数的 discount ，转化为每次接收单个参数完成求职</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">discountCurry</span>(<span class="hljs-params">discount</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">price</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> price * discount;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> tenPercentDiscount = discountCurry(<span class="hljs-number">0.1</span>);<br></code></pre></td></tr></table></figure><p>现在，我们可以只计算你的顾客买的物品都价格了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">tenPercentDiscount(<span class="hljs-number">500</span>); <span class="hljs-comment">// $50</span><br><br></code></pre></td></tr></table></figure><p>同样地，有些优惠顾客比一些优惠顾客更重要-让我们称之为超级客户。并且我们想给这些超级客户提供20%的折扣。<br>可以使用我们的柯里化的discount函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> twentyPercentDiscount = discountCurry(<span class="hljs-number">0.2</span>);<br><br></code></pre></td></tr></table></figure><p>我们通过这个柯里化的 discount 函数折扣调为 0.2（即20%），给我们的超级客户配置了一个新的函数。<br>返回的函数 twentyPercentDiscount 将用于计算我们的超级客户的折扣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">twentyPercentDiscount(<span class="hljs-number">500</span>); <span class="hljs-comment">// 100</span><br><br></code></pre></td></tr></table></figure><p>我相信通过上面的 **discountCurry **你已经对柯里化有点感觉了，这篇文章是谈的柯里化在函数式编程里面的应用，所以我们再来看看在函数式里面怎么应用。</p><p>现在我们有这么一个需求：给定的一个字符串，先翻转，然后转大写，找是否有<code>TAOWENG</code>，如果有那么就输出 yes，否则就输出 no。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringToUpper</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toUpperCase()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stringReverse</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">find</span>(<span class="hljs-params">str, targetStr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> str.includes(targetStr)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">judge</span>(<span class="hljs-params">is</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(is ? <span class="hljs-string">&#x27;yes&#x27;</span> : <span class="hljs-string">&#x27;no&#x27;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们很容易就写出了这四个函数，前面两个是上面就已经写过的，然后 find 函数也很简单，现在我们想通过 compose 的方式来实现 pointfree，但是我们的 find 函数要接受两个参数，不符合 compose 参数的规定，这个时候我们像前面一个例子一样，把 find 函数柯里化一下，然后再进行组合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 柯里化 find 函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findCurry</span>(<span class="hljs-params">targetStr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> str.includes(targetStr)<br>&#125;<br><br><span class="hljs-keyword">const</span> findTaoweng = findCurry(<span class="hljs-string">&#x27;TAOWENG&#x27;</span>)<br><br><span class="hljs-keyword">const</span> result = compose(judge, findTaoweng, stringReverse, stringToUpper)<br><br></code></pre></td></tr></table></figure><p>看到这里是不是可以看到柯里化在达到 pointfree 是非常的有用，较少参数，一步一步的实现我们的组合。</p><p>但是通过上面那种方式柯里化需要去修改以前封装好的函数，这也是破坏了<strong>开闭原则</strong>，而且对于一些基础函数去把源码修改了，其他地方用了可能就会有问题，所以我们应该写一个函数来手动柯里化。</p><p>根据定义之前对柯里化的定义，以及前面两个柯里化函数，我们可以写一个二元(参数个数为 2)的通用柯里化函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">twoCurry</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstArg</span>) </span>&#123; <span class="hljs-comment">// 第一次调用获得第一个参数</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">secondArg</span>) </span>&#123; <span class="hljs-comment">// 第二次调用获得第二个参数</span><br>            <span class="hljs-keyword">return</span> fn(firstArg, secondArg) <span class="hljs-comment">// 将两个参数应用到函数 fn 上</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以上面的 findCurry 就可以通过 twoCurry 来得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> findCurry = twoCurry(find)<br><br></code></pre></td></tr></table></figure><p>这样我们就可以不更改封装好的函数，也可以使用柯里化，然后进行函数组合。不过我们这里只实现了二元函数的柯里化，要是三元，四元是不是我们又要要写三元柯里化函数，四元柯里化函数呢，其实我们可以写一个通用的 n 元柯里化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) &#123;<br>        <span class="hljs-keyword">return</span> fn(...args)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> currying(fn, ...args, ...args2)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我这里采用的是递归的思路，当获取的参数个数大于或者等于 fn 的参数个数的时候，就证明参数已经获取完毕，所以直接执行 fn 了，如果没有获取完，就继续递归获取参数。</p><p>可以看到其实一个通用的柯里化函数核心思想是非常的简单，代码也非常简洁，而且还支持在一次调用的时候可以传多个参数(但是这种传递多个参数跟柯里化的定义不是很合，所以可以作为一种柯里化的变种)。</p><blockquote><p>我这里重点不是讲柯里化的实现，所以没有写得很健壮，更强大的柯里化函数可见羽讶的：<a href="https://segmentfault.com/a/1190000010608477">JavaScript专题之函数柯里化</a>。</p></blockquote><h2 id="部分应用"><a href="#部分应用" class="headerlink" title="部分应用"></a>部分应用</h2><p>部分应用是一种通过将函数的不可变参数子集，初始化为固定值来创建更小元数函数的操作。简单来说，如果存在一个具有五个参数的函数，给出三个参数后，就会得到一个、两个参数的函数。</p><p>看到上面的定义可能你会觉得这跟柯里化很相似，都是用来缩短函数参数的长度，所以如果理解了柯里化，理解部分应用是非常的简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debug</span>(<span class="hljs-params">type, firstArg, secondArg</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(type === <span class="hljs-string">&#x27;log&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.log(firstArg, secondArg)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">&#x27;info&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.info(firstArg, secondArg)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">&#x27;warn&#x27;</span>) &#123;<br>        <span class="hljs-built_in">console</span>.warn(firstArg, secondArg)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.error(firstArg, secondArg)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> logDebug = 部分应用(debug, <span class="hljs-string">&#x27;log&#x27;</span>)<br><span class="hljs-keyword">const</span> infoDebug = 部分应用(debug, <span class="hljs-string">&#x27;info&#x27;</span>)<br><span class="hljs-keyword">const</span> warnDebug = 部分应用(debug, <span class="hljs-string">&#x27;warn&#x27;</span>)<br><span class="hljs-keyword">const</span> errDebug = 部分应用(debug, <span class="hljs-string">&#x27;error&#x27;</span>)<br><br>logDebug(<span class="hljs-string">&#x27;log:&#x27;</span>, <span class="hljs-string">&#x27;测试部分应用&#x27;</span>)<br>infoDebug(<span class="hljs-string">&#x27;info:&#x27;</span>, <span class="hljs-string">&#x27;测试部分应用&#x27;</span>)<br>warnDebug(<span class="hljs-string">&#x27;warn:&#x27;</span>, <span class="hljs-string">&#x27;测试部分应用&#x27;</span>)<br>errDebug(<span class="hljs-string">&#x27;error:&#x27;</span>, <span class="hljs-string">&#x27;测试部分应用&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><code>debug</code>方法封装了我们平时用 console 对象调试的时候各种方法，本来是要传三个参数，我们通过<strong>部分应用</strong>的封装之后，我们只需要根据需要调用不同的方法，传必须的参数就可以了。</p><p>我这个例子可能你会觉得没必要这么封装，根本没有减少什么工作量，但是如果我们在 debug 的时候不仅是要打印到控制台，还要把调试信息保存到数据库，或者做点其他的，那是不是这个封装就有用了。</p><p>因为部分应用也可以减少参数，所以他在我们进行编写组合函数的时候也占有一席之地，而且可以更快传递需要的参数，留下为了 compose 传递的参数，这里是跟柯里化比较，因为柯里化按照定义的话，一次函数调用只能传一个参数，如果有四五个参数就需要:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b, c, d</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c +d<br>&#125;<br><br><span class="hljs-comment">// 使用柯里化方式来使 add 转化为一个一元函数</span><br><span class="hljs-keyword">let</span> addPreThreeCurry = currying(add)(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br>addPreThree(<span class="hljs-number">4</span>) <span class="hljs-comment">// 10</span><br><br></code></pre></td></tr></table></figure><p> 这种连续调用(这里所说的柯里化是按照定义的柯里化，而不是我们写的柯里化变种)，但是用部分应用就可以:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用部分应用的方式使 add 转化为一个一元函数</span><br><span class="hljs-keyword">const</span> addPreThreePartial = 部分应用(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>addPreThree(<span class="hljs-number">4</span>) <span class="hljs-comment">// 10</span><br><br></code></pre></td></tr></table></figure><p>既然我们现在已经明白了部分应用这个函数的作用了，那么还是来实现一个吧，真的是非常的简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通用的部分应用函数的核心实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">..._arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> fn(...args, ..._arg);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>另外不知道你有没有发现，这个部分应用跟 JavaScript 里面的 bind 函数很相似，都是把第一次穿进去的参数通过闭包存在函数里，等到再次调用的时候再把另外的参数传给函数，只是部分应用不用指定 this，所以也可以用 bind 来实现一个部分应用函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通用的部分应用函数的核心实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> fn.bind(<span class="hljs-literal">null</span>, ...args)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>另外可以看到实际上柯里化和部分应用确实很相似，所以这两种技术很容易被混淆。它们主要的区别在于参数传递的内部机制与控制：</p><ul><li>柯里化在每次分布调用时都会生成嵌套的一元函数。在底层 ，函数的最终结果是由这些一元函数<strong>逐步组合</strong>产生的。同时，curry 的变体允许同时传递一部分参数。因此，可以完全控制函数<strong>求值的时间与方式</strong>。</li><li>部分应用将函数的参数与一些预设值绑定(赋值)，从而产生一个拥有<strong>更少参数的新函数</strong>。改函数的闭包中包含了这些已赋值的参数，在之后的调用中被完全求值。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章里我重点想介绍的是函数以组合的方式来完成我们的需求，另外介绍了一种函数式编程风格：pointfree，让我们在函数式编程里面有了一个最佳实践，尽量写成 pointfree 形式(尽量，不是都要)，然后介绍了通过柯里化或者部分应用来减少函数参数，符合 compose 或者 pipe 的参数要求。</p><p>所以这种文章的重点是理解我们如何去组合函数，如何<strong>去抽象复杂的函数为颗粒度更小，功能单一的函数</strong>。这将使我们的代码更容易维护，更具声明式的特点。</p><blockquote><p>对于这篇文章里面提到的其他概念：闭包、作用域，然后柯里化的其他用途我希望是在番外篇里面更深入的去理解，而这篇文章主要掌握函数组合就行了。</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://yq.aliyun.com/articles/617808">JavaScript函数式编程之pointfree与声明式编程</a></li><li><a href="https://blog.bitsrc.io/understanding-currying-in-javascript-ceb2188c339">Understanding Currying in JavaScript</a></li><li>《JavaScript 函数式编程指南》</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pm2 使用教程</title>
    <link href="/index.php/archives/238/"/>
    <url>/index.php/archives/238/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PM2 是 node 进程管理工具，可以利用它来简化很多 node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g pm2<br></code></pre></td></tr></table></figure><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 start app.js<br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>参数说明：</p><ul><li><code>--watch</code>：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。</li><li><code>-i --instances</code>：启用多少个实例，可用于负载均衡。如果<code>-i 0</code>或者<code>-i max</code>，则根据当前机器核数确定实例数目。</li><li><code>--ignore-watch</code>：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如<code>--ignore-watch=&quot;test node_modules &quot;some scripts&quot;&quot;</code></li><li><code>-n --name</code>：应用的名称。查看应用信息的时候可以用到。</li><li><code>-o --output &lt;path&gt;</code>：标准输出日志文件的路径。</li><li><code>-e --error &lt;path&gt;</code>：错误输出日志文件的路径。</li><li><code>--interpreter &lt;interpreter&gt;</code>：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。</li></ul><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 restart app.js<br></code></pre></td></tr></table></figure><h3 id="3-3-停止"><a href="#3-3-停止" class="headerlink" title="3.3 停止"></a>3.3 停止</h3><p>停止特定的应用。可以先通过<code>pm2 list</code>获取应用的名字（–name指定的）或者进程id。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 stop app_name|app_id<br></code></pre></td></tr></table></figure><p>如果要停止所有应用，可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 stop all<br></code></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><p>类似<code>pm2 stop</code>，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 stop app_name|app_id<br>pm2 stop all<br></code></pre></td></tr></table></figure><h3 id="从进程列表删除进程"><a href="#从进程列表删除进程" class="headerlink" title="从进程列表删除进程"></a>从进程列表删除进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// pm2 delete [appname] | id<br>pm2 delete app  // 指定进程名删除<br>pm2 delete 0    // 指定进程id删除<br></code></pre></td></tr></table></figure><h3 id="删除进程列表中所有进程"><a href="#删除进程列表中所有进程" class="headerlink" title="删除进程列表中所有进程"></a>删除进程列表中所有进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 delete all<br></code></pre></td></tr></table></figure><h3 id="查看进程状态"><a href="#查看进程状态" class="headerlink" title="查看进程状态"></a>查看进程状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 list<br>// 或者<br>pm2 ls<br></code></pre></td></tr></table></figure><h3 id="查看某个进程的信息"><a href="#查看某个进程的信息" class="headerlink" title="查看某个进程的信息"></a>查看某个进程的信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 describe 0<br></code></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>命令如下，表示开启三个进程。如果<code>-i 0</code>，则会根据机器当前核数自动开启尽可能多的进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 start app.js -i 3 <span class="hljs-comment"># 开启三个进程</span><br>pm2 start app.js -i max <span class="hljs-comment"># 根据机器CPU核数，开启对应数目的进程 </span><br></code></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><p>除了可以打开日志文件查看日志外，还可以通过<code>pm2 logs</code>来查看实时日志。这点对于线上问题排查非常重要。</p><p>比如某个 node 服务突然异常重启了，那么可以通过 pm2 提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">p<span class="hljs-name">m2</span> logs<br></code></pre></td></tr></table></figure><h3 id="开机自动启动"><a href="#开机自动启动" class="headerlink" title="开机自动启动"></a>开机自动启动</h3><p>可以通过<code>pm2 startup</code>来实现开机自启动。细节可<a href="http://pm2.keymetrics.io/docs/usage/startup/">参考</a>。大致流程如下</p><ol><li>通过<code>pm2 save</code>保存当前进程状态。</li><li>通过<code>pm2 startup [platform]</code>生成开机自启动的命令。（记得查看控制台输出）</li><li>将步骤2生成的命令，粘贴到控制台进行，搞定。</li></ol><h3 id="监控-monitor-查看进程的资源消耗情况"><a href="#监控-monitor-查看进程的资源消耗情况" class="headerlink" title="监控(monitor)-查看进程的资源消耗情况"></a>监控(monitor)-查看进程的资源消耗情况</h3><p>运行如下命令，查看当前通过pm2运行的进程的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pm2 monit<br></code></pre></td></tr></table></figure><h2 id="通过pm2配置文件来自动部署项目"><a href="#通过pm2配置文件来自动部署项目" class="headerlink" title="通过pm2配置文件来自动部署项目"></a>通过pm2配置文件来自动部署项目</h2><h3 id="在项目根目录下新建一个-deploy-yaml-文件"><a href="#在项目根目录下新建一个-deploy-yaml-文件" class="headerlink" title="在项目根目录下新建一个 deploy.yaml 文件"></a>在项目根目录下新建一个 deploy.yaml 文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># deploy.yaml</span><br><span class="hljs-attr">apps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">script:</span> <span class="hljs-string">./start.js</span>       <span class="hljs-comment"># 入口文件</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;app&#x27;</span>              <span class="hljs-comment"># 程序名称</span><br>    <span class="hljs-attr">env:</span>                     <span class="hljs-comment"># 环境变量</span><br>      <span class="hljs-attr">COMMON_VARIABLE:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">env_production:</span><br>      <span class="hljs-attr">NODE_ENV:</span> <span class="hljs-string">production</span><br><br><span class="hljs-attr">deploy:</span>                     <span class="hljs-comment"># 部署脚本</span><br>  <span class="hljs-attr">production:</span>               <span class="hljs-comment"># 生产环境</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">lentoo</span>            <span class="hljs-comment"># 服务器的用户名</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.2</span><span class="hljs-number">.166</span>     <span class="hljs-comment"># 服务器的ip地址</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">22</span>                <span class="hljs-comment"># ssh端口</span><br>    <span class="hljs-attr">ref:</span> <span class="hljs-string">origin/master</span>      <span class="hljs-comment"># 要拉取的git分支</span><br>    <span class="hljs-attr">ssh_options:</span> <span class="hljs-string">StrictHostKeyChecking=no</span> <span class="hljs-comment"># SSH 公钥检查</span><br>    <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/**.git</span> <span class="hljs-comment"># 远程仓库地址</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/home</span>              <span class="hljs-comment"># 拉取到服务器某个目录下</span><br>    <span class="hljs-attr">pre-deploy:</span> <span class="hljs-string">git</span> <span class="hljs-string">fetch</span> <span class="hljs-string">--all</span> <span class="hljs-comment"># 部署前执行</span><br>    <span class="hljs-attr">post-deploy:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">&amp;&amp;</span>  <span class="hljs-string">pm2</span> <span class="hljs-string">reload</span> <span class="hljs-string">deploy.yaml</span> <span class="hljs-string">--env</span> <span class="hljs-string">production</span> <span class="hljs-comment"># 部署后执行</span><br>    <span class="hljs-attr">env:</span><br>      <span class="hljs-attr">NODE_ENV:</span> <span class="hljs-string">production</span><br><br></code></pre></td></tr></table></figure><h3 id="配置git的ssh免密认证"><a href="#配置git的ssh免密认证" class="headerlink" title="配置git的ssh免密认证"></a>配置git的ssh免密认证</h3><ol><li><p>在服务器中生成rsa公钥和私钥，当前是 <strong>centos7</strong> 下进行</p></li><li><p>前提服务器要安装git，没有安装的先安装git，已安装的跳过</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum –y install git<br></code></pre></td></tr></table></figure><ol start="3"><li>生成秘钥</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;xxx@xxx.com&quot;</span><br></code></pre></td></tr></table></figure><p>在~/.ssh目录下有 id_rsa和 id_rsa.pub两个文件，其中id_rsa.pub文件里存放的即是公钥key。</p><ol start="4"><li>登录到GitHub，点击右上方的头像，选择settings ，点击Add SSH key，把id_rsa.pub的内容复制到里面即可。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/26/16574cdcd9ac289b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="使用pm2部署项目"><a href="#使用pm2部署项目" class="headerlink" title="使用pm2部署项目"></a>使用pm2部署项目</h3><p>每次部署前先将本地的代码提交到远程git仓库</p><ul><li>首次部署</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">pm2 <span class="hljs-keyword">deploy</span> <span class="hljs-keyword">deploy</span>.yaml production setup <br>复制代码<br></code></pre></td></tr></table></figure><p>部署完成后，既可登陆服务器查看配置的目录下是否从git上拉取了项目</p><ul><li>再次部署</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">pm2 <span class="hljs-keyword">deploy</span> <span class="hljs-keyword">deploy</span>.yaml production upddate<br></code></pre></td></tr></table></figure><h3 id="该部署流程同样适用前端项目"><a href="#该部署流程同样适用前端项目" class="headerlink" title="该部署流程同样适用前端项目"></a>该部署流程同样适用前端项目</h3><p>如vue-cli的项目，自动部署到服务器，自动执行npm run build 命令，生成的dist目录，指定到nginx的静态文件目录下。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/chyingp/p/pm2-documentation.html">PM2实用入门指南</a></li><li><a href="https://juejin.im/post/5b823506e51d4538d517662f">使用pm2自动化部署node项目</a></li></ul><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><p><a href="https://pm2.io/doc/zh/runtime/overview/">https://pm2.io/doc/zh/runtime/overview/</a></p>]]></content>
    
    
    <categories>
      
      <category>基础教程</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桃园前端周刊第三期(2019-01-28)</title>
    <link href="/index.php/archives/237/"/>
    <url>/index.php/archives/237/</url>
    
    <content type="html"><![CDATA[<h2 id="前端中的-Ioc"><a href="#前端中的-Ioc" class="headerlink" title="前端中的 Ioc"></a><a href="https://zhuanlan.zhihu.com/p/53832991">前端中的 Ioc</a></h2><p>前端应用在不断壮大的过程中，内部模块间的依赖可能也会随之越来越复杂，模块间的 低复用性 导致应用 难以维护，不过我们可以借助计算机领域的一些优秀的编程理念来一定程度上解决这些问题，接下来要讲述的 IoC 就是其中之一。</p><h2 id="Polyfill-方案的过去、现在和未来"><a href="#Polyfill-方案的过去、现在和未来" class="headerlink" title="Polyfill 方案的过去、现在和未来"></a><a href="https://github.com/sorrycc/blog/issues/80">Polyfill 方案的过去、现在和未来</a></h2><p>我们希望浏览器提供一些特性，但是没有，然后我们自己写一段代码来实现他，那这段代码就是补丁（polyfill）。</p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>周刊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>发布 react 组件到 npm 上</title>
    <link href="/index.php/archives/235/"/>
    <url>/index.php/archives/235/</url>
    
    <content type="html"><![CDATA[<p>我发布了我的第一个 npm 组件，一个<a href="https://www.npmjs.com/package/react3dtagcloud">基于 react 的 3d 标签云</a>组件。在这途中我也是遇到了很多的坑，花在完善整个发布流程的时间远多于写这个组件本身的时间，所以我记录下我觉得一个正常的 react 组件的发布流程</p><blockquote><p>最后记录这篇文章花的时间比我完成整个组件的时间都多，最终希望能给新手带来帮助</p></blockquote><p>在整个发布组件的过程我做了如下几件事儿：</p><ol><li>开发组件</li><li>编写 Readme</li><li>推送到 github，并且把 demo 放到 github page 上</li><li>发布组件到 npm 上</li></ol><h2 id="开发组件"><a href="#开发组件" class="headerlink" title="开发组件"></a>开发组件</h2><p>创建项目文件夹并初始化 <code>npm package</code> ，确保你创建的组件名称没有在 <a href="https://www.npmjs.com/">npm</a> 上被使用过， 这里我们用 react-demo 作为示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir react-demo<br><span class="hljs-built_in">cd</span> react-demo<br>npm init<br></code></pre></td></tr></table></figure><p><code>npm init</code> 是生成初始的 <strong>package.json</strong> 的命令，在 <code>npm init</code> 的时候，你可以根据你自己的需要进行填写你的组件信息。或者直接使用 <code>npm init -y</code> 采用默认的，后面自己再去修改。</p><p>首先安装 react 相关的包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i react react-dom -D<br></code></pre></td></tr></table></figure><p>采用 <strong>babel</strong> 编译相关的依赖：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i @babel/cli @babel/core @babel/preset-env @babel/preset-react -D<br></code></pre></td></tr></table></figure><p>采用 <strong>webpack</strong> 做构建，<strong>webpack-dev-server</strong> 作为本地开发服务器，所以需要安装如下依赖：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i webpack webpack-<span class="hljs-keyword">cli</span> webpack-dev-server -D<br></code></pre></td></tr></table></figure><p>我这里为了简单演示，只安装 babel-loader 用来编译 jsx，其他 loader 安装自己的需要自己安装。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i babel-loader -D<br></code></pre></td></tr></table></figure><p>另外再安装一个 webpack 插件 html-webpack-plugin ，用来生成 html：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i html-webpack-plugin -D<br></code></pre></td></tr></table></figure><p>然后再添加上常规的 <strong>start</strong> 和 <strong>build</strong> 脚本，<strong>package.json</strong> 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;react-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open development&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;keywords&quot;</span>: [],<br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@babel/cli&quot;</span>: <span class="hljs-string">&quot;^7.2.3&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/core&quot;</span>: <span class="hljs-string">&quot;^7.2.2&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span>: <span class="hljs-string">&quot;^7.3.1&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-react&quot;</span>: <span class="hljs-string">&quot;^7.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;babel-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.5&quot;</span>,<br>    <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react-dom&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.29.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-dev-server&quot;</span>: <span class="hljs-string">&quot;^3.1.14&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，你也可以直接把我这个 package.json 复制过去，然后 <code>npm install</code> 进行依赖的安装，也可以一个一个的安装。</p><blockquote><p>一个最基本的组件只需要编译 jsx，所以我这里没有安装 css 以及处理其他的 loader，这篇文章的重点不是讲 webpack 的，所以其他的自行解决，有 webpack 问题可以私聊我。</p></blockquote><p>然后我们再创建如下的目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── example // 示例代码，在自己测试的时候可以把测试文件放到 src 里<br>│   └── src // 示例源代码<br>│       ├── index.html // 示例 html<br>│       └── app.js // 添加到 react-dom 的文件<br>├── package.json <br>├── src // 组件源代码<br>│   └── index.js // 组件源代码文件<br>├── .babelrc<br>├── .editorconfig // 不必须的，但是建议有<br>├── .gitignore // 如果要放到 github 上，这个是需要有的<br>└── webpack.config.js<br></code></pre></td></tr></table></figure><p>下面我们再创建一个最简单的组件，来进行演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*** src/index.js ***/</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">const</span> ReactDemo = <span class="hljs-function">() =&gt;</span> (<br> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是我的第一个 react npm 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ReactDemo;<br></code></pre></td></tr></table></figure><p>接下来添加一个 demo</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- examples/src/index.html --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>My First React Component<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*** examples/src/app.js ***/</span><br><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> &#123; render &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span><br><span class="hljs-keyword">import</span> ReactDemo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../src&#x27;</span><br><br><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReactDemo</span> /&gt;</span></span><br>render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br><br></code></pre></td></tr></table></figure><blockquote><p>注意 demo 中的 ReactDemo 是从 ../../src 中导入的</p></blockquote><p>接下来配置非常简单的 webpack, 在项目根路径下创建 webpack.config.js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;html-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> htmlWebpackPlugin = <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br><span class="hljs-attr">template</span>: path.join(__dirname, <span class="hljs-string">&quot;./example/src/index.html&quot;</span>),<br><span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;./index.html&quot;</span><br>&#125;);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br><span class="hljs-attr">entry</span>: path.join(__dirname, <span class="hljs-string">&quot;./example/src/app.js&quot;</span>),<br><span class="hljs-attr">output</span>: &#123;<br><span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">&quot;example/dist&quot;</span>),<br><span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;bundle.js&quot;</span><br>&#125;,<br><span class="hljs-attr">module</span>: &#123;<br><span class="hljs-attr">rules</span>: [&#123;<br><span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>,<br>use: <span class="hljs-string">&quot;babel-loader&quot;</span>,<br><span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span><br>&#125;]<br>&#125;,<br><span class="hljs-attr">plugins</span>: [htmlWebpackPlugin],<br><span class="hljs-attr">resolve</span>: &#123;<br><span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.jsx&quot;</span>]<br>&#125;,<br><span class="hljs-attr">devServer</span>: &#123;<br><span class="hljs-attr">port</span>: <span class="hljs-number">3001</span><br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>Webpack 的配置文件主要做了如下事情：</p><ul><li>使用 example/src/index.js 作为项目入口，处理资源文件的依赖关系</li><li>通过 babel-loader 来编译处理  js 和 jsx 文件</li><li>通过 html-webpack-plugin 自动注入编译打包好的脚本文件</li><li>为 demo 启动端口为 3001 的服务</li></ul><p>然后再配置一下 <strong>babel</strong>，咱们的 <strong>babel</strong> 主要做两件事，将 <strong>jsx</strong> 编译成 <strong>es5</strong>，然后再加一个通用的 <strong>env</strong>，所以 <strong>.babelrc</strong> 配置如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>, <span class="hljs-string">&quot;@babel/preset-react&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到之前的 <strong>package.json</strong> ，我这里 <strong>babel</strong> 安装的是 <strong>7.x</strong>，那么 <strong>babel-loader</strong> 就应该是 <strong>8.x</strong> 才行，然后 <strong>babel 7.x</strong> 相对于之前的配置是不同的，要用这个配置，版本一定要跟我的相同，不然配置可能会不一样。</p><p>然后现在执行 <code>npm start</code>，然后再访问 localhost:3001 就可以访问到了。</p><h3 id="编写-README"><a href="#编写-README" class="headerlink" title="编写 README"></a>编写 README</h3><p>编写 README，如果你不知道该如何编写，我给你提几点建议，你可以选择你觉得必要的点来写：</p><ol><li>logo</li><li>官方主页</li><li>介绍</li><li>安装</li><li>快速开始</li><li>功能列表</li><li>截图</li><li>todoList</li><li>不足之处</li><li>FAQ</li><li>Change Log（更新日志）</li></ol><h4 id="添加徽章"><a href="#添加徽章" class="headerlink" title="添加徽章"></a>添加徽章</h4><p>当你写完 <strong>README</strong> 之后，我们将添加一些来自 <a href="https://link.juejin.im/?target=https://shields.io/">shields.io</a> 的时髦徽章，让人们知道我们又酷又专业。</p><p><img src="http://imgs.taoweng.site/blog/typecho/1548919239.png"></p><p>想添加什么样的徽章看自己喜欢吧，种类有很多。</p><p>可以<a href="https://github.com/crazylxr/3dtagcloudforeact">点击这里</a>看我之前写的 3d 标签云的 README。</p><p>现在基本上可以发布了，但是要是能提供一个在线的 demo 让别人在用这个组件的时候可以看到效果就更好了。</p><h2 id="在-GitHub-Pages-上发布一个在线-demo"><a href="#在-GitHub-Pages-上发布一个在线-demo" class="headerlink" title="在 GitHub Pages 上发布一个在线 demo"></a>在 GitHub Pages 上发布一个在线 demo</h2><p>发布在线 demo 可以直接用 Github Pages 来帮助我们托管，通过 webpack 构建生产环境版本，然后发到 Github 上去即可。</p><p>首先去 Github 创建一个用来存放你组件代码的仓库。</p><p>然后把你的项目初始化成 git 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>再添加远程仓库，将本地仓库和远程仓库关联起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:crazylxr/react-demo.git<br></code></pre></td></tr></table></figure><p>接下来我们可以安装 <strong>gh-pages</strong> 来帮助我们发布到 github pages：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm i gh-pages -D<br></code></pre></td></tr></table></figure><p>为了方便记忆，后续能更快的发布，这些命令我们可以写成 npm-scriprt，所以我们增加两个脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;@taoweng/react-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;react demo&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open development&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span>,<br>    <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;gh-pages -d examples/dist&quot;</span>,<br>    <span class="hljs-attr">&quot;publish-demo&quot;</span>: <span class="hljs-string">&quot;npm run build &amp;&amp; npm run deploy&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;keywords&quot;</span>: [],<br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@babel/cli&quot;</span>: <span class="hljs-string">&quot;^7.2.3&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/core&quot;</span>: <span class="hljs-string">&quot;^7.2.2&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span>: <span class="hljs-string">&quot;^7.3.1&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-react&quot;</span>: <span class="hljs-string">&quot;^7.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;babel-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.5&quot;</span>,<br>    <span class="hljs-attr">&quot;gh-pages&quot;</span>: <span class="hljs-string">&quot;^2.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react-dom&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.29.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-dev-server&quot;</span>: <span class="hljs-string">&quot;^3.1.14&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>添加了 <strong>deploy</strong> 脚本和 <strong>publish-demo</strong>，以后需要发布 demo 的时候只需要 <code>npm run publish-demo</code> 即可。</p><p>然后我们就可以 build 项目之后再将 expamples/dist 发布到 gh-pages 分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run build<br>npm run deploy<br></code></pre></td></tr></table></figure><p>或者直接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run publish-demo<br></code></pre></td></tr></table></figure><blockquote><p>注意：这里只会将 expample/src 下的文件发布到 ph-pages 分支，master 分支依然没有到 github 上，如果你要把源码放到 github 的 master 或者其他分支上，还是需要自己 push 的。 </p></blockquote><p>这个时候，我们可以通过 <strong>crazylxr.github.io/react-demo</strong> 访问到我们写的 demo。crazylxr 是 github 的 username，react-demo 是仓库名，注意改成你自己的。</p><h2 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h2><p>我们现在的源码是 <strong>jsx</strong> 的，所以我们需要通过 <strong>babel</strong> 把 <strong>jsx</strong> 编译为正常浏览器能访问的代码。我们可以通过 <strong>babel-cli</strong> 来编译我们代码，直接编译 <strong>src</strong> 目录，到 <strong>lib</strong> 文件夹。更多命令见 <a href="https://babeljs.io/docs/en/babel-cli/">babel-cli</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx babel src --out-dir lib<br></code></pre></td></tr></table></figure><p>执行完这个命令，就把生成一个 <strong>lib</strong> 文件夹，然后里面的 <strong>index.js</strong> 就是编译过后的文件，是可以直接发布到 <strong>npm</strong> 的文件。</p><p>然后将这个编译命令写到 <strong>script</strong> 里，<strong>package.json</strong> 如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;@taoweng/react-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;react demo&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open development&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span>,<br>    <span class="hljs-attr">&quot;compile&quot;</span>: <span class="hljs-string">&quot;npx babel src --out-dir lib&quot;</span>,<br>    <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;gh-pages -d example/dist&quot;</span>,<br>    <span class="hljs-attr">&quot;publish-demo&quot;</span>: <span class="hljs-string">&quot;npm run build &amp;&amp; npm run deploy&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;keywords&quot;</span>: [],<br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span>,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@babel/cli&quot;</span>: <span class="hljs-string">&quot;^7.2.3&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/core&quot;</span>: <span class="hljs-string">&quot;^7.2.2&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span>: <span class="hljs-string">&quot;^7.3.1&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-react&quot;</span>: <span class="hljs-string">&quot;^7.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;babel-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.5&quot;</span>,<br>    <span class="hljs-attr">&quot;gh-pages&quot;</span>: <span class="hljs-string">&quot;^2.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react-dom&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.29.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-dev-server&quot;</span>: <span class="hljs-string">&quot;^3.1.14&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>那么以后要编译 <strong>src</strong> 下面的代码，只需要执行：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">npm <span class="hljs-keyword">run</span> <span class="hljs-keyword">compile</span><br></code></pre></td></tr></table></figure><p>现在我们已经有编译好的代码了，接下来就可以发布到 npm 供其他人使用了。</p><h2 id="发布-npm-包"><a href="#发布-npm-包" class="headerlink" title="发布 npm 包"></a>发布 npm 包</h2><p>在发布以前我们是需要一些准备：</p><p><strong>注册 npm 账户：</strong></p><p>在这里](<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>) 注册一个 npm 账号。</p><p><strong>登录</strong></p><p>在终端输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm adduser<br></code></pre></td></tr></table></figure><p>也可以用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm login<br></code></pre></td></tr></table></figure><p>然后你会得到一个让你输入<strong>username</strong>、<strong>password</strong> 和 **email ** 的提示，把它们填在相应的位置。</p><p><strong>关于 package.json 需要注意的点</strong></p><p>package.json 里面的配置信息非常重要，我解释一下几个重要的配置。</p><ul><li><p><a href="https://docs.npmjs.com/files/package.json#name">name</a>: 包名，如果你学习的话建议加一个 scoped，就是我上面的 <strong>@taoweng/react-demo</strong> 而不是 <strong>react-demo</strong>，因为 npm 包特别的多，很容易重复。这样这个包就会是私有的，可以通过 <code>npm publish --access=public</code> 将这个包变为共有的包。</p></li><li><p><a href="https://docs.npmjs.com/files/package.json#version">version</a>: 包的版本，每次发布包的版本不能和上次一样。详细规范可见<a href="https://semver.org/lang/zh-CN/">这里</a></p></li><li><p><a href="https://docs.npmjs.com/files/package.json#description">description</a>：包的简介。</p></li><li><p><a href="https://docs.npmjs.com/files/package.json#repository">repository</a>：适合写 Github 地址，建议写成：**:username/:repository**。</p></li><li><p><a href="https://docs.npmjs.com/files/package.json#license">license</a>：认证。不知道该用什么的，就写MIT 吧。</p></li><li><p><a href="https://docs.npmjs.com/files/package.json#main">main</a>：包的入口文件。就是引入这个包的时候去加载的入口文件。</p></li><li><p><a href="https://docs.npmjs.com/files/package.json#keywords">keywords</a>：添加一些关键词更容易使你的包被搜索到。</p></li></ul><p>更详细的 <strong>package.json</strong> 配置可见<a href="https://docs.npmjs.com/files/package.json">官网</a>。</p><p>我这里简单的添加了这些信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;@taoweng/react-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;react demo&quot;</span>,<br>  <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;lib/index.js&quot;</span>,<br>  <span class="hljs-attr">&quot;repository&quot;</span>: <span class="hljs-string">&quot;crazylxr/react-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --open development&quot;</span>,<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span>,<br>    <span class="hljs-attr">&quot;compile&quot;</span>: <span class="hljs-string">&quot;npx babel src --out-dir lib&quot;</span>,<br>    <span class="hljs-attr">&quot;deploy&quot;</span>: <span class="hljs-string">&quot;gh-pages -d example/dist&quot;</span>,<br>    <span class="hljs-attr">&quot;publish-demo&quot;</span>: <span class="hljs-string">&quot;npm run build &amp;&amp; npm run deploy&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;keywords&quot;</span>: [<span class="hljs-string">&quot;react&quot;</span>, <span class="hljs-string">&quot;demo&quot;</span>],<br>  <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;taoweng&quot;</span>,<br>  <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;MIT&quot;</span>,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@babel/cli&quot;</span>: <span class="hljs-string">&quot;^7.2.3&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/core&quot;</span>: <span class="hljs-string">&quot;^7.2.2&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-env&quot;</span>: <span class="hljs-string">&quot;^7.3.1&quot;</span>,<br>    <span class="hljs-attr">&quot;@babel/preset-react&quot;</span>: <span class="hljs-string">&quot;^7.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;babel-loader&quot;</span>: <span class="hljs-string">&quot;^8.0.5&quot;</span>,<br>    <span class="hljs-attr">&quot;gh-pages&quot;</span>: <span class="hljs-string">&quot;^2.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;html-webpack-plugin&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;react-dom&quot;</span>: <span class="hljs-string">&quot;^16.7.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack&quot;</span>: <span class="hljs-string">&quot;^4.29.0&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-cli&quot;</span>: <span class="hljs-string">&quot;^3.2.1&quot;</span>,<br>    <span class="hljs-attr">&quot;webpack-dev-server&quot;</span>: <span class="hljs-string">&quot;^3.1.14&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这些配置信息都会在 npm 包的页面显示出来的，所以能填还是填一下：</p><p><img src="http://imgs.taoweng.site/blog/typecho/1548919186.png"></p><p>最后我们在项目中添加 .npmignore 文件，跟 .gitignore 的作用一样，就是在发布 npm 的时候需要忽略的文件和文件夹：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># .npmignore </span><br>src<br>examples<br><span class="hljs-string">.babelrc</span><br><span class="hljs-string">.gitignore</span><br>webpack.config.js<br></code></pre></td></tr></table></figure><p>这个时候我们就可以发布到 npm 了:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish<br></code></pre></td></tr></table></figure><p>如果你是私有包，可以这样发布：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm publish --access=public<br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以后发布新版本的时候，只需要更改一下 package.json 里面的 version 版本号，然后执行 npm publish 和 npm run publish-demo 就可以同步 npm 和 demo。</p><p>不过如果想让你的组件在社区里给更多人用，你需要把 README 写得更好一点，然后添加好自动化测试，不然别人不太敢用。</p><p>另外在写组件之前可以先了解下有没有类似的组件了，如果有就直接用吧，咱们就站在巨人的肩膀上，把自己宝贵的时间放在创造价值上。</p><p>最后整个项目的源代码见 <a href="https://github.com/crazylxr/react-demo">github</a></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/37366401" title="从 0 开始发布一个 react 组件到 npm">从 0 开始发布一个 react 组件到 npm</a></li><li><a href="https://juejin.im/post/5c26c1b65188252dcb312ad6" title="创建并发布一个小而美的 npm 包，没你想的那么难！">创建并发布一个小而美的 npm 包，没你想的那么难！</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>基础教程</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>npm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 之修改 commit 以及 rebase 的使用</title>
    <link href="/index.php/archives/228/"/>
    <url>/index.php/archives/228/</url>
    
    <content type="html"><![CDATA[<p>我在提交中犯了一个错误，我该如何解决？</p><p>我的提交历史一团遭，我改如何让它整洁？</p><p>如果您有过上述问题，那么这篇文章适合您。这篇文章介绍了一个让你成为 Git 专家的主题列表。</p><p>如果您不了解 Git 基础知识，请单击此处查看我的 Git 基础知识博客。您必须了解 Git 的基础知识才能充分利用本文。</p><h2 id="我的提交中犯了一个错误。我该怎么办？"><a href="#我的提交中犯了一个错误。我该怎么办？" class="headerlink" title="我的提交中犯了一个错误。我该怎么办？"></a>我的提交中犯了一个错误。我该怎么办？</h2><h3 id="情景-1"><a href="#情景-1" class="headerlink" title="情景 1"></a>情景 1</h3><p>假设您已经提交了一堆文件并意识到您输入的提交消息实际上并不清楚。现在您要更改提交消息。为此，您可以使用 <code>git commit --amend</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend -m “新提交消息”<br></code></pre></td></tr></table></figure><h3 id="情景-2"><a href="#情景-2" class="headerlink" title="情景 2"></a>情景 2</h3><p>假设您想提交六个文件，但是，错误地，您最终只提交了五个文件。您可能认为可以创建新提交并将第6个文件添加到该提交。</p><p>这种方法没有错。但是，为了保持整洁的提交历史，如果你真的可以以某种方式将此文件添加到您之前的提交本身，那会不会更好？这也可以通过以下方式完成 <code>git commit --amend</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add file6 <br>git commit --amend --no-edit<br></code></pre></td></tr></table></figure><p><code>--no-edit</code> 表示提交消息不会更改</p><h3 id="场景3"><a href="#场景3" class="headerlink" title="场景3"></a>场景3</h3><p>无论何时在 Git 中进行提交，提交都会附上作者姓名和作者电子邮件。通常，当您第一次设置 Git 时，您需要设置作者姓名和电子邮件。您无需担心每次提交的作者详细信息。</p><p>也就是说，对于特定项目，您可能希望使用不同的电子邮件 ID。您需要使用以下命令为该项目配置电子邮件 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.email “你的电子邮件ID”<br></code></pre></td></tr></table></figure><p>假设您忘记配置电子邮件，并且已经完成了第一次提交。Amend 也可用于更改先前提交的作者。可以使用以下命令更改提交的作者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend --author“作者姓名&lt;作者电子邮件&gt;”<br></code></pre></td></tr></table></figure><blockquote><p>注意：仅在本地存储库中使用该 amend 命令。使用远程存储库可能会造成很多混乱 amend</p></blockquote><h2 id="我的提交历史是一团糟。我该如何处理？"><a href="#我的提交历史是一团糟。我该如何处理？" class="headerlink" title="我的提交历史是一团糟。我该如何处理？"></a>我的提交历史是一团糟。我该如何处理？</h2><p>假设您正在处理一段代码。您知道代码大约需要十天才能完成。在这十天内，其他开发人员也将提交代码到远程存储库。</p><p>将本地存储库代码与远程存储库中的代码保持同步是一种很好的做法。这会在您提出拉取请求时避免很多合并冲突。因此，您决定每两天从远程存储库中提取一次更改。</p><p>每次将代码从远程存储库提取到本地存储库时，都会在本地存储库中创建新的合并提交。这意味着您的本地提交历史记录将会进行大量的合并提交，这会使审阅者感到困惑。</p><p><img src="http://imgs.taoweng.site/blog/typecho/1548153123.png" alt="以下是提交历史记录在本地存储库中的显示方式。"></p><h3 id="如何使提交历史看起来更整洁？"><a href="#如何使提交历史看起来更整洁？" class="headerlink" title="如何使提交历史看起来更整洁？"></a>如何使提交历史看起来更整洁？</h3><p>这就是 rebase 拯救的地方。</p><h3 id="什么是变基-rebase-？"><a href="#什么是变基-rebase-？" class="headerlink" title="什么是变基(rebase)？"></a>什么是变基(rebase)？</h3><p>让我通过一个例子解释一下。<br><img src="http://imgs.taoweng.site/blog/typecho/1548153160.png" alt="此图显示了发布分支和功能分支中的提交"></p><ol><li>Release 分支有三个提交：Rcommit1，Rcommit2 和Rcommit3。</li><li>您在 Release 分支中只有一个提交（即 Rcommit1）时创建了 Feature 分支。</li><li>您已向 Feature 分支添加了两个提交。它们是 Fcommit1 和 Fcommit2。</li><li>您的目标是从 Release 分支提交到 Feature 分支。</li><li>您将使用 rebase 来执行此操作。</li><li>让 Release 分支的名称发布，Feature 分支的名称是 feature。</li><li>可以使用以下命令重新进行重新定位：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout feature<br>git rebase release<br></code></pre></td></tr></table></figure><h3 id="垫底"><a href="#垫底" class="headerlink" title="垫底"></a>垫底</h3><p>在重新定位时，您的目标是确保功能分支从 release 分支获取最新代码。</p><p>重新尝试尝试逐个添加每个提交，并检查冲突。这听起来有点令人困惑吗？</p><p>让我在图表的帮助下解释。</p><p>这显示了内部实际的变革：</p><p><img src="http://imgs.taoweng.site/blog/typecho/1548153188.png"></p><h4 id="第-1-步"><a href="#第-1-步" class="headerlink" title="第 1 步"></a>第 1 步</h4><ol><li>运行该命令的那一刻，feature 分支指向 release 分支的头部。</li><li>现在，feature 分支有三个提交：Rcommit1，Rcommit2 Rcommit3。</li><li>您可能想知道 Fcommit1和 Fcommit2 发生了什么。</li><li>提交仍然存在，将在下面的步骤中使用。</li></ol><h4 id="第-2-步"><a href="#第-2-步" class="headerlink" title="第 2 步"></a>第 2 步</h4><ol><li>现在 git 尝试将 fcommit1 添加到 feature 分支。</li><li>如果没有冲突，则在 Rcommit3 之后添加 Fcommit1</li><li>如果存在冲突，git 会通知您，您必须手动解决冲突。解决冲突后，使用以下命令继续重新绑定</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add fixedfile <br>git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure><h4 id="第-3-步"><a href="#第-3-步" class="headerlink" title="第 3 步"></a>第 3 步</h4><ol><li>一旦添加了 Fcommit1，git 将尝试添加 Fcommit2。</li><li>同样，如果没有冲突，则在 Fcommit1 之后添加 Fcommit2 并且 rebase 成功。</li><li>如果存在冲突，git 会通知您，您必须手动解决。解决冲突后，请使用步骤2中提到的相同命令</li><li>整个 rebase 完成后，您会注意到 feature 分支有Rcommit1，Rcommit2，Rcommit3，Fcommit1 和 Fcommit2。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>Rebase 和 Merge 在 Git 中都很有用。一个并不比另一个好。</li><li>在合并的情况下，您将进行合并提交。在 rebase 的情况下，没有像 merge 提交那样的额外提交。</li><li>一种最佳实践是在不同点使用命令。使用远程存储库中的最新代码更新本地代码存储库时，请使用 rebase。在处理 pull 请求以将Feature 分支与 Release 或 Master 分支合并时，请使用merge。</li><li>使用 Rebase 会更改提交历史记录（使其更整洁）。但话虽如此，改变提交历史存在风险。因此，请确保永远不要对远程存储库中的代码使用 rebase。始终仅使用 rebase 来更改本地仓库代码的提交历史记录。</li><li>如果对远程存储库进行了rebase，则会产生很多混乱，因为其他开发人员无法识别新的历史记录。</li><li>此外，如果在远程存储库上完成 rebase，则当其他开发人员尝试从远程存储库中提取最新代码时，它可能会产生问题。所以我再说一遍，总是只为本地存储库使用 rebase</li></ol><h2 id="恭喜"><a href="#恭喜" class="headerlink" title="恭喜"></a>恭喜</h2><p>你现在是Git专家<br>在这篇文章中你了解到：</p><ul><li>修改提交</li><li>变基(rebase)</li></ul><p>这两个都是非常有用的概念。去探索Git的世界，进一步学习。</p><blockquote><p>原文：<a href="https://medium.freecodecamp.org/how-to-become-a-git-expert-e7c38bf54826">https://medium.freecodecamp.org/how-to-become-a-git-expert-e7c38bf54826</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
      <category>译文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端书籍推荐</title>
    <link href="/index.php/archives/227/"/>
    <url>/index.php/archives/227/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML-与-CSS"><a href="#HTML-与-CSS" class="headerlink" title="HTML 与 CSS"></a>HTML 与 CSS</h2><ul><li>《Head First HTML与CSS(第2版)》–豆瓣评分 9.3。入门真的是经典书籍，手把手教学，丰富的案例让你从 0 开始学前端。</li><li>《CSS权威指南(第三版)》–豆瓣评分 8.5。这本书也是非常的经典了，2007 年的书了，但是无不影响这本书作为 CSS 的经典著作，把原理讲得非常的通透，除了 w3c 标准，算最权威的一本了，毕竟权威指南。这本书都是 css 2.1 的，与张鑫旭的《CSS 世界》可以说是一个类别的，我没看过这本书，但是据我朋友说没有权威指南好，口水话太多，也许是让读者好理解，权威指南这本我是看过的，学 CSS 必读经典。</li><li>《CSS揭秘》–豆瓣评分9.4。神书，47 和 css 技巧让你在面对各种 css 问题的时候游刃有余。豆瓣评分 9.4 ，是 css 书籍中评分最高的了，css 进阶必备。</li></ul><p>总结：所以对于 css 来说，《Head First HTML与CSS(第2版)》是入门，权威指南是基础，css 揭秘是进阶，可以按照这个顺序来阅读。</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><ul><li>《javascript语言精粹》–豆瓣评分 9.1。这本书可以在入门之前了解一下基本语法，以及在学习之前可以了解下 JS 里面的精粹以及糟粕，虽然这本书很薄很薄，但是值得反复去读的一本书，当时学习前端半年，一年再回来看这本书会跟你第一看应该有更深刻的理解。</li><li>《JavaScript DOM编程艺术(第2版)》– 豆瓣评分 8.7。本 书在简洁明快地讲述JavaScript和DOM的基本知识之后，通过几个实例演示了专业水准的网页开发技术，透彻阐述了平稳退化等一批至关重要的 JavaScript编程原则和最佳实践。</li><li>《JavaScript权威指南》：犀牛书是每个FE都绕不过的一本书，可以先大致通读几遍，也可以把其当作工具书，时时翻阅。</li><li>《JavaScript高级程序设计》：红宝书虽然号称高级，但其实是帮助入门的，Zakas大神把概念深入浅出，将JavaScript的语法要点讲清楚明白。小红书配合犀牛书，相互印证，谁读谁知道。</li><li>《你不知道的JavaScript 上中下》：这本绝对是神书，让你了解JavaScript不为人知的另一面，把闭包、异步这些讲得很通透。</li><li>《ES6 标准入门（第3版）》–豆瓣评分 8.9。阮老师的书，国内最好的一本 ES6 ES7 ES8 的入门书籍，第三版相对于第二版多了 ES8 的内容，所以也厚了很多。因为现在框架盛行，特别是 React 基本是已经完全拥抱了 ES6 了，还没学 ES6 赶紧补起来，不然要落后了。</li><li>《深入理解 ES6》–豆瓣评分9.5。这本书是红宝书作者写的又一部经典著作，ES6 进阶用。</li><li>《JavaScript设计模式与开发实践》–豆瓣评分 9.1。本书将教会你如何把经典的设计模式应用到JavaScript语言中，编写出优美高效、结构化和可维护的代码。如果想学 设计模式的，我相信这本书应该比 JavaScript 设计模式那本书更好懂。</li><li>《高性能JavaScript》–豆瓣评分9.0。揭示了技术和策略能帮助你在开发过程中消除性能瓶颈。你将会了解如何提升各方面的性能，包括代码的加载、运行、DOM交互、页面生存周期等。</li></ul><p>总结：阅读顺序建议从《javascript语言精粹》-&gt; JavaScript DOM编程艺术(第2版)》-&gt; 《JavaScript高级程序设计》和 《JavaScript权威指南》-&gt; 《ES6 标准入门（第3版）》。</p><p>其他几本没写顺序的就可以在学完基础都可以看着的。根据自己当时的需要来选择性阅读。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><ul><li>《深入 React 技术栈》– 豆瓣评分 8.3。写 react 及其技术栈的还有一本程墨的《深入 React 和 Redux》，后者文字比较通俗易懂，相对于前者来说还不够深入，而且没有源码解析，两本我都看过，如果买的话我推荐《深入 React 技术栈》。如果已经买了《深入 React 和 Redux》 的，就看这本也可以了。</li><li>《React状态管理与同构实战》–豆瓣评分估计 8.5 以上。这本刚出的书，我也看了一部分了，偏实战，react 知识讲解得比较少，大部分用来讲解 Redux 并用 Redux 如果做好状态管理，并且还有同构部分的深入讲解。想深入学习 React 原理的并不是适合买这本书。</li><li>《React 进阶之路》–豆瓣评分 9.3。虽然这本书是进阶之路，但是其实这本书还是适合新手看的，从入门到进阶吧，这本是 React 16 版本的书，16 的新特性也都写到了，新手想学 React 的这是一本不错的书哦。</li></ul><p>总结：《React 进阶之路》这本用来入门，《深入 React 技术栈》用来深入理解，《React状态管理与同构实战》这本用来实战。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>《图解HTTP》：一本HTTP的神书，图文并茂，生动形象。</li><li>《Web性能权威指南》：优化web性能，进阶之书。– 豆瓣评分8.8</li></ul><h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Node 说实话，真没感觉有什么好书。<br>非要推荐的话，就</p><ul><li><p>《深入浅出Node.js》：针对Node的基本原理做了深入，能让你了解底层的Node实现</p></li><li><p>《Node.js开发指南》：Node的事件循环，必看必会。</p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>担心有读者问我为啥不推荐 vue 的书，这里说一下，学习 vue 真的不用买书，官网够了，vue 官网是我看过质量最高的官网了，入门，进阶都有。但是要深入的话，比如源码这些，推荐看黄轶在慕课上的源码解析，如果不想看课程的也有配套的开源源码分析文章，<a href="http://hcysun.me/vue-design/">vue 技术内幕</a>(<a href="http://hcysun.me/vue-design/)%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%98%E6%9C%89%E6%9F%93%E9%99%8C%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%9C%B0%E5%9D%80%E6%98%AF(https://github.com/answershuto/learnVue)%E3%80%82">http://hcysun.me/vue-design/)，然后还有染陌的源码解析，地址是(https://github.com/answershuto/learnVue)。</a></p><p>Angular 我刚学，了解一下，基本都是从官网里面学习，没有买过书，所以 Angular 我就不推荐了，没看过担心误人子弟。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>书籍</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac Brew 常用命令笔记</title>
    <link href="/index.php/archives/223/"/>
    <url>/index.php/archives/223/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Homebrew 是一款自由及开放源代码的软件包管理系统，用以简化 macOS 系统上的软件安装过程。每个操作系统都有类似的，比如 Ubuntu 的 apt，Centos 的 yum。</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="安装-brew"><a href="#安装-brew" class="headerlink" title="安装 brew"></a>安装 brew</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ruby -e <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="使用brew安装软件"><a href="#使用brew安装软件" class="headerlink" title="使用brew安装软件"></a>使用brew安装软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brew install git<br></code></pre></td></tr></table></figure><h3 id="使用brew卸载软件"><a href="#使用brew卸载软件" class="headerlink" title="使用brew卸载软件"></a>使用brew卸载软件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brew uninstall git<br></code></pre></td></tr></table></figure><h3 id="使用brew查询软件"><a href="#使用brew查询软件" class="headerlink" title="使用brew查询软件"></a>使用brew查询软件</h3><p>有时候，你不知道你安装的软件的名字， 那么你需要先搜索下, 查到包的名字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew search /wge*/<br></code></pre></td></tr></table></figure><h3 id="其他brew命令"><a href="#其他brew命令" class="headerlink" title="其他brew命令"></a>其他brew命令</h3><ul><li>brew list           列出已安装的软件</li><li>brew update     更新brew</li><li>brew home       用浏览器打开brew的官方网站</li><li>brew info         显示软件信息</li><li>brew deps        显示包依赖</li><li>brew upgarde 更新所有</li><li>brew upgarde [包名] 更新指定包</li><li>brew cleanup  清理所有包的旧版本</li><li>brew cleanup [包名] 清理指定包的旧版本</li><li>brew cleanup -n 查看可清理的旧版本包，不执行实际操作</li></ul><h3 id="卸载-brew"><a href="#卸载-brew" class="headerlink" title="卸载 brew"></a>卸载 brew</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> `brew --prefix`<br>rm -rf Cellar<br>brew prune<br>rm `git ls-files`<br>rm -r Library/Homebrew Library/Aliases Library/Formula Library/Contributions<br>rm -rf .git<br>rm -rf ~/Library/Caches/Homebrew<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2018 年度总结, 三个角色的转变</title>
    <link href="/index.php/archives/221/"/>
    <url>/index.php/archives/221/</url>
    
    <content type="html"><![CDATA[<p>2018已经结束了，总结自己这一年来就是三个角色的转变：自己从一个学生成为了一个社会人，从一个读者变成了一个自媒体人，从一个在校学习者变成了终身学习者。</p><p>每一种角色的转变意味着责任的转变，每多一种角色，就会多承担一份责任。角色变得越大，责任也会承担得越大，当然收获得也更大。</p><h2 id="技术成长"><a href="#技术成长" class="headerlink" title="技术成长"></a>技术成长</h2><p>对于技术成长，我感觉我莫名其妙的就走在了前端的前沿，刚刚在知乎上看到一个帖子<a href="https://www.zhihu.com/question/308348507/answer/568757795">2019 前端技术规划该包含什么？</a>很多大佬在规划里面都谈到 <code>Rxjs</code>、<code>Typescript</code>、<code>函数式编程</code>、<code>Flutter</code>、<code>PWA</code>、<code>Node 相关</code>, 然而事实就是这么巧(或者可以说我眼界比较远，偷笑)，在 2018 年我很多都已经接触过了，比如 Rxjs、TS、函数式编程、Node 等。</p><h3 id="聊-Typescript-TS"><a href="#聊-Typescript-TS" class="headerlink" title="聊 Typescript(TS)"></a>聊 Typescript(TS)</h3><p>特别是对于 TS，我在公众号，然后我维护的微信群里早就已经说过，TS 最近会火起来的，没学的赶紧学起来，不知道有多少人听了我的，看了那么多大佬的规划，我更加的坚信了 TS 将会变成未来前端工程师一项必备的技能。</p><p>然后对于 TS 的学习，我看过这些东西，我推荐一下，不过对于 TS 我仍然是个初学者，不敢说有多精通，我只在我自己的小项目中用过，没有在公司的项目中使用。</p><ul><li><a href="https://www.tslang.cn/">TS 官方文档</a></li><li><a href="http://jspang.com/post/typescript.html#toc-af7">技术胖的 ts 教程</a></li><li><a href="https://segmentfault.com/l/1500000014450043">TypeScript极速完全进阶指南</a></li><li><a href="https://jkchao.github.io/typescript-book-chinese/">深入理解 TypeScript</a></li></ul><p>如果问我使用 TS 感觉是什么样的，我只能说相逢恨晚，就跟 vim 一样，用过之后就像一直用。</p><h3 id="聊-Rxjs"><a href="#聊-Rxjs" class="headerlink" title="聊 Rxjs"></a>聊 Rxjs</h3><p>对于学 Rxjs 来说，我想说的是，Rxjs 是我学过最难学的一个库了，目前为止没有之一。现在回想起来，要是早点接触函数式编程就好了，如果先是研究函数式编程，再去学习 Rxjs，我相信会轻松 40% 以上。但是目前为止，我并没有拿到真正的生产环境去用过，只是写过一些简单的 demo，然后看过一些资料和书籍，同时也在团队做过相关的普及。</p><p>Rxjs 难的就是思维方式以及 api 很多，然后就是由于一些概念不知道为什么要这么设计(很多思想我相信学了函数式编程就会明白了)。</p><p>对于 rxjs 的学习看过很多的文章，我这里还是推荐三个我觉得比较全的学习资料。</p><ul><li><a href="https://cn.rx.js.org/">Rxjs 官网</a></li><li><a href="https://ithelp.ithome.com.tw/users/20103367/ironman/1199">30 天精通 Rxjs</a></li><li>程墨老师的<a href="http://product.dangdang.com/25273232.html">深入浅出 Rxjs</a></li></ul><h3 id="聊函数式编程"><a href="#聊函数式编程" class="headerlink" title="聊函数式编程"></a>聊函数式编程</h3><p>学习函数式编程给我最大的感受就是让我拓宽了我的眼界，突然的就弥补了以前知识体系缺的点。比如对于 compose、curry 这些 js 里面也算一直提及的重要概念，但是总是记了又忘，忘了又记，就算自己手写来实现过了，但是隔了几个月还是又忘了，因为没用过。但是学了函数式编程以后，发现全是这些东西，compose 呀、柯里化呀、部分应用呀，就跟用数组的  map、reduce 这些方法那么熟练，所以，现在闭着眼睛也能写出来，就几行代码的事儿。</p><p><a href="http://www.taoweng.site/index.php/archives/218/">函数式编程里面的基本工具函数实现</a>, 用 ES6 简单的实现了这些概念的核心原理，真的就几行代码。</p><p>之前也谈到过学 Rxjs 的时候要是先学了函数式编程就好了，那是因为 Rxjs 用的也是函数式编程，而且那里面的操作符也是，然后比如 rxjs 的链式调用当时觉得很不错，jQuery 也有这种，当时还无法确切的知道是怎样的机制，然而当了解了函数式编程的 Functor 之后，就不再感到迷惑了，再比如实现一个 Promise，我相信是对于大部人前端开发者来说还是有一定的难度的，当 学习了 Monad 之后，可能再去写一个 Promise 就没那么难了，因为 Promise 就是一个 Monad，Monad 是函数式编程里面一个非常非常难以理解的概念，我觉得是最难的概念之一。</p><p>另外可能就会有朋友问，既然函数式编程这么好，那你平时在用吗？说实话，我不敢在公司的项目里面使用，要用也最多只会用下组合，柯里化，部分应用这些，不敢去用 Monad 相关的东西，因为团队用函数式的人很少，一个人去用，会给团队带来很大的维护成本。而且目前感觉这些高级概念在 js 里面不太适合，可能因为我还是个初学者，还没学到精华吧。</p><p>但是对于函数式里面的组合，我是非常之赞成，通过抽象颗粒度更小的函数，然后再组成满足任务函数，这点我感觉是函数式编程的精华之一，想要用好组合，柯里化和部分应用的灵活使用就显得非常重要，可能刚开始不知道有啥区别，或者说什么时候该用哪个，当你真正遇到的时候，你自然就会区分出来。</p><p>函数式编程给我带来的收获太多了，后面会陆续总结出我的学习总结，本来早就想写，但是之前发表的一篇<a href="https://juejin.im/post/5c19c3ffe51d45059b632eef">函数式编程，真香</a>令我有点心累，这篇文章是我刚开始学习函数式编程不久写的一篇文章，当时在看《javascript 函数式编程指南》的时候写的，这篇基本上是总结的那上面的第一章，因为我觉得这是我看到过的资料里面对函数式编程的总体概述说得最好的，所以我写出来给大家分享一下，然后就被说，抄书有意思？等等之类的话，但是也有朋友说，感谢我的分享，书上有时候大段大段的文字，还不如别人一篇文章总结的好。反正这篇文章是我写了之后最难受的一篇，在发这篇文章之后的几天，我都很怕我的掘金账号有通知消息，生怕又要被骂了，那个时候本来就计划着自己可以总结一下那本书的精华，然后写一系列文章，但是为了维护我的玻璃心，就继续买书，看资料，理解得更深刻了，变为自己东西了再写。</p><p>我收集的一些<a href="http://www.taoweng.site/index.php/archives/197/">函数式编程的资料</a>以及书籍，如果没找到好的资料的可以点进去看下。</p><p>虽然我看了这么多资料以及书籍，但是我还是一个在函数式领域的新手，要是写得不好，欢迎大家拍砖(留点面子)。</p><p>之前以一篇《我如何零基础转行成为一个自信的前端》的文章，红遍掘金的<a href="https://juejin.im/post/5c3c7708e51d4552313479f1?utm_source=wechat&from=timeline&isappinstalled=0">serialcoder</a>，就是被有些朋友激进的言语离开掘金了，删掉了所有的文章，还好现在我看他现在又回归了。希望大家还是多交流，言语啥的也都轻点，都是一个圈子的人。</p><h2 id="我的公众号"><a href="#我的公众号" class="headerlink" title="我的公众号"></a>我的公众号</h2><p>做公众号是我今年做得最正确的一个决定吧，也是令我收获蛮大的。主要是写了很多的文章，扩展了自己的社交圈，认识了很多朋友，也接触到了很多大佬，还有了一点点运营的概念。</p><p>我的公众号是【前端桃园】，做得不太好，最近没有坚持更新了，因为在写自己的小项目，后面可以看到自己规划的项目还有好多没写完呢，希望有小伙伴来入个伙，早点让这些项目上线用起来。</p><h2 id="我的项目"><a href="#我的项目" class="headerlink" title="我的项目"></a>我的项目</h2><p>今年计划的项目其实还挺多的。不过目前为止一个拿得出手的都没有，说出来惭愧呀。</p><h3 id="1-github-issue-博客"><a href="#1-github-issue-博客" class="headerlink" title="1. github issue 博客"></a>1. github issue 博客</h3><p><a href="https://github.com/crazylxr/crazylxr.github.io">项目地址</a></p><p>之前想在 github issue 上写博客，但是有嫌弃 issue 太丑了，所以就写了一个静态博客，那个时候刚好 parcel 刚好发布了，所以就用 vue + parcel 练练手，获取 issue 的内容，然后展示在网站上，所以就做了一个极简的博客系统，但是写好了就没怎么用了，现在似乎图片都失效了。</p><h3 id="2-随机小程序-决策那点事儿"><a href="#2-随机小程序-决策那点事儿" class="headerlink" title="2. 随机小程序(决策那点事儿)"></a>2. 随机小程序(决策那点事儿)</h3><p>写这个项目的原因是，最开始我们在公司的时候，中午总是不知道出去吃哪一家，所以就比较的纠结，当时我就想到要是有一个东西可以帮我做下决定，随机一下，然后还可以给答案设定权重，比如比较喜欢吃张亮麻辣烫就权重设高一点，那么随机的概率就大点。然后想到这种对于选项太多，难以做决定的情况也很多，比如想去看电影，有好几部都想看，这个时候就可以随机一下，帮你做决定。其实对于这种小程序已经有了，但是他们都没有设置权重的功能，所以我还是决定自己做一个，现在代码是写完了，但是由于小程序是要用 https 的域名，所以目前还没有上线。</p><h3 id="3-中文版的-medium"><a href="#3-中文版的-medium" class="headerlink" title="3. 中文版的 medium"></a>3. 中文版的 medium</h3><p>这个项目的来历是因为我经常看 medium 上的文章，不过英语不是太好，所以很多时候都是都是翻译了之后再看的，然后我也会经常翻译这上面的文章到公众号里，但是就算翻译，也很花时间，而且有些是机器翻译的，所以比较的生硬。所以我就想着把 medium 上的文章爬下来，然后通过翻译 api 翻译之后得到一篇中文文章，然后中文文章每段判断都有原文，然后用户可以去修正翻译的中文，这样一次次的修正，相信文章被翻译得越来越好，就跟做开源项目一样。</p><p>在这个项目中我用的是 puppeteer 做的爬虫，然后翻译是用的划词翻译的接口。目前做到的地步只是可以爬文章，然后翻译文章(这个其实也不是那么简单，需要把英文的每个段落拿去翻译，然后再把每段的翻译组成文章)，对于用户修改中文这个还没做好，这个比较复杂，还要管理员审核啥的。有兴趣的小伙伴可以和我一起做。</p><h3 id="4-聚合-github-issue-博客"><a href="#4-聚合-github-issue-博客" class="headerlink" title="4. 聚合 github issue 博客"></a>4. 聚合 github issue 博客</h3><p>项目背景：经过我的观察，很多程序员喜欢在 github issue 里面写文章，往往这种人写的博客质量还比较高，但是 github 对于搜索 issue 还是比较鸡肋，搜索引擎搜的呢又不是很全，所以我就想着做一个聚合的网站，在网站上填一个仓库地址，就获取 issue 以及作者的信息，然后进行打标签，分类等操作，主要是方便查找，而且 UI 也可以定制得好看一些，同时还可以做订阅功能等。</p><p>现在初版快完成了，尽量在春节之前上线。</p><h2 id="其他方面的成长"><a href="#其他方面的成长" class="headerlink" title="其他方面的成长"></a>其他方面的成长</h2><p>虽然我们是程序员，但是人生里面不能只有技术，还应该学习一些其他的知识。</p><h3 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h3><p>理财的重要性我就不阐述了，说下我的经历吧，最开始接触理财的书籍我看的是一本《指数基金投资指南》,文中就说指数基金是巴菲特在公众场合唯一推荐的小白投资方式，无脑定投个几年也会赚，然后我就跟着作者的公众号推荐的一些指数，每个月投资了一点，投资了大半年了，目前还是亏的，我相信只是因为今年行情不好，中国没到牛市，算是给自己的心理安慰吧。</p><p>另外看了《富爸爸与穷爸爸》,这本书是一本畅销书，还是很推荐阅读的，里面提出的富人的金钱观，以及一些思维我觉得对我们为人处世，以及花钱都还是有帮助的。</p><p>还在得到上买了两门金融课程，当时为了学习炒股，所以就买了想学习，一门是《香帅的北大金融课》,现在我还没有补完，才看了一百多节，另外一门是陆蓉的《行为金融学》课程，这个是每节都追的，刚出来我就买了，还是挺有收获的，扩展了我的金融观，以及一些投资技巧，虽然现在股票还没赚，趁着现在没啥钱，多鼓捣，摸索经验，亏了也没多少钱，等到以后有钱了，亏了就亏大了。</p><p>在圣诞节女朋友看我之前一直想买《穷查理宝典》，她在圣诞节帮我买了，这本书我相信是会对我的思维有所帮助的，是讲的巴菲特的合伙人查理芒格的一些思考方式，巴菲特对查理芒格的评价很高，他觉得查理芒格比他自己更聪明。</p><h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><p>一直很喜欢极客时间的课程，当时也是想接触一下产品方面的，然后就买了《邱岳的产品实战》课来看，很愧疚，都更新完很久了，我现在也才看了一半，立个 flag 春节后一个月内一定要看完。</p><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>做公众号，或者说自媒体其实就是要写作嘛，做内容，另外还需要宣传，做营销，但是现在我想的是先把内容做好，所以就买了粥左罗的《新媒体写作 30 讲》来看，这个是早已看了两遍了，但是有很多自己还没有实践起来，最近粥老师又出新课了，差点又剁手了。</p><p>另外写作真的是一门很重要的技能，真心希望大家多写，打造自己的 IP。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在文章的开头我已经说了今年的我主要是三个角色的转变，学生变成了社会人，今年六月份毕业，来到了蘑菇街工作；从一个读者变成了一个自媒体人，自己开始做公众号，开始经常写作；从一个读者变成了一个自媒体人，开始在网上买各种课程，在这个充满着变化的世界里不断的为自己充能，学习新知识。</p><p>不知道有没有觉得我的项目可能有类似的竞品了，为什么还要做，我的回答就是因为我还不够满意，我就想做一个我自己满意的东西，就像尤大一样，当初写 vue 只是想写一款自己好用的框架，没想到大家也觉得好用，所以就火了，我的项目虽然没抱着会火的心态，但是让我自己用着很舒服也是一件不错的事儿呢！</p><p>学到的技术尽量想办法实践，不实践，永远只是纸上谈兵，而且纸上得到终觉浅。拿自己举例吧，我不是做了好几个自己的小项目么，里面都需要服务端吧，所以这个时候就是学习 node 的好机会，koa、ts 都用起来，前端也得写，所以如果你想学习 vue，前端就用 vue 写，想学 angular ，前端就用 angular 写，最好学习了一个技术，有一定的项目经验，才能说你会了。</p><p>另外再说下编辑器，现在 VSCode 很火，我司大部分前端开发者都在用，我也承认它是一款非常优秀的编辑器，但是 VSCode 还是有些地方我用着不是太满意，所以我还是用继续用了 Emacs。</p><p>哎，我这该死的，无处安放的 xx!</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程里面的基本工具函数实现</title>
    <link href="/index.php/archives/218/"/>
    <url>/index.php/archives/218/</url>
    
    <content type="html"><![CDATA[<h2 id="compose-实现"><a href="#compose-实现" class="headerlink" title="compose 实现"></a>compose 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> args.reduceRight(<span class="hljs-function">(<span class="hljs-params">result, fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> fn(result)<br>    &#125;, result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="pipe-实现"><a href="#pipe-实现" class="headerlink" title="pipe 实现"></a>pipe 实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function">(<span class="hljs-params">result, fn</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> fn(result)<br>    &#125;, result)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="柯里化实现"><a href="#柯里化实现" class="headerlink" title="柯里化实现"></a>柯里化实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) &#123;<br>        <span class="hljs-keyword">return</span> fn(...args)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> currying(fn, ...args, ...args2)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="部分应用实现"><a href="#部分应用实现" class="headerlink" title="部分应用实现"></a>部分应用实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">partial</span>(<span class="hljs-params">fn, ...args</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">..._arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> fn(...args, ..._arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
      <tag>函数式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>群里提问的艺术</title>
    <link href="/index.php/archives/215/"/>
    <url>/index.php/archives/215/</url>
    
    <content type="html"><![CDATA[<p>现在互联网发达的时代，大家都会有很多的群，xxx 交流群、xxx 技术交流、xxx开发群、xxx技术学习群等，大家的初心可能都是想交流的，遇到点问题然后就可以在群里问。</p><p>然而很多时候你问的问题没人回答；也有时候问了半天还是没找到答案；也有时候当你把问题发出来了，别人正准备回答你的时候，你说知道了；然后刚开始群里很活跃，慢慢的就死了。</p><p>其实以上问题，都是大家不想看到的，然而<strong>在群里提问</strong>是我们加入群的初心，但是很多人做不好，最终导致你的问题无人解答，群慢慢的失去意义。</p><p>今天我所谈的就是<strong>群里提问的艺术</strong>，让你的问题快速得到解决。</p><p>我将今天的问题分成以下三部分进行介绍：</p><ul><li>提问之前</li><li>提问之时，怎么提问</li><li>注意事项</li></ul><h2 id="提问之前"><a href="#提问之前" class="headerlink" title="提问之前"></a>提问之前</h2><p>在群里提问之前首先我们应该做好功课，看自己是否完成以下步骤，否则你的提问将一塌糊涂，大概率得不到想要 的答案。</p><ol><li>尝试自己解决</li><li>不能自己解决应该准备的哪些</li></ol><h3 id="尝试自己解决"><a href="#尝试自己解决" class="headerlink" title="尝试自己解决"></a>尝试自己解决</h3><p>尝试自己解决是非常重要的一步，这也是我们能否经过这个问题能够成长的关键所在。</p><ol><li><strong>通过搜索引擎搜索</strong>：baidu 或者 google(推荐)，搜索结果中前三页如果找不到你想要的信息，就进行下一步吧。对于成熟的开源项目，你遇到的问题，很可能别人也遇到过。这时通过 Google、StackOverflow 等网站的搜索服务，可以帮你快速定位并解决问题。永远记住，地球上的你并不孤单，包括你遇到的问题。</li><li><strong>查阅手册/文档：</strong>确保自己阅读过至少一次官方文档。这样在遇到问题时，如果能回忆起只言片语，就可以再去读一遍相关文档，问题往往也就解决了。</li><li><strong>查阅社区/论坛：</strong>阅读常见问题文件（FAQ）或者开源项目的 issue，或者论坛(类似 <a href="http://react-china.org/">react china</a>)</li><li><strong>询问朋友：</strong>如果你使用的开源软件，在朋友圈或同事圈里也有人使用，那么抬起你的脚、或拿起你的电话，真挚诚恳的探讨不会遭遇拒绝，而会增进友谊。不要犹豫，你的内心渴望面对面交流，你的朋友也是。</li><li><strong>自检并不断测试：</strong>试自己检查或试验以找到答案。</li><li><strong>阅读源码(这步非必须)：</strong>如果你是程序开发者，尽量尝试阅读源码以找到答案。</li></ol><p>经过以上 6 步或者 5 步你都无法解决遇到的问题，那么你确实针对这个问题能力有限，准备去群里请教了，那么在尝试自己解决之后无果，应该做哪些准备呢？</p><h3 id="不能自己解决应该准备的哪些"><a href="#不能自己解决应该准备的哪些" class="headerlink" title="不能自己解决应该准备的哪些"></a>不能自己解决应该准备的哪些</h3><ol><li><strong>一定要明白自己想要问什么问题</strong>：不能自己都说不清自己想要问什么问题，那么群里提问你也问不出什么来。</li><li><strong>梳理准备您的问题</strong>：要说明之前你都干了些什么。</li><li><strong>要用言简意赅的语言</strong>：这个是我们作为职场一个必备的技能，说重点，言简意赅。</li></ol><h2 id="怎么提问"><a href="#怎么提问" class="headerlink" title="怎么提问"></a>怎么提问</h2><p>抱着平和对等的心态，找到合适的途径后，就得静下心来将遇到的问题写成文字。书写文字不是一件简单的事情，我们可以从遵循一些简单的规则开始。</p><h3 id="用词准确，问题明确"><a href="#用词准确，问题明确" class="headerlink" title="用词准确，问题明确"></a>用词准确，问题明确</h3><p>标题要简洁清晰，要言之有物。</p><blockquote><p>Bad：救命呀/急/跪求，遇到了一个 react 问题，xxx 组件渲染不出来</p></blockquote><blockquote><p>Good：在使用 xxx 版本的 react ，我操作了 xxx，也写了 xxx，但是 xxx 组件渲染不出来</p></blockquote><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><h3 id="描述清晰，信息充足"><a href="#描述清晰，信息充足" class="headerlink" title="描述清晰，信息充足"></a>描述清晰，信息充足</h3><ol><li><p><strong>准确有效的信息：</strong>描述事实，而不是猜测，如果你想给出你的猜测，一定要先描述事实，给你的猜测一些证据，不然就不要猜测。</p></li><li><p><strong>问题表现/内容：</strong>按照时间顺序列出问题症状。问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p></li><li><p><strong>简单的做过什么尝试：</strong>在描述你做过什么尝试的时候，简单的你描述你做了哪些尝试就行，为什么要这么做其实不是那么重要。</p><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p>玉伯有句话是这么说的：</p><blockquote><p>提问者选择的路本身就是一条崎岖之路，对于要解决的问题，实际上有更好的方式。这种情况下，描述清楚目标，讲清楚要干什么非常重要。</p></blockquote></li><li><p><strong>想要问到什么：</strong>提供建议？发送一段代码？检查你的补丁或者别的？在群里经常会出现这种情况，当某个人发了一段文字，另外的人说：你想问什么？</p><p>所以我们在问问题的时候一定要把你想要问到什么，这个目标想清楚。</p></li><li><p><strong>提供尽量多的信息：</strong>尽量提供可重现的例子，你可以在 <a href="%5Bhttp://www.jsbin.com%5D(http://www.jsbin.com/)">jsbin</a>、<a href="http://runjs.cn/">runjs</a>、<a href="%5Bhttp://www.jsfiddle.net%5D(http://www.jsfiddle.net/)">jsfiddle</a>、<a href="http://codepen.io/">codepen</a> 等这些地方提供一个可重现的例子。即使你是一个很大的项目，想办法把你需要验证的点提取出来，如果确实无法提取，就贴一些代码，出现问题那行代码周围的代码(周围的相关代码都要，因为你可能觉得不是他们的问题，但也许就是，不然你觉得的都是对的，你就不会不知道怎么解决了)。</p></li></ol><h3 id="避免一些毫无意义的问题"><a href="#避免一些毫无意义的问题" class="headerlink" title="避免一些毫无意义的问题"></a>避免一些毫无意义的问题</h3><p>经常会有人问一些毫无意义的问题，比如这样的：</p><blockquote><p>Bad：有没有人会xxx？</p></blockquote><blockquote><p>Bad: 有没有人在？</p></blockquote><blockquote><p>Bad: 谁能帮我解决一个问题？</p></blockquote><p>面对这种问题，别人就很难预估你这个问题需要解决多久，也很难判断自己是否能解决这个问题，如果他回答了你，意味着你就是有空而且很在行，所以他还是选择不出声。这个就跟微信私聊的时候说：”在吗？“ 这种一个意思。</p><blockquote><p>Bad: 什么是 JavaScript？</p></blockquote><p>这种问题也是，很明显通过搜索引擎就能搞定的，要是下次还有这种问题，你就把这个图发给它。</p><p><img src="http://imgs.taoweng.site/2019-06-10-113803.jpg"></p><h3 id="建议的问法："><a href="#建议的问法：" class="headerlink" title="建议的问法："></a>建议的问法：</h3><ol><li><p>有问题直接问。比如：ES6什么时候雄霸天下，前端什么时候一统江湖？</p></li><li><p>直接说场景：我在做xx端东西的时候，在 window 7 平台的 IE7 版本下遇到了左右不对齐问题，具体如图所示img，代码地址：<a href="http://www.jsbin.com/xxxx%EF%BC%8C%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%89%BE%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%8C%E8%AF%95%E4%BA%86%E4%B9%8B%E5%90%8E%E8%BF%98%E6%98%AF%E6%9C%89%E5%90%8C%E6%A0%B7%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82%E8%AF%B7%E6%9C%89%E7%A9%BA%E7%9A%84%E5%90%8C%E5%AD%A6%E5%B8%AE%E6%88%91%E7%9C%8B%E7%9C%8B%E6%98%AF%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F">http://www.jsbin.com/xxxx，在百度中找到的答案，试了之后还是有同样的问题。请有空的同学帮我看看是什么问题？</a></p></li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>提前做好冷场的准备：也许别人在忙，也许这个问题太简单了，也许没人做过这块，如果冷场了，没人回答，赶紧换下一个群。</li><li>谦虚，别人没有义务帮你解决问题，往往大牛的时间比你少，比你珍贵。</li><li>没有一定的自学能力，问到问题就伸手的不适合玩这个。</li><li>群唯一的作用就是：扯淡、交流、分享，以上几条为前提。</li></ul><p>如果觉得问题记不住，收藏一下这个图吧：</p><p><img src="http://imgs.taoweng.site/2019-06-10-113804.jpg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>其实对于问问题，我们换位思考一下就更好了，这其实也是人际交往的方式，站在看你提问题的角度，想想当别人提问题的时候，你想让他问什么，你才愿意去回答。</p><p>当然除了在群里提问，在社区里提问，论坛里提问都有一定的规范，后面再慢慢补充吧。</p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>交流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程资料</title>
    <link href="/index.php/archives/197/"/>
    <url>/index.php/archives/197/</url>
    
    <content type="html"><![CDATA[<h2 id="Eric-Elliott-函数式教程"><a href="#Eric-Elliott-函数式教程" class="headerlink" title="Eric Elliott 函数式教程"></a>Eric Elliott 函数式教程</h2><ol><li><a href="https://www.zcfy.cc/article/master-the-javascript-interview-what-is-functional-programming-2221.html">征服 JavaScript 面试: 什么是函数式编程？</a></li><li><a href="https://www.zcfy.cc/article/the-rise-and-fall-and-rise-of-functional-programming-composing-software-2693.html">组合软件：1. 函数式编程的兴衰</a></li><li><a href="https://juejin.im/post/58f5a2ecb123db2fa2b1b244">为什么用 JavaScript 学习函数式编程？（软件编写）（第二部分）</a></li><li><a href="https://juejin.im/post/58f58b06da2f60005d43388b">函数式程序员的 JavaScript 简介 (软件编写)（第三部分）</a></li><li><a href="https://juejin.im/post/58f6d6ff570c3500564fbddc">高阶函数（软件编写）（第四部分）</a></li><li><a href="https://juejin.im/post/58f44082da2f60005d3a3710">Reduce（软件编写）（第五部分）</a></li><li><a href="https://juejin.im/post/58f58d5da0bb9f006aac3e8d">Functor 与 Category （软件编写）（第六部分）</a></li><li><a href="https://juejin.im/post/594a2cf6ac502e006bc0bc3a">函数式 Mixin（软件编写）（第七部分）</a></li><li><a href="https://juejin.im/post/59cf43ce6fb9a00a4e67cd36">为什么在使用了类之后会使得组合变得愈发困难（软件编写）（第九部分）</a></li><li><a href="https://juejin.im/post/59e3f3786fb9a0450166ff7b">借助函数完成可组合的数据类型（软件编写）（第十部分）</a></li><li><a href="https://juejin.im/post/59e55dbbf265da43333d7652">JavaScript 让 Monad 更简单（软件编写）（第十一部分）</a></li></ol><h2 id="JavaScript-轻量级函数式编程"><a href="#JavaScript-轻量级函数式编程" class="headerlink" title="JavaScript 轻量级函数式编程"></a>JavaScript 轻量级函数式编程</h2><p><a href="https://github.com/ikcamp/Functional-Light-JS">JavaScript 轻量级函数式编程</a></p><h2 id="Starkwang-log"><a href="#Starkwang-log" class="headerlink" title="Starkwang.log"></a>Starkwang.log</h2><ol><li><p><a href="https://zhuanlan.zhihu.com/p/21714695">JavaScript函数式编程（一）</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/21926955">JavaScript函数式编程（二）</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/22094473">JavaScript函数式编程（三）</a></p></li></ol><h2 id="如果你想成为函数式编程爱好者"><a href="#如果你想成为函数式编程爱好者" class="headerlink" title="如果你想成为函数式编程爱好者"></a>如果你想成为函数式编程爱好者</h2><ol><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-1.html">如何成为一位函数式编程爱好者(Part 1)</a></li><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-2.html">如何成为一位函数式编程爱好者(Part 2)</a></li><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-3.html">如何成为一位函数式编程爱好者(Part 3)</a></li><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-4.html">如何成为一位函数式编程爱好者(Part 4)</a></li><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-5.html">如何成为一位函数式编程爱好者(Part 5)</a></li><li><a href="https://www.w3cplus.com/javascript/so-you-want-to-be-a-functional-programmer-part-6.html">如何成为一位函数式编程爱好者(Part 6)</a></li></ol><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><ul><li>《JavaScript 函数式编程指南》推荐</li><li>《JavaScript 函数式编程思想》推荐</li><li>《JavaScript ES6 函数式入门经典》看了上面两本这本就不用买了</li><li>《JavaScript 函数式编程》<h2 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h2></li><li><a href="https://folktale.origamitower.com/">https://folktale.origamitower.com/</a></li><li><a href="https://github.com/fantasyland/fantasy-land">https://github.com/fantasyland/fantasy-land</a></li><li><a href="http://ramda.cn/">http://ramda.cn/</a></li><li><a href="http://lodash.think2011.net/">http://lodash.think2011.net/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>另一个视角看待这次 antd</title>
    <link href="/index.php/archives/191/"/>
    <url>/index.php/archives/191/</url>
    
    <content type="html"><![CDATA[<p>公众号相信大家今天都已经知道了 antd 这次的事故了，不知道的简单回顾一下。</p><p>今天圣诞节，所以在 type 是 primary 的 Button 上都加上了雪花。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-699e66f80ccb9d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="雪花"></p><p>就是在 <code>antd 3.9.3</code> 的时候增加了一个定时器，到 12 月 25 的时候增加一个 christmas 的 css 类，还给 title 改为了 <code>Ho Ho Ho</code>。具体 commit 见：<a href="https://github.com/ant-design/ant-design/commit/00aebeb9756afecc884ad48486084836b9a2707a">https://github.com/ant-design/ant-design/commit/00aebeb9756afecc884ad48486084836b9a2707a</a></p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-eaaec4416e00c938.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ts"></p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-20fdb3ed70f0ea05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="css"></p><p>然后就导致今天开发者早上一来看，就觉得莫名其妙，还以为是病毒啥的，还有人因此被解雇(issue 上说的，不知道是否是真)，总之，这个事情还是挺严重的。</p><p>作为一个<strong>有温度的前端号</strong>，肯定不是带你们吃瓜的，要是带你们吃瓜，肯定大早上的这篇文章就出来了，我们从另外的角度来看下这个问题。</p><ul><li><p>功不抵过</p></li><li><p>开源及责任</p></li><li><p>批评没有任何好处</p></li></ul><h3 id="功不抵过"><a href="#功不抵过" class="headerlink" title="功不抵过"></a>功不抵过</h3><p>Antd 作为全世界最好的 React 前端组件库之一，目前将近 4 万的 star，国内外很多企业都会使用 antd 做前端开发。</p><p>我估计最近几年大部分人接触 React 的人，使用的 UI 库都会是 antd，Vue 的话可能 Element UI 和 iView 还可以拼杀一下，但是 antd 在 React 界是绝对的老大，这是 antd 的功。</p><p>但是这一次彩蛋事件，就导致很多人因此而放弃它。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-a2002aa190f6ceb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>然后网上骂声一片。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-970879efe31c8741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-d4999fbda31a743a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>这是为什么呢？</p><p>因为这次失误触犯了使用者的底线，本来使用 antd 就是因为他的稳定，用起来放心。</p><p>结果这个彩蛋，出其不意，在没有给用户任何提示的情况下，悄悄的代码里面加一些“副作用”，导致让用户感觉用 antd 不再放心，担心下次加点获取用户信息啥的。</p><p>所以呀，能做好的就一定要保证一直好下去，一旦出现了触犯原则的事情就是好事不出门，坏事传千里，前端娱乐圈再次火起来了，搞 py 的、 Java 的等都知道 antd 了，可以说这次“<strong>宣传</strong>”很到位。</p><h3 id="批评没有任何好处"><a href="#批评没有任何好处" class="headerlink" title="批评没有任何好处"></a>批评没有任何好处</h3><p>在卡耐基的《人性的弱点》第一章里就说到</p><blockquote><p>批评是没有用的，因为它使人增加一层防御，而且竭力地替自己辩护。批评也是危险的，它会伤害了一个人的自尊和自重的感觉，并激起他的反抗。</p></blockquote><p>我看到很多人在 issue 里，在知乎上对 antd 团队，对蚂蚁金服，对阿里开源进行各种批评，我感到很痛心。</p><p>因为在我的眼里，antd 真的很优秀，阿里的开源也做得很好，我很怕开发者扛不住他们的批评，而导致他们的开源热情一点点较少，或者阿里内部扛不住舆论，把相关人员给开了。</p><p>这次偏右大大主动一个人承担了责任，也有人在 issue 里@他出来挨打</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-c180dadbaf2fac1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>偏右可是 “antd 之父”，他一个人对 antd 的贡献可能将近百分之四十(看贡献图看到的，没有统计过)，下面是最近提交的贡献度。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-a8bf6bf02d48de20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="贡献度"></p><p>要是阿里内部扛不住压力，或是他自己扛不住，辞职了，那么你会开心吗？可能你会开心，但是对于整个 React 社区，对于还要使用 Antd 的人来说，又有什么好处呢？可能 issue 解决得慢一点，PR 合并得慢一点，bug 可能多一点。</p><p>我想说道这里大家应该已经明白了，过分的批评真的没有任何好处，你可以回想你自己在生活中发生的事儿，哪一次你对别人的批评，让对方觉得你批评得好，感觉很爽的。相反的，发自内心的赞赏别人，是待人成功的秘诀。</p><p>可能有些人又会说了，你的意思是他做这事儿，我还应该去赞赏他了？对于这种问题，我想劝你去看下《人性的弱点》这本书。你站在被责怪人的角度考虑一下，是你的批评让他以后会做得更好，还是你的鼓励呢？</p><p>批评、责怪别人会让人感到反感，让人不爽，让人产生抵触情绪，这是人的天性。</p><p>说到这里，我声明一下，我还是会使用 antd 的产品，我相信他们经过这次，会更严格的规范代码流程，code review 会更仔细。我也希望大家不要对他们失去信心，虽然我不是阿里的，但是我看好他们团队，他们团队都做不好，国内还能有多少团队比他们更好呢？</p><h3 id="开源及责任"><a href="#开源及责任" class="headerlink" title="开源及责任"></a>开源及责任</h3><p>这个掘金站长在这篇文章(<a href="https://juejin.im/post/5c21a3ea5188254eaa5c4486)%E4%B8%AD%E5%B7%B2%E7%BB%8F%E8%AF%B4%E5%BE%97%E5%BE%88%E8%AF%A6%E7%BB%86%E4%BA%86">https://juejin.im/post/5c21a3ea5188254eaa5c4486)中已经说得很详细了</a></p><p>虽然在前面我强调不要再去批评指责他们了，但是不代表他们所做的就是正确的，玉伯也发表声明会吸取这次教训，请大家持续监督。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-fc536ee3e8e9f3f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="玉伯知乎回答"></p><h3 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h3><p>真心希望我的读者不要做一个键盘侠，不仅仅只做一个吃瓜群众，在吃瓜的同时能挖掘到其他的东西，别人的教训是否会发生在自己身上，他们这种大佬都会犯这样的错误，何况我们这些一般的人呢？</p><blockquote><p>最后我觉得有点奇怪的是，偏右 issue 里面回了个“早就做好了被骂的准备”，让我怀疑可能这个想法不是他的主意，一个正常人会知道被人骂还这样搞么，一点疑惑，但是这都不是这篇文章的重点。</p></blockquote><p>相关链接：</p><p><a href="https://github.com/ant-design/ant-design/issues/13098">Christmas easter egg</a></p><p><a href="https://github.com/ant-design/ant-design/issues/13818">Please remove Christmas Easter Egg for Ant Design framework</a></p><p><a href="https://www.zhihu.com/question/306858501">知乎：如何看待 Ant Design 圣诞节彩蛋事件？</a></p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阿里</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识函数式编程</title>
    <link href="/index.php/archives/190/"/>
    <url>/index.php/archives/190/</url>
    
    <content type="html"><![CDATA[<p>最开始接触函数式编程的时候是在小米工作的时候，那个时候看老大以前写的代码各种 compose，然后一些 ramda 的一些工具函数，看着很吃力，然后极力吐槽函数式编程，现在回想起来，那个时候的自己真的是见识短浅，只想说,’真香’。</p><p>最近在研究函数式编程，真的是在学习的过程中感觉自己的思维提升了很多，抽象能力大大的提高了，让我深深的感受到了函数式编程的魅力。所以我打算后面用 5 到 8 篇的篇幅，详细的介绍一下函数式编程的思想，基础、如何设计、测试等。</p><p>今天这篇文章主要介绍函数式编程的思想。</p><ul><li>函数式编程有用吗？</li><li>什么是函数式编程？</li><li>函数式编程的优点。</li></ul><blockquote><p>面向对象编程(OOP)通过封装变化使得代码更易理解。<br>函数式编程(FP)通过最小化变化使得代码更易理解。<br>– Michacel Feathers（Twitter）</p></blockquote><p>总所周知 JavaScript 是一种拥有很多共享状态的动态语言，慢慢的，代码就会积累足够的复杂性，变得笨拙难以维护。面向对象设计能帮我们在一定程度上解决这个问题，但是还不够。</p><p>由于有很多的状态，所以处理数据流和变化的传递显得尤为重要，不知道你们知道<strong>响应式编程</strong>与否，这种编程范式有助于处理 JavaScript 的异步或者事件响应。总之，当我们在设计应用程序的时候，我们应该考虑是否遵守了以下的设计原则。</p><ul><li>可扩展性–我是否需要不断地重构代码来支持额外的功能？</li><li>易模块化–如果我更改了一个文件，另一个文件是否会受到影响？</li><li>可重用性–是否有很多重复的代码？</li><li>可测性–给这些函数添加单元测试是否让我纠结？</li><li>易推理性–我写的代码是否非结构化严重并难以推理？</li></ul><p>我这能这么跟你说，一旦你学会了函数式编程，这些问题迎刃而解，本来函数式编程就是这个思想，一旦你掌握了函数式，然后你再学习响应式编程那就比较容易懂了，这是我亲身体会的。我之前在学 Rxjs 的时候是真的痛苦，说实话，Rxjs 是我学过最难的库了，没有之一。在经历过痛苦的一两个月之后，有些东西还是不能融会贯通，知道我最近研究函数式编程，才觉得是理所当然。毫无夸张，我也尽量在后面的文章中给大家介绍一下 Rxjs，这个话题我也在公司分享过。</p><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>简单来说，函数式编程是一种强调以函数使用为主的软件开发风格。看到这句我想你还是一脸懵逼，不知道函数式编程是啥，不要着急，看到最后我相信你会明白的。</p><p>还有一点你要记住，函数式编程的目的是使用函数来<strong>抽象作用在数据之上的控制流和操作</strong>，从而在系统中<strong>消除副作用</strong>并<strong>减少对状态的改变。</strong></p><p>下面我们通过例子来简单的演示一下函数式编程的魅力。</p><p>现在的需求就是输出在网页上输出 <code>“Hello World”</code>。</p><p>可能初学者会这么写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#msg&#x27;</span>).innerHTML = <span class="hljs-string">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>这个程序很简单，但是所有代码都是死的，不能重用，如果想改变消息的格式、内容等就需要重写整个表达式，所以可能有经验的前端开发者会这么写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printMessage</span>(<span class="hljs-params">elementId, format, message</span>) </span>&#123;<br>    <span class="hljs-built_in">document</span>.querySelector(elementId).innerHTML = <span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;format&#125;</span>&gt;<span class="hljs-subst">$&#123;message&#125;</span>&lt;/<span class="hljs-subst">$&#123;format&#125;</span>&gt;`</span><br>&#125;<br><br>printMessage(<span class="hljs-string">&#x27;msg&#x27;</span>, <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这样确实有所改进，但是任然不是一段可重用的代码，如果是要将文本写入文件，不是非 HTML，或者我想重复的显示 <code>Hello World</code>。</p><p>那么作为一个函数式开发者会怎么写这段代码呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> printMessage = compose(addToDom(<span class="hljs-string">&#x27;msg&#x27;</span>), h1, echo)<br><br>printMessage(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><p>解释一下这段代码，其中的 <code>h1</code> 和 <code>echo</code> 都是函数，<code>addToDom </code> 很明显也能看出它是函数，那么我们为什么要写成这样呢？看起来多了很多函数一样。</p><p>其实我们是讲程序分解为一些更可重用、更可靠且更易于理解的部分，然后再将他们组合起来，形成一个更易推理的程序整体，这是我们前面谈到的基本原则。</p><blockquote><p>compose 简单解释一下，他会让函数从最后一个参数顺序执行到第一个参数，compose 的每个参数都是函数，不明白的可以查一下，在 redux 的中间件部分这个函数式精华。</p></blockquote><p>可以看到我们是将一个任务拆分成多个最小颗粒的函数，然后通过组合的方式来完成我们的任务，这跟我们组件化的思想很类似，将整个页面拆分成若干个组件，然后拼装起来完成我们的整个页面。在函数式编程里面，组合是一个非常非常非常重要的思想。</p><p>好，我们现在再改变一下需求，现在我们需要将文本重复三遍，打印到控制台。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> printMessaage = compose(<span class="hljs-built_in">console</span>.log, repeat(<span class="hljs-number">3</span>), echo)<br><br>printMessage(‘Hello World’)<br></code></pre></td></tr></table></figure><p>可以看到我们更改了需求并没有去修改内部逻辑，只是重组了一下函数而已。</p><p>可以看到函数式编程在开发中具有声明模式。为了充分理解函数式编程，我们先来看下几个基本概念。</p><ul><li>声明式编程</li><li>纯函数</li><li>引用透明</li><li>不可变性</li></ul><h3 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h3><p>函数式编程属于声明是编程范式：这种范式会<strong>描述一系列的操作</strong>，但并不会<strong>暴露它们是如何实现的</strong>或是<strong>数据流如何传过它们</strong>。</p><p>我们所熟知的 SQL 语句就是一种很典型的声明式编程，它由一个个<strong>描述</strong>查询结果应该是什么样的断言组成，对数据检索的内部机制进行了<strong>抽象</strong>。</p><p>我们再来看一组代码再来对比一下命令式编程和声明式编程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 命令式方式</span><br><span class="hljs-keyword">var</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>    array[i] = <span class="hljs-built_in">Math</span>.pow(array[i], <span class="hljs-number">2</span>)<br>&#125;<br><br>array; <span class="hljs-comment">// [0, 1, 4, 9]</span><br><br><span class="hljs-comment">// 声明式方式</span><br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> <span class="hljs-built_in">Math</span>.pow(num, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>可以看到命令式很具体的告诉计算机如何执行某个任务。</p><p>而声明式是将程序的<strong>描述与求值</strong>分离开来。它关注如何用各种<strong>表达式</strong>来描述程序逻辑，而不一定要指明其控制流或状态关系的变化。</p><p>为什么我们要去掉代码循环呢？循环是一种重要的命令控制结构，但很难重用，并且很难插入其他操作中。而函数式编程旨在尽可能的提高代码的无状态性和不变性。要做到这一点，就要学会使用<strong>无副作用</strong>的函数–也称纯函数</p><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数指<strong>没有副作用</strong>的函数。相同的输入有相同的输出，就跟我们上学的函数一样。</p><p>常常这些情况会产生副作用。</p><ul><li>改变一个全局的变量、属性或数据结构</li><li>改变一个函数参数的原始值</li><li>处理用户输入</li><li>抛出一个异常</li><li>屏幕打印或记录日志</li><li>查询 HTML 文档，浏览器的 Cookie 或访问数据库</li></ul><p>举一个简单的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数就是不纯的，它读取了外部的变量，可能会觉得这段代码没有什么问题，但是我们要知道这种依赖外部变量来进行的计算，计算结果很难预测，你也有可能在其他地方修改了 counter 的值，导致你 increment 出来的值不是你预期的。</p><p>对于纯函数有以下性质：</p><ul><li>仅取决于提供的输入，而不依赖于任何在函数求值或调用间隔时可能变化的隐藏状态和外部状态。</li><li>不会造成超出作用域的变化，例如修改全局变量或引用传递的参数。</li></ul><p>但是在我们平时的开发中，有一些副作用是难以避免的，与外部的存储系统或 DOM 交互等，但是我们可以通过将其从主逻辑中分离出来，使他们易于管理。</p><p>现在我们有一个小需求：通过 id 找到学生的记录并渲染在浏览器(在写程序的时候要想到可能也会写到控制台，数据库或者文件，所以要想如何让自己的代码能重用)中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 命令式代码</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showStudent</span>(<span class="hljs-params">id</span>) </span>&#123;<br>    <span class="hljs-comment">// 这里假如是同步查询</span><br>    <span class="hljs-keyword">var</span> student = db.get(id)<br>    <span class="hljs-keyword">if</span>(student !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 读取外部的 elementId</span><br>          <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">`<span class="hljs-subst">$&#123;elementId&#125;</span>`</span>).innerHTML = <span class="hljs-string">`<span class="hljs-subst">$&#123;student.id&#125;</span>,<span class="hljs-subst">$&#123;student.name&#125;</span>,<span class="hljs-subst">$&#123;student.lastname&#125;</span>`</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;not found&#x27;</span>)<br>    &#125;<br>&#125;<br><br>showStudent(<span class="hljs-string">&#x27;666&#x27;</span>)<br><br><span class="hljs-comment">// 函数式代码</span><br><br><span class="hljs-comment">// 通过 find 函数找到学生</span><br><span class="hljs-keyword">var</span> find = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">db, id</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> obj = db.get(id)<br>    <span class="hljs-keyword">if</span>(obj === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;not fount&#x27;</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> obj<br>&#125;)<br><br><span class="hljs-comment">// 将学生对象 format</span><br><span class="hljs-keyword">var</span> csv = <span class="hljs-function">(<span class="hljs-params">student</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;student.id&#125;</span>,<span class="hljs-subst">$&#123;student.name&#125;</span>,<span class="hljs-subst">$&#123;student.lastname&#125;</span>`</span><br><br><span class="hljs-comment">// 在屏幕上显示</span><br><span class="hljs-keyword">var</span> append = curry(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elementId, info</span>) </span>&#123;<br>    <span class="hljs-built_in">document</span>.querySelector(elementId).innerHTML = info<br>&#125;)<br><br><span class="hljs-keyword">var</span> showStudent = compose(append(<span class="hljs-string">&#x27;#student-info&#x27;</span>), csv, find(db))<br><br>showStudent(<span class="hljs-string">&#x27;666&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果看不懂 curry (柯里化)的先不着急，这是一个对于新手来说比较难理解的一个概念，在函数式编程里面起着至关重要的作用。</p><p>可以看到函数式代码通过较少这些函数的长度，将 showStudent 编写为小函数的组合。这个程序还不够完美，但是已经可以展现出相比于命令式的很多优势了。</p><ul><li>灵活。有三个可重用的组件</li><li>声明式的风格，给高阶步骤提供了一个清晰视图，增强了代码的可读性</li><li>另外是将纯函数与不纯的行为分离出来。</li></ul><p>我们看到纯函数的输出结果是一致的，可预测的，相同的输入会有相同的返回值，这个其实也被称为<strong>引用透明</strong>。</p><h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>引用透明是定义一个纯函数较为正确的方法。纯度在这个意义上表面一个函数的参数和返回值之间映射的纯的关系。如果一个函数对于相同的输入始终产生相同的结果，那么我们就说它是<strong>引用透明</strong>。</p><p>这个概念很容易理解，简单的举两个例子就行了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">// 非引用透明</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">increment</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> ++counter<br>&#125;<br><br><span class="hljs-comment">// 引用透明</span><br><span class="hljs-keyword">var</span> increment = <span class="hljs-function">(<span class="hljs-params">counter</span>) =&gt;</span> counter + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><p>其实对于箭头函数在函数式编程里面有一个高大上的名字，叫 lambda 表达式，对于这种匿名函数在学术上就是叫 lambda 表达式，现在在 Java 里面也是支持的。</p></blockquote><h3 id="不可变数据"><a href="#不可变数据" class="headerlink" title="不可变数据"></a>不可变数据</h3><p>不可变数据是指那些创建后不能更改的数据。与许多其他语言一样，JavaScript 里有一些基本类型(String,Number 等)从本质上是不可变的，但是对象就是在任意的地方可变。</p><p>考虑一个简单的数组排序代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> sortDesc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> a - b<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>]<br>sortDesc(arr) <span class="hljs-comment">// [1, 2, 3]</span><br>arr <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>这段代码看似没什么问题，但是会导致在排序的过程中会产生副作用，修改了原始引用，可以看到原始的 arr 变成了 <code>[1, 2, 3]</code>。这是一个语言缺陷，后面会介绍如何克服。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>使用纯函数的代码绝不会更改或破坏全局状态，有助于提高代码的可测试性和可维护性</li><li>函数式编程采用声明式的风格，易于推理，提高代码的可读性。</li><li>函数式编程将函数视为积木，通过一等高阶函数来提高代码的模块化和可重用性。</li><li>可以利用响应式编程组合各个函数来降低事件驱动程序的复杂性(这点后面可能会单独拿一篇来进行讲解)。</li></ul><blockquote><p>内容来至于《JavaScript函数式编程指南》</p></blockquote><p>欢迎关注个人公众号【前端桃园】，公号更新频率比掘金快。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/19/167c4a7aa2e61e21?w=344&h=344&f=jpeg&s=8203"></p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>函数式编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三个比它们等效 ES5 速度慢的 ES 6 函数</title>
    <link href="/index.php/archives/226/"/>
    <url>/index.php/archives/226/</url>
    
    <content type="html"><![CDATA[<p>[Meting]<br>[Music server=”tencent” id=”000AwJtd3Wp27b” type=”song”/]<br>[/Meting]</p><p>我在 medium 上看到一篇 <strong>3 JavaScript Performance Mistakes You Should Stop Doing</strong> 文章(点击阅读全文可以查看原文，需要科学上网)，大概意思就是说<strong>有 3 个 JavaScript 性能错误，你不应该再去写了</strong>。很多“歪果仁”也是一看到这个标题就开始<strong>“喷”</strong>作者了，下文会详细说。我先介绍下这篇文章的主要内容</p><h3 id="文章主要内容："><a href="#文章主要内容：" class="headerlink" title="文章主要内容："></a>文章主要内容：</h3><p>当 ES5 发布的时候，JavaScript 引入了很多新的数组函数。其中包括 forEach，reduce，map，filter - 它们让我们感觉语言在不断增长，功能越来越强大，编写代码变得更加有趣和流畅，结果更易于阅读和理解。</p><p>大约在同一时间，一个新的环境–Node.js，它使我们能够从前端到后端平稳过渡，同时真正重新定义完整的全栈开发。</p><p>所以作者就测试了一下新提供的这些方法是否会影响我们程序的性能。他在 macOS 上对Node.js v10.11.0 和 Chrome 浏览器执行了以下测试。</p><p><strong>1. 循环数组</strong></p><p>他想到的第一次很常见的场景，就是计算一下 10k 项的总和。然后比较了使用 for，for of，while，forEach 和 reduce 的随机 10k 项的总和。运行测试 10,000 次返回以下结果：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">For</span> <span class="hljs-keyword">Loop</span>, average <span class="hljs-keyword">loop</span> <span class="hljs-type">time</span>: ~<span class="hljs-number">10</span> microseconds<br><span class="hljs-keyword">For</span>-<span class="hljs-keyword">Of</span>, average <span class="hljs-keyword">loop</span> <span class="hljs-type">time</span>: ~<span class="hljs-number">110</span> microseconds<br><span class="hljs-keyword">ForEach</span>, average <span class="hljs-keyword">loop</span> <span class="hljs-type">time</span>: ~<span class="hljs-number">77</span> microseconds<br><span class="hljs-keyword">While</span>, average <span class="hljs-keyword">loop</span> <span class="hljs-type">time</span>: ~<span class="hljs-number">11</span> microseconds<br>Reduce, average <span class="hljs-keyword">loop</span> <span class="hljs-type">time</span>: ~<span class="hljs-number">113</span> microseconds<br></code></pre></td></tr></table></figure><p>在谷歌搜索如何对数组求和时，reduce 是最好的解决方案，但它是最慢的。即使是最新的（ES6）也提供了较差的性能。事实证明，老的 for 循环提供了迄今为止最好的性能 - 超过 10 倍以上！</p><p>最新推荐的解决方案如何使 JavaScript 变得如此之慢？造成这种痛苦的原因有两个主要原因：reduce 和 forEach 需要执行一个回调函数，这个函数被递归调用并使堆栈膨胀，以及对执行代码进行的附加操作和验证（在此描述 <a href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.21%EF%BC%89%E3%80%82">https://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.21）。</a></p><p><strong>2. 复制数组</strong></p><p>虽然这听起来不那么有趣，但这是不可变函数的支柱，它在生成输出时不会修改输入。</p><p>此处的性能测试结果再次显示了同样有趣的趋势 - 当重复 10k 随机项的 10k 数组时，使用旧的传统解决方案更快。同样最新的 ES6 扩展操作符 <code>[... arr]</code> 和来自 <code>Array.from（arr）</code> 的数组加上 ES5  的 map <code>arr.map（x =&gt; x）</code>  不如老的 slice <code>arr.slice（） </code> 和 concat <code>[] .concat（arr）</code>。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Duplicate <span class="hljs-keyword">using</span> Slice, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">367</span> microseconds<br>Duplicate <span class="hljs-keyword">using</span> Map, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">469</span> microseconds<br>Duplicate <span class="hljs-keyword">using</span> Spread, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">512</span> microseconds<br>Duplicate <span class="hljs-keyword">using</span> Conct, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">366</span> microseconds<br>Duplicate <span class="hljs-keyword">using</span> Array From, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">1</span>,<span class="hljs-number">436</span> microseconds<br>Duplicate manually, <span class="hljs-built_in">average</span>: ~<span class="hljs-number">412</span> microseconds<br></code></pre></td></tr></table></figure><p><strong>3. 迭代对象</strong></p><p>另一种常见的情况是迭代对象，当我们尝试遍历 JSON 和对象时，这是必要的，而不是寻找特定的键值。同样有老 的解决方案，如 for-in <code>for（let key in obj）</code>，或者后来的 <code>Object.keys（obj）</code>（在 es6 中显示）和 <code>Object.entries（obj）</code> （来自ES8）它返回 keys 和 vaues。</p><p>使用上述方法对 10k 个对象迭代进行性能分析，每个迭代包含 1,000 个随机 key 和value，得到以下结论。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Object <span class="hljs-keyword">iterate</span> For<span class="hljs-params">-In</span>, <span class="hljs-keyword">average</span>: ~<span class="hljs-number">240</span> microseconds<br>Object <span class="hljs-keyword">iterate</span> Keys For Each, <span class="hljs-keyword">average</span>: ~<span class="hljs-number">294</span> microseconds<br>Object <span class="hljs-keyword">iterate</span> Entries For<span class="hljs-params">-Of</span>, <span class="hljs-keyword">average</span>: ~<span class="hljs-number">535</span> microseconds<br></code></pre></td></tr></table></figure><p>原因是在后两个解决方案中创建了可枚举值数组，而不是在没有 keys 数组的情况下直接遍历对象。但最终结果仍然引起关注。</p><p><strong>最后</strong><br>我的结论很清楚 - 如果快速性能对您的应用程序至关重要，或者您的服务器需要处理一些负载 - 使用最酷，更易读，更感觉的解决方案将会对您的应用程序性能产生重大影响 - 最多可以达到慢 10 倍！</p><p>下一次，在盲目采用最新趋势之前，确保它们也符合您的要求 - <strong>对于小型应用程序，快速编写和更易读的代码是完美的 - 但对于压力大的服务器和大型客户端应用程序，这可能不是最好的做法。</strong></p><h3 id="评论吃瓜"><a href="#评论吃瓜" class="headerlink" title="评论吃瓜"></a>评论吃瓜</h3><p><strong>评论 1</strong></p><blockquote><p>一个英文名叫 Christian Gitter 评论说：</p></blockquote><p>不同意。谁在乎微秒？</p><p>如果您正在开发一个高性能的超级关键服务器应用程序，那么您要么首先不使用  JavaScript，要么您将成为一名经验丰富的开发人员，他知道自己在做什么以及谁不仅仅取得他的第一个结果。 “如何将数组相加”,Google 搜索结果并将其作为目标。</p><p>我们假设你有一个你注意到的服务很慢。你有两个选择。选项 1 占用了团队中的一个或几个开发人员，让他们花一些时间来优化代码以提高速度。选项 2 正在投入一些资金来扩展您的硬件。我说几乎总是选择 2。</p><p>在短期内，让您的开发人员进行优化工作可能比扩展服务器所需的成本更高。长期成本甚至更高，因为您将不得不继续进行这种优化，并且您将失去代码可读性，因此新开发人员需要更长时间来确定代码的作用。</p><p>这是你几乎应该做的事情：</p><ul><li>循环数组=&gt; <code>[].forEach（...）</code></li><li>复制数组=&gt; <code>const newArray = [... oldArray]</code></li><li>迭代对象<br>…如果你只需要 values =&gt; <code>Object.values（obj）.forEach（）</code><br>…或者如果你想要 keys =&gt; <code>Object.entries（obj）.forEach（）</code><br>…或者只是 keys =&gt; <code>Object.keys（obj）.forEach（）</code></li></ul><p>我想你明白我的意思。</p><p><strong>作者回复：</strong></p><p>“谁在乎微秒？” - 好吧，在我工作的地方，我们每天处理大约550亿个事件，这意味着每秒大约700k个事件，当我们尝试在这种环境中运行节点时……你知道其余的事情。</p><p><strong>Stephen Young 回复作者</strong></p><p>好吧，让我们对每秒 700k 事件进行数学计算。让我们说，为了论证，20％ 的事件（每秒 140k）正在进行一些繁重的工作并循环超过一万件事情。现在，假设您将这些循环从 <code>forEach</code> 优化到 <code>for</code> 循环。您的“基准”可为此更改节省 67 微秒。700k * 0.20 * 67 等于 938 万微秒。这归结为节省了惊人的 9.38 秒。这些秒不是线性的，因为我假设您没有在单个 JavaScript 线程上使用单个服务器消耗 700k 事件。在那种规模上，你并行运行多个线程。所以在这个非常慷慨的例子中，你每秒循环 10k 项、 140k次……你最终可能节省不到一秒钟。</p><p><strong>评论 2</strong></p><p>对于真正的应用程序性能，整个博客文章遗憾地是非常糟糕的建议。</p><p>在优化性能时应该做的第一件事是找到应用程序的实际瓶颈。否则，花费时间来优化对实际执行时间没有实际影响的代码。我是一名软件架构师，我最喜欢的一件事就是让代码快速发展。根据我的经验，主要的瓶颈主要是算法复杂性差。除此之外，算法中经常出现错误，并且在实现中存在许多奇怪之处。所以请使用 <a href="https://clinicjs.org/">https://clinicjs.org/</a> 等工具。这有助于找到应该优化的代码。</p><p>这篇文章中提到的优化是微优化，降低了代码的可读性，因此代码需要更多的时间来阅读和理解，这导致优化热代码路径的时间更短。性能也只是当前版本的快照，并且由于新的引擎优化，相同的代码在下一版本中可能表现得非常不同。</p><p>如果内置函数确实比不同的实现慢得多（由于 V8 团队很厉害，这种情况不再那么常见），请向 V8 团队报告，以便他们可以进一步优化这些部分。还要注意，由于底层引擎优化（死代码消除等），基准测试本身可能不会按预期运行。</p><h3 id="个人看法"><a href="#个人看法" class="headerlink" title="个人看法"></a>个人看法</h3><p>首先发布个人看法，我觉得这篇文章还是很有价值的，很有趣的，它带给我们的价值不是说这些比较的数字比较有价值，而是另外的两点：</p><ol><li>让我们要注意，google 出来的第一个答案不一定是好的答案。</li><li>ES 新发布的特性不一定是最好的解决方案，我们需要引起注意。</li><li>当发现性能瓶颈的时候这也许是个方案(但是依我看来大多数用不上)</li></ol><p>另外我观看评论得出以下结论：</p><ol><li><p>过早优化是万恶之源，代码的可读性比性能更重要，因为代码是写来给人看的，不是给机器看的。这点让我想到前几天在掘金里面争论 FP(函数式编程) 和 OOP(面向对象编程)哪个好，或者说该用哪个？我的观点就是看自己的团队，如果你的团队大部分人都喜欢 FP，都熟悉 FP，大家都看得懂 FP，那么就可以用 FP，比如 Facebook 的 React 团队，他们很多都热衷于 FP，那么都是用 FP 有何不可呢？因为 FP 的抽象程度更高，所以对开发者要求相对高一点，所以对于不习惯 FP 的团队，还是老老实实的 OOP 吧。我这里没说 FP 就比 OOP 更好，只是想表达看个人爱好的团队爱好。</p></li><li><p>对于作者文中提到的这种微优化，在绝大部分情况下是没必要的，性能瓶颈往往可以通过优化算法来解决，算法解决不了可以通过增加服务器来解决。(所以这个观点我跟大部分的评论者相同)</p></li><li><p>“<strong>喷</strong>”也要有理有据，不赞同别人的观点，你可以举一些反例来证明，而不是当颠覆自己的认知的时候，当键盘侠，评论什么，<strong>垃圾文章</strong>，<strong>傻逼</strong>，<strong>v8 团队写的不好，你写的得好</strong>之类的话。另外我们要明白，<strong>有时候作者起的文章标题有点偏激，或者极端，他只是想引起你的重视，因为他觉得这点很重要</strong>，很可能是颠覆你以前的认知的事儿。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破坏开发人员生产力的十二件事</title>
    <link href="/index.php/archives/157/"/>
    <url>/index.php/archives/157/</url>
    
    <content type="html"><![CDATA[<p>今天的文章是来自 medium 的一篇文章，点赞数有将近 1 万 9，所以翻译出来给大家分享一下，有些概念怕大家不了解，所以我放了一些 维基百科的解释。如果有翻译得不是很好的地方，请看原文：<a href="https://hackernoon.com/top-12-things-that-destroy-developer-productivity-2ddf0abc190">https://hackernoon.com/top-12-things-that-destroy-developer-productivity-2ddf0abc190</a></p><p>正文：</p><p>很多文章都涉及技术主管和项目经理的角色。我们经常遇到的一个共同主题是如何提高团队的工作效率。但是在你集中精力来提高生产力之前，你可能首先要考虑是什么在摧毁它，以便建立一个可靠的基础。不幸的是，即使 Peopleware 近 30 年前发布，我们也看到许多团队在一些（消极的）显着方式中遭受巨大的生产力损失！</p><p>没有人希望程序员在没有计算机的情况下完成工作，但是有很多公司希望程序员能够在不知情的情况下完成工作。这同样不切实际。</p><p>因此，让我们深入探讨我们的 12 个阻止您的开发人员“进入区域”并提高工作效率的事项列表。我将尝试从大多数到最不具影响力的列表中优先考虑此列表。随意评论！</p><p>如果您想知道这一切是否值得投资，只需考虑开发商的工资。生产力提高10％甚至更多！</p><ol><li>中断和会议<br>在我看来，中断是开发人员的首要生产力杀手。开发人员在中断之前不能轻易回到他们正确的位置。他们需要进入发展的思维模式，然后慢慢追溯到他们离开的地方。这可能需要超过30分钟。中断越多，挫折越多，工作质量越差，错误就越多 - 而且还在继续。</li></ol><p>“The more times you trip me up while I’m trying to get started — the longer between each time I’m going to try. If you fill my morning with interruptions — don’t be surprised when the day is unproductive.。” –A developer on Reddit</p><p>大概意思就是说，每次被打断都要重新开始，如果你的一天里经常被打断，那么当你一天没有任何成果的时候，不要感到惊讶。</p><p>会议怎么样？会议和中断之间的唯一区别是会议是计划中断，这会使情况变得更糟。如果开发人员在处理任务时知道他们会中断，则他们无法完成任务。因此，如果他们在一两个小时内召开会议，他们将无法取得任何进展，因为大多数工程任务需要更多时间。</p><p>As Paul Graham wrote, “A single meeting can blow a whole afternoon by breaking it into two pieces, each too small to do anything hard in.”</p><p>意思就是：正如保罗·格雷厄姆（Paul Graham）所写的那样，“单次会议可以将整个下午分成两部分，每部分都太小而无法做任何事情。”</p><p>如何避免这种情况？这部分记录良好; 你没有任何借口。例如，在一天的开始或午餐前举行简短的状态会议，以避免不必要的中断。</p><ol start="2"><li>微观管理<br>在不同类型的管理者中，微观管理者在开发人员的生产力方面可能是最糟糕的。当然，微观管理者往往会有更多的会议和意外中断。但不仅如此。他们表现出缺乏信任，通过这样做，你会觉得他们不断破坏你的技能和你完成任务的能力。开发人员在中断之间的任何动机都会在那时消失。影响超出了生产力。微观管理者可能是开发人员离职的第一个原因，或者至少是改变团队的原因。</li></ol><p>如果不知道什么是微观管理(micro-management)的，看下面的解释：</p><p>在商业管理中，微观管理（英语：Micromanagement），亦作微观管理学、微管理学、微管理或显微管理学，一种管理风格，与宏观管理的理念相反。在这种手法里，管理者透过对被管理者（员工）的密切观察及操控，使被管理者达成管理者所指定的工作。相对于一般管理者只对较小型的工作给予一般的指示，微观管理者会监视及评核每一个步骤。这个名词一般在使用上带有负面的意思。– 来自维基百科</p><ol start="3"><li>模糊<br>有许多方法可以说明模糊性。错误的报告，如“出问题了，快修复！”没有足够的信息供开发人员使用。顺便说一下，拥有错误报告模板可以帮助解决这个问题。</li></ol><p>或者对某个功能的规范不明确，在这种情况下，一旦管理员更好地详细说明了预期的行为，开发人员就会开始实施对他们感觉合适的事情。</p><p>不明确的优先次序也属于此类别。开发人员想知道他们是否正在处理正确的任务的时间可以很容易地避免。如果有的话，他们会得到经理的评论，询问他们为什么要处理这个特定的任务（虽然优先事项没有定义）……好吧，你得到它 - 很多挫折……</p><ol start="4"><li><p>海鸥管理<br>你听说过吗？当管理者完全没有参与工作时，就会发生这种情况，但是……他们偶尔会突然畏缩不前。“这是错的，这个，这看起来很糟糕，”等等，然后又飞走了。我不得不承认我喜欢这个形象，但不幸的是，这种情况比我们想要的更频繁。这种行为让开发人员感到非常沮丧; 他们将在接下来的几个小时内无法返回该区域，有时甚至连几天都没有。</p></li><li><p>信用贪婪<br>您是否有过经理或其他开发人员，他们在过去几周内完成了您所做的工作？开发人员首先重视能力。为别人赢得信誉是为了自己并将其从他或她手中移除。这在我的名单上相当高，因为我觉得它产生了如此多的紧张，它只会在很长一段时间内摧毁整个开发人员的生产力。</p></li><li><p>环境 - 噪音，运动，工作区设计……<br>这对于非程序员来说可能看起来很奇怪，但开发人员工作的环境对他们的活动有重要影响。例如，有一些白噪声 - 响亮的交流电，听力汽车和卡车翻滚 - 帮助他们更好地集中注意力。这就是我们这么多人戴耳机的原因！我其实刚刚发现了RainyMood  - 非常棒</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>译文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>medium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不要再说虚拟 DOM 有多快了</title>
    <link href="/index.php/archives/124/"/>
    <url>/index.php/archives/124/</url>
    
    <content type="html"><![CDATA[<blockquote><p>如果你觉得它很快，那么这篇文章可能就是你所缺少的</p></blockquote><p>我经常听到有人在群里，或者在社区里说的一个很严重的错误，那就是说 React 的 Virtual Dom 是以快出名的，比原生 Dom 快多了，啥啥啥的，每次都一两句话说不清楚，所以下次有谁再说 React 是以快出名的，你就把这篇文章丢给他，下面进入正题。</p><p>在过去的几年里，你一直在跟踪 JavaScript 社区的发展，你至少听说过 Virtual DOM（React，Vue.js 2，Riot.js，Angular 2等等）。他们承诺（或者更确切地说，他们的宣传）更快的渲染界面，特别是更新，减少麻烦。你很快的上手了使用虚拟DOM的应用程序，这很好。几个月后，您的应用程序现在变得越来越复杂，你可能从用户交互到屏幕更新只需要一两秒钟的更新。你可能会想，这东西很神奇，应该会比 jQuery 快，但是实际上不是这个样子的。</p><p>虽然我同意虚拟 DOM 为我们提供了很多便利，但我将解释为什么我认为根据定义，更快的渲染和更快的更新是不正确的。要付出代价，其利益并不是大多数人想象或至少希望的。</p><p>要阅读本文，您需要熟悉DOM。理想情况下，您至少可以使用 DOM API。如果你只使用 DOM API 构建东西，你可能不需要这篇文章，但我仍然希望你阅读它并在评论中留下一点评语。</p><h2 id="渲染和更新"><a href="#渲染和更新" class="headerlink" title="渲染和更新"></a>渲染和更新</h2><p>让我们来看看手动执行 DOM 节点的创建和更新的鸟瞰图。这对于理解虚拟DOM如何工作以及它解决了哪些问题非常重要。</p><p>在谈论 JavaScript Web 应用程序时，用户界面的更改通过 DOM 操作发生。这个过程分为两个阶段：</p><ol><li>JS 部分：定义 JavaScript 世界中的变化</li><li>DOM 部分：使用 DOM API 函数和属性执行更改</li></ol><p>性能是根据整个过程的速度来衡量的，但了解每部分的速度也很重要，以便了解要优化的内容。</p><p>有两种方法可以创建和更新DOM树的各个部分。</p><p><strong>①字符串方式创建</strong></p><p>使用字符串既快速又简单，但在更新方面并不是非常精细。对于字符串，JS部分是它如此之快的原因。您可以在几毫秒内创建一段代表5000个节点的HTML。这是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> userList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;user-list&quot;</span>);<br><br><span class="hljs-comment">// JS 部分</span><br><span class="hljs-keyword">const</span> html = users.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div id=&quot;<span class="hljs-subst">$&#123;user.id&#125;</span>&quot; class=”user”&gt;</span><br><span class="hljs-string">      &lt;h2 class=&quot;header&quot;&gt;<span class="hljs-subst">$&#123;user.firstName&#125;</span> <span class="hljs-subst">$&#123;user.lastName&#125;</span>&lt;/h2&gt;</span><br><span class="hljs-string">      &lt;p class=&quot;email&quot;&gt;&lt;a href=”mailto:<span class="hljs-subst">$&#123;user.email&#125;</span>”&gt;EMAIL&lt;/a&gt;&lt;/p&gt;</span><br><span class="hljs-string">      &lt;p class=&quot;avg-grade&quot;&gt;Average grade: <span class="hljs-subst">$&#123;user.avgGrade&#125;</span>&lt;/p&gt;</span><br><span class="hljs-string">      &lt;p class=&quot;enrolled&quot;&gt;Enrolled: <span class="hljs-subst">$&#123;user.enrolled&#125;</span>&lt;/p&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span><br>&#125;).join(<span class="hljs-string">&quot;&quot;</span>);<br><br><span class="hljs-comment">// DOM 部分</span><br>userList.innerHTML = html;<br></code></pre></td></tr></table></figure><p>我提到使用这种方法时存在局限性。请考虑以下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> search = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;search&quot;</span>);<br>search.innerHTML = <span class="hljs-string">`&lt;input class=&quot;search&quot; type=&quot;text&quot; value=&quot;foo&quot;&gt;`</span>;<br><span class="hljs-comment">// Change value to &quot;bar&quot;?</span><br>search.innerHTML = <span class="hljs-string">`&lt;input class=&quot;search&quot; type=&quot;text&quot; value=&quot;bar&quot;&gt;`</span>;<br></code></pre></td></tr></table></figure><p>虽然看起来上面的内容很简单，但它实际上并不起作用。当我们运行上面的代码时，原始<code>&lt;input&gt;</code>元素被替换而不是更新，例如，如果用户有焦点的字段，他们将失去焦点。</p><p>创建和更新 DOM 树的另一种方法是使用 DOM 对象。就你必须编写的代码而言，这种方法非常冗长，而且总体来说它也慢得多。</p><p>让我们使用这个方法重写用户列表示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = <span class="hljs-built_in">document</span>.getElementById（“user-list”）;<br><span class="hljs-comment">// JS part </span><br><span class="hljs-keyword">const</span> = <span class="hljs-built_in">document</span>.createDocumentFragment（）; <br>users.forEach（<span class="hljs-function"><span class="hljs-keyword">function</span>（<span class="hljs-title">user</span>）</span>&#123; <br>  <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.createElement（“div”）; <br>  div.id = user.id; <br>  div.className =“user”; <br>  <span class="hljs-keyword">const</span> header = <span class="hljs-built_in">document</span>.createElement（“h2”）; <br>  h2 .className =“header”; <br>  h2.appendChild（<br>    <span class="hljs-built_in">document</span>.createTextNode（<span class="hljs-string">`$ &#123;user.firstName&#125; $ &#123;user.lastName&#125;`</span>）<br>  ）; <br>  <span class="hljs-comment">// .... </span><br>  frag.appendChild（div）; <br>&#125;）;<br><span class="hljs-comment">// DOM部分</span><br>userList.innerHTML =“”; <br>userList.appendChild（FRAG）;<br></code></pre></td></tr></table></figure><p>这看起来不太好，但它仍然是创建DOM节点的有效方法。它还有一个优点，即我们能够将它与第三方库（如D3）混合使用，以执行 HTML 字符串不易处理的事情。在真正的优势，虽然是执行粒度更新现有的树时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> search = <span class="hljs-built_in">document</span>.getElementById（“search”）; <br>search.innerHTML =<span class="hljs-string">`&lt;input class =&quot;search&quot; type =&quot;text&quot;value =&quot;foo&quot;&gt;`</span>; <br><span class="hljs-comment">//将值更改为“bar”？</span><br>search.querySelector（<span class="hljs-string">&quot;input&quot;</span>）。value =<span class="hljs-string">&quot;bar&quot;</span>;<br></code></pre></td></tr></table></figure><p>这次我们结合快速方便的字符串 HTML 方法来创建初始 UI，然后我们使用 DOM 操作方法来更新 value 属性。不像我们第一次这样做，<code>&lt;input&gt;</code>现在没有被替换，所以它不会像第一个例子那样引起 UX 故障。</p><h2 id="进入虚拟DOM"><a href="#进入虚拟DOM" class="headerlink" title="进入虚拟DOM"></a>进入虚拟DOM</h2><p>让我们回到输入示例的第一个版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> search = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;search&quot;</span>);<br>search.innerHTML = <span class="hljs-string">`&lt;input class=&quot;search&quot; type=&quot;text&quot; value=&quot;foo&quot;&gt;`</span>;<br><span class="hljs-comment">// Change value to &quot;bar&quot;?</span><br>search.innerHTML = <span class="hljs-string">`&lt;input class=&quot;search&quot; type=&quot;text&quot; value=&quot;bar&quot;&gt;`</span>;<br></code></pre></td></tr></table></figure><p>如果我们参数化值部分，它将如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> search = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;search&quot;</span>);<br><span class="hljs-keyword">const</span> renderInput = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  search.innerHTML = <span class="hljs-string">`&lt;input class=&quot;search&quot; type=&quot;text&quot; value=&quot;<span class="hljs-subst">$&#123;value&#125;</span>&quot;&gt;`</span>;<br>&#125;;<br>renderInput(<span class="hljs-string">&quot;foo&quot;</span>);<br><span class="hljs-comment">// Change value to &quot;bar&quot;?</span><br>renderInput(<span class="hljs-string">&quot;bar&quot;</span>);<br></code></pre></td></tr></table></figure><p>好吧，新 renderInput() 功能肯定看起来很酷，但我们已经知道这不是好方法。</p><p>如果我们有一些骚操作可以让我们继续使用类似的东西，但同时弄清楚我们想要做什么并做正确的事情呢？第二次 renderInput() 被调用，我们只更新 value 属性，所以只更新该属性而不是重新渲染整个属性<code>&lt;input&gt;</code>？</p><p>我们说过创建和更新 DOM 树的整个过程分为两个阶段。使用虚拟 DOM，DOM 阶段应该尽可能高效，代价是在 JS 阶段完成的额外工作。这项额外的工作会做 diff(不要以为 js 计算就不花费代价)，因此它的另一个名称将是开销。根据定义，虚拟 DOM 比精心设计的手动更新慢，但它为我们提供了一个更方便的 API 来创建 UI。</p><blockquote><p>虚拟DOM比精心设计的手动更新慢。</p></blockquote><h2 id="为什么有些开发人员认为Virtual-DOM更快"><a href="#为什么有些开发人员认为Virtual-DOM更快" class="headerlink" title="为什么有些开发人员认为Virtual DOM更快"></a>为什么有些开发人员认为Virtual DOM更快</h2><p>在虚拟DOM（尤其是React）的早期，传播了一个神话，即虚拟 DOM 使 DOM 快速更新。正如我们在前面的章节中看到的那样，这在技术上是不可行的。DOM 更新就是它们的原因，并且没有任何魔法可以使它更快：它必须在浏览器的本机代码中进行优化。</p><p><img src="http://www.taoweng.site/usr/uploads/2018/11/1585582967.png" alt="vdom.png"></p><p>可以看到 React 主页里面没有提到性能，而是开发人员的便利性。</p><p>React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。</p><p>您仍然可以看到比较各种虚拟 DOM 实现的基准测试，并且一些措辞会误导新开发人员认为虚拟 DOM 是当今事实上的标准，并且不值得对其他技术进行基准测试。然而，有一些基准可以将它与其他技术进行比较，例如 Aerotwist 的 React +性能文章，它描绘了虚拟 DOM 在宏观方案中所处位置的更真实的画面。</p><h2 id="我们得到了什么？这值得么？"><a href="#我们得到了什么？这值得么？" class="headerlink" title="我们得到了什么？这值得么？"></a>我们得到了什么？这值得么？</h2><p>虚拟DOM最终是一种执行 DOM 更新的循环方式。但是，它打开了通向有趣架构的大门，例如将视图视为状态函数，或者编写和组合视图组件。虚拟 DOM 带来了很多好东西，尽管疯狂的性能水平不是其中之一。您可以将其视为 Python 或 PHP 中的编码与 C 中的编码之间的差异。我们以性能为代价获得更多的开发人员工具。换句话说，这是一种权衡。</p><p>另一方面，开发人员的时间丢失也是一些实现方面的事情。虚拟 DOM 试图弄清楚它需要执行哪些更改的部分是由人类实现的，因此它并不总是万无一失。有时你必须介入。在某些情况下，无法进行干预。对于绝对性能至关重要的事情，它甚至可能不是一种选择。</p><blockquote><p>衡量您的表现并根据硬数据来决定。</p></blockquote><p>最重要的是，虚拟DOM只是您可以使用的工具之一。衡量您的表现并根据硬数据来决定。数据绑定仍然非常可行，我们已经看到您也可以手动完成所有操作。它绝对不是万能的，因此没有必要与虚拟DOM结合。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>React 厉害的地方并不是说它比 DOM 快，而是说不管你数据怎么变化，我都可以以最小的代价来进行更新 DOM。 方法就是我在内存里面用心的数据刷新一个虚拟 DOM 树，然后新旧 DOM 进行比较，找出差异，再更新到 DOM 树上。</p><p>这就是所谓的 diff 算法，虽然说 diff 算法号称算法复杂度 O(n) 可以得到最小操作结果，但实际上 DOM 树很大的时候，遍历两棵树进行各种对比还是有性能损耗的，特别是我在顶层 setState 一个简单的数据，你就要整棵树 walk 一遍，而真实中我可以一句 jQuery 就搞定，所以就有了 <code>shouldComponentUpdate</code> 这种东西。</p><p>框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。</p><p>针对每一个点，都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈未来几年前端的发展方向</title>
    <link href="/index.php/archives/117/"/>
    <url>/index.php/archives/117/</url>
    
    <content type="html"><![CDATA[<p>在知乎上看到这么一个问题，觉得很有意思，以下是原提问者的见解</p><blockquote><p>过去五年前端的发展过程基本上是一个工程化的过程,框架和工程化工具层出不穷。</p><p>近两年其实发展已经比较迟滞了。</p><p>框架方面:基本就是三大框架鼎立的局面,三大框架都在相互借鉴吸收,而且方向各有侧重,未来短时间内我看格局不可能有什么大变化.</p><p>工程化工具:基本上是 webpack 一统江湖的趋势,虽然有 parcel 等来小打小闹,但是生态一旦形成,没有革命性的项目是无法取代 webpack 的,而且 webpack 也在进化.</p><p>个人认为前面五年是前端生产力提高的五年,工程化使得前端的生产力得到了极大提升,但是现在也基本上是在已有的格局中修修补补了</p></blockquote><p>我谈谈我对前端未来几年的发展方向的看法。</p><p>看未来的发展方向，无非就是看现在的解决方案所存在的痛点。</p><h2 id="1-浏览器的性能问题"><a href="#1-浏览器的性能问题" class="headerlink" title="1. 浏览器的性能问题"></a>1. 浏览器的性能问题</h2><p>做 web 前端的同学都知道，和原生的 App 相比，性能一直一个致命的痛点，如果要追求性能，肯定得用原生 App。那么在性能上，未来几年可能是一个方向。</p><p><strong>①前端代码编译为字节码</strong></p><blockquote><p>浏览器这几年在 Chrome 的带动下，性能飞速发展，但毕竟其核心原理没有变化，性能始终难以达到原生 App 的水平，这部分是很有可能出现大的变化的，一个可能的方向就是浏览器变成虚拟机，前端代码编译为字节码，通过这种方式来将性能提升一个等级，虽然还是难以达到原生App的水平，但已经能够满足绝大部分应用的性能需求，类似于Java对比C/C++一样。    –李运华</p></blockquote><p>因为 js 是边解释边执行的，这肯定是要比编译型语言要慢，为了解决解释器的低效问题，大概在 2008 年的时候，提出了 JIT 的概念，它是使 JavaScript 运行更快的一种手段（JIT，内联缓存和隐藏类）之一，通过监视代码的运行状态，把 hot 代码（重复执行多次的代码）进行优化。通过这种方式，可以使 JavaScript 应用的性能提升很多倍。</p><p>但是时至今日，还是觉得不够快，所以各大浏览器厂商开始支持 WebAssembly。WebAssembly 是一种新的字节码格式，主流浏览器都已经支持 WebAssembly。</p><p>和 JS 需要解释执行不同的是，WebAssembly 字节码和底层机器码很相似可快速装载运行，因此性能相对于 JS 解释执行大大提升。 </p><p>也就是说 WebAssembly 并不是一门编程语言，而是一份字节码标准，需要用高级编程语言编译出字节码放到 WebAssembly 虚拟机中才能运行.</p><p>他的优点就是：</p><ul><li>体积小：由于浏览器运行时只加载编译成的字节码，一样的逻辑比用字符串描述的 JS 文件体积要小很多；</li><li>加载快：由于文件体积小，再加上无需解释执行，WebAssembly 能更快的加载并实例化，减少运行前的等待时间；</li></ul><p>目前可以编译成为 WebAssembly 字节码有 ：AssemblyScript(语法跟 TS 差不多，)、c\c++、Rust、Kotlin。</p><p><strong>②统一的DOM树限制了单线程的渲染</strong></p><p>理论上来说，一个页面某个时间变化的部分只是集中在一小块区域，没有必要将整个DOM树锁住。因此，一个可能的方向是分区渲染，即将页面划分为几个不同的区域，每个区域有独立的DOM树，独立渲染，那么性能会高很多，类似于 App 开发中的组件，组件类的运行不影响其它组件，如果需要依赖其它组件，通过组件间消息进行通信。</p><h2 id="原生-App-不同平台重新开发的痛点"><a href="#原生-App-不同平台重新开发的痛点" class="headerlink" title="原生 App 不同平台重新开发的痛点"></a>原生 App 不同平台重新开发的痛点</h2><p>现在的 web 有两大优势，一个是浏览完毕直接走人，另外一个是跨平台，只要有浏览器，一切都好说。</p><p>所以现在有很多 hybrid 解决方案，某些页面通过 h5 的方式来展现。</p><p>想解决的无非就是少花点成本，写一份代码，可以在 ios 和 Android 上都可以用，进而也出来了想 RN、weex、NativeScript 这类 Learn Once, Write Anywhere(RN提出来的) ，但是他们最终都会翻译成原生代码。</p><p>但是用过这些的人都知道，还有很多坑，经常调侃 rn 的就是 write once ，debug anywhere。</p><p>Learn Once, Write Anywhere 的理念，背后就是跨端的思想，所以也诞生出来 electron、PWA 为代表的案例。</p><p>而且现在出现了 Taro 、mpvue 这些 h5 与小程序的统一的方案，所以未来在突破写一份代码在 h5 ，原生 app、小程序，甚至桌面应用都有可能。</p><h2 id="另外提醒"><a href="#另外提醒" class="headerlink" title="另外提醒"></a>另外提醒</h2><ol><li>我很早就跟星球里的朋友们说过，TS 一定会在火的，现在用 TS 的感觉，让我感觉跟 vim 很像，刚开始用的时候很难受，一旦习惯了就离不开了。未来项目会越来越复杂，用了 TS 项目的风险会可控很多。</li><li>多注重框架原理，现在对于前端工程化，个人认为差不多到了瓶颈期，很难有新的突破，注重原理才能很好的应对未来的发展。</li><li>眼界放宽、拓宽自己知识的广度。</li></ol>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章搞定 ES6</title>
    <link href="/index.php/archives/115/"/>
    <url>/index.php/archives/115/</url>
    
    <content type="html"><![CDATA[<p>JavaScript ES6 带来了新的语法和新的强大功能，使您的代码更现代，更易读。它允许您编写更少的代码并执行更多操作。 ES6 向我们介绍了许多强大的功能，如箭头函数，模板字符串，对象结构，模块等，让我们来看看。</p><h2 id="const-and-let"><a href="#const-and-let" class="headerlink" title="const and let"></a>const and let</h2><p>const 是 ES6 中用于声明变量的新关键字。 const  比 var 更强大。使用后，无法重新分配变量。换句话说，它是一个不可变的变量，除非它与对象一起使用。</p><p>这对于定位选择器非常有用。例如，当我们有一个触发事件的按钮时，或者当您想在 JavaScript 中选择 HTML 元素时，请使用 const 而不是 var。这是因为 var 会被提升，当不想重新分配变量时，最好使用 const。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5</span><br><span class="hljs-keyword">var</span> MyBtn = <span class="hljs-built_in">document</span>.getElementId(<span class="hljs-string">&#x27;mybtn&#x27;</span>);<br><br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">const</span> MyBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;mybtn&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在上面的代码中，const 不会更改，也不能重新分配。如果您尝试为其赋予新值，则会返回错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&quot;Said&quot;</span>;<br>    name = <span class="hljs-string">&quot;Rick&quot;</span>;<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// Rick</span><br></code></pre></td></tr></table></figure><p>let 可以重新分配并获得新的价值。它创建了一个可变变量。</p><p>let 与 const 相同，因为两者都是块级作用域，这意味着该变量仅在其块级范围内可用。</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数非常棒，使您的代码更具可读性，更具结构性，并且看起来像现代代码，而不是使用这个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello &#x27;</span> + name;<br>&#125;<br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;said&#x27;</span>));  <span class="hljs-comment">// Hello said</span><br></code></pre></td></tr></table></figure><p>而使用 ES6 的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 Arrow function</span><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;Said&#x27;</span>)); <span class="hljs-comment">// Hi Said</span><br><br><span class="hljs-comment">// 或者不要 return 关键字</span><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br><br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;Said&#x27;</span>));<span class="hljs-comment">// Hi Said</span><br></code></pre></td></tr></table></figure><p>如您所见，箭头功能似乎更具可读性和清洁性！您将不再需要使用旧语法。</p><p>此外，您可以使用箭头功能与 map，filter 和 reduce 内置函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myArray = [<span class="hljs-string">&#x27;tony&#x27;</span>, <span class="hljs-string">&#x27;Sara&#x27;</span>, <span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// ES5</span><br><span class="hljs-keyword">let</span> Arr1 = myArray.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> item;<br>&#125;);<br><span class="hljs-built_in">console</span>.log(Arr1);<span class="hljs-comment">// [&quot;tony&quot;, &quot;Sara&quot;, &quot;Said&quot;, 5]</span><br><br><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">let</span> Arr2 = myArray.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item);<br><span class="hljs-built_in">console</span>.log(Arr2);<span class="hljs-comment">// [&quot;tony&quot;, &quot;Sara&quot;, &quot;Said&quot;, 5]</span><br></code></pre></td></tr></table></figure><p>带箭头的 map 函数看起来比 ES5 中的 map 更清晰可读。使用 ES6，您可以编写更短的代码，你也可以用相同的方法使用  reduce 和 filter。</p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p>模板字符串非常酷，当我们想在字符串中使用变量时我们不必使用加号（+）运算符来连接字符串。</p><p>旧语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES5</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunc1</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hi &#x27;</span> + name + <span class="hljs-string">&#x27; Your age is &#x27;</span> + age + <span class="hljs-string">&#x27; year old&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">22</span>)); <span class="hljs-comment">// Hi Said, Your age is 22 year old</span><br></code></pre></td></tr></table></figure><p>用 ES6 新语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6</span><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, Your age is <span class="hljs-subst">$&#123;age&#125;</span> year old`</span>;<br>&#125;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, Your age is <span class="hljs-subst">$&#123;age&#125;</span> year old`</span>;<br><br><span class="hljs-built_in">console</span>.log(myFunc1(<span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">22</span>)); <span class="hljs-comment">// Hi Said, Your age is 22 year old</span><br></code></pre></td></tr></table></figure><p>很简单！这是旧语法和 ES6 之间的巨大差异。使用字符串时，ES6 中的文字字符串看起来比 ES5 更有条理，结构更好。</p><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>当您忘记编写参数时，它不会返回未定义的错误，因为该参数已在默认值中定义。因此，当您使用遗漏参数运行函数时，它将采用默认参数的值，并且不会返回错误！</p><p>看看这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function">(<span class="hljs-params">name, age</span>) =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, Your age is <span class="hljs-subst">$&#123;age&#125;</span> year old`</span>;<br><br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;Said&#x27;</span>)); <span class="hljs-comment">// Hi Said, Your age is undefined year old</span><br></code></pre></td></tr></table></figure><p>上面的函数返回 undefined，因为我们忘了给它第二个参数 age。</p><p>但是如果我们使用默认参数，当我们忘记分配参数时,它将使用它的默认值，将不会返回 undefined！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myFunc = <span class="hljs-function">(<span class="hljs-params">name, age = <span class="hljs-number">22</span></span>) =&gt;</span> <span class="hljs-string">`Hi <span class="hljs-subst">$&#123;name&#125;</span>, Your age is <span class="hljs-subst">$&#123;age&#125;</span> year old`</span>;<br><br><span class="hljs-built_in">console</span>.log(myFunc(<span class="hljs-string">&#x27;Said&#x27;</span>)); <span class="hljs-comment">// Hi Said, Your age is 22 year old</span><br></code></pre></td></tr></table></figure><p>如您所见，即使我们错过了第二个参数，该函数也会返回一个值。现在使用默认参数我们可以提前处理错误。</p><h2 id="数组和对象解构"><a href="#数组和对象解构" class="headerlink" title="数组和对象解构"></a>数组和对象解构</h2><p>解构使得将数组或对象的值分配给新变量更容易。</p><p>旧语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contacts = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;said&#x27;</span>,<br>  <span class="hljs-attr">famillyName</span>: <span class="hljs-string">&#x27;Hayani&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> name = contacts.name;<br><span class="hljs-keyword">let</span> famillyName = contacts.famillyName;<br><span class="hljs-keyword">let</span> myAge = contacts.age;<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// said</span><br><span class="hljs-built_in">console</span>.log(famillyName); <span class="hljs-comment">// Hayani</span><br><span class="hljs-built_in">console</span>.log(myAge); <span class="hljs-comment">// 22</span><br></code></pre></td></tr></table></figure><p>ES6 新语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contacts = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;said&#x27;</span>,<br>  <span class="hljs-attr">famillyName</span>: <span class="hljs-string">&#x27;Hayani&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;name, famillyName, age&#125; = contacts;<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// said</span><br><span class="hljs-built_in">console</span>.log(famillyName); <span class="hljs-comment">// Hayani</span><br><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 22</span><br></code></pre></td></tr></table></figure><p>使用 ES5，我们必须为每个变量分配每个值。使用 ES6，我们只需将我们的值放在大括号中以获取对象的任何属性。</p><p>注意：如果指定的变量与属性名称不同，则返回 undefined。例如，如果属性的名称是 name，我们将其分配给 username变量，它将返回undefined。</p><p>我们总是必须将变量命名为与属性名称相同。但是如果我们想要重命名变量，我们可以使用冒号：代替。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> contacts = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;said&#x27;</span>,<br>  <span class="hljs-attr">famillyName</span>: <span class="hljs-string">&#x27;Hayani&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>:otherName, famillyName, myAge&#125; = contacts;<br><br><span class="hljs-built_in">console</span>.log(otherName);<span class="hljs-comment">// said</span><br></code></pre></td></tr></table></figure><p>对于数组，我们使用与对象相同的语法。我们只需用方括号替换花括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> Arr = [<span class="hljs-string">&#x27;Lionel&#x27;</span>, <span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;Layla&#x27;</span>, <span class="hljs-number">20</span>];<br><br><span class="hljs-keyword">let</span> [value1, value2, value3] = Arr;<br><span class="hljs-built_in">console</span>.log(value1); <span class="hljs-comment">// Lionel</span><br><span class="hljs-built_in">console</span>.log(value2); <span class="hljs-comment">// John</span><br><span class="hljs-built_in">console</span>.log(value3); <span class="hljs-comment">// Layla</span><br></code></pre></td></tr></table></figure><h2 id="Import-and-export"><a href="#Import-and-export" class="headerlink" title="Import and export"></a>Import and export</h2><p>在 JavaScript 应用程序中使用 import 和 export 使其更强大。它们允许您创建单独的可重用组件。</p><p>如果您熟悉任何 JavaScript MVC 框架，您将看到他们使用 import 和 export 出来在大多数时间处理组件。那么它们如何真正起作用呢？</p><p>很简单！ export 允许您导出要在另一个 JavaScript 组件中使用的模块。我们使用 import 导入该模块以在我们的组件中使用它。</p><p>例如，我们有两个文件。第一个名为 detailComponent.js，第二个名为 homeComponent.js。</p><p>在 detailComponent.js 中，我们将导出 detail 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 </span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">detail</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello <span class="hljs-subst">$&#123;name&#125;</span>, your age is <span class="hljs-subst">$&#123;age&#125;</span> year old!`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们想在 homeComponent.js 中使用此函数，我们将只使用 import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; detail &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./detailComponent&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(detail(<span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">20</span>)); <span class="hljs-comment">// Hello Said, your age is 20 year old!</span><br></code></pre></td></tr></table></figure><p>如果我们要导入多个模块，我们只需将它们放在大括号内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;detail, userProfile, getPosts&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./detailComponent&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(detail(<span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">20</span>)); <br><span class="hljs-built_in">console</span>.log(userProfile); <br><span class="hljs-built_in">console</span>.log(getPosts)); <br></code></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 是 ES6 的新功能。这是编写异步代码的方法。例如，当我们想要从 API 获取数据时，可以使用它，或者当我们有一个需要时间执行的函数时。Promise 使解决问题更容易，所以让我们创建我们的第一个 Promise！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javacript">const myPromise = () =&gt; &#123;<br>  return new Promise((resolve, reject) =&gt; &#123;<br>    resolve(&#x27;Hi the Promise execute successfully&#x27;);<br>  &#125;)<br>&#125;<br>console.log(myPromise()); // Promise &#123;&lt;resolved&gt;: &quot;Hi the Promise execute successfully&quot;&#125;<br></code></pre></td></tr></table></figure><p>如果您登录控制台，它将返回一个 Promise。因此，如果我们想在获取数据后执行一个函数，我们将使用 Promise。 Promise有两个参数： resolve 和 reject 来处理预期的错误。</p><p>注意：fetch函数返回一个Promise本身！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url=<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/posts&#x27;</span>;<br><span class="hljs-keyword">const</span> getData=<span class="hljs-function">(<span class="hljs-params">url</span>)=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(url);<br>&#125;<br>getData(url).<br>then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span> data.json()).<br>then(<span class="hljs-function"><span class="hljs-params">result</span>=&gt;</span> <span class="hljs-built_in">console</span>.log(result));<br></code></pre></td></tr></table></figure><p>现在，如果您登录控制台，它将返回一个数据数组。</p><h2 id="Rest-参数和-Spread-运算符"><a href="#Rest-参数和-Spread-运算符" class="headerlink" title="Rest 参数和 Spread 运算符"></a>Rest 参数和 Spread 运算符</h2><p>Rest 参数用于获取数组的参数，并返回一个新数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;said&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;Javascript enthusiast&#x27;</span>, <span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-string">&#x27;How are you?&#x27;</span>];<br><br><span class="hljs-comment">// 通过解构获取值</span><br><span class="hljs-keyword">const</span> [val1, val2, val3, ...rest] = arr;<br><br><span class="hljs-keyword">const</span> Func = <span class="hljs-function">(<span class="hljs-params">restOfArr</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> restOfArr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<span class="hljs-keyword">return</span> item&#125;).join(<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(Func(rest)); <span class="hljs-comment">// Hi Said How are you?</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;said&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;Javascript enthusiast&#x27;</span>, <span class="hljs-string">&#x27;Hi&#x27;</span>, <span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-string">&#x27;How are you?&#x27;</span>];<br><br><span class="hljs-keyword">const</span> Func = <span class="hljs-function">(<span class="hljs-params">...anArray</span>) =&gt;</span> anArray;<br><br><span class="hljs-built_in">console</span>.log(Func(arr)); <span class="hljs-comment">//  [&#x27;said&#x27;, 20, &#x27;Javascript enthusiast&#x27;, &#x27;Hi&#x27;, &#x27;Said&#x27;, &#x27;How are you?&#x27;]</span><br></code></pre></td></tr></table></figure><p>spread 运算符与 rest 参数具有相同的语法，但是 spread 运算符采用数组本身而不仅仅是参数。我们可以使用 Spread 参数来获取数组的值，而不是使用 for 循环或任何其他方法。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const arr=[<span class="hljs-string">&#x27;said&#x27;</span>,<span class="hljs-number">20</span>,<span class="hljs-string">&#x27;JavaScript enthusiast&#x27;</span>,<span class="hljs-string">&#x27;Hi&#x27;</span>,<span class="hljs-string">&#x27;Said&#x27;</span>,<span class="hljs-string">&#x27;How are you?&#x27;</span>];<br>const Func=<span class="hljs-function"><span class="hljs-params">(...anArray)</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> anArray;<br>&#125;<br><span class="hljs-built_in">console</span>.log(Func(arr)); <span class="hljs-regexp">//</span>[<span class="hljs-string">&quot;said&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;JavaScript enthusiast&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-string">&quot;Said&quot;</span>, <span class="hljs-string">&quot;How are you?&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>类是面向对象编程（OOP）的核心。它们使您的代码更安全和封装。使用类可以为代码提供一个很好的结构并使其保持面向对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要创建一个类，请使用 class 关键字，后跟带有两个大括号的类的名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name, age</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> myClass(<span class="hljs-string">&#x27;Said&#x27;</span>, <span class="hljs-number">22</span>);<br><span class="hljs-built_in">console</span>.log(user.name); <span class="hljs-comment">// Said</span><br>cosnole.log(user.age); <span class="hljs-comment">// 22</span><br></code></pre></td></tr></table></figure><p>现在我们可以使用 new 关键字访问类方法和属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name,age</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name=name;<br>    <span class="hljs-built_in">this</span>.age=age;<br>&#125;<br>&#125;<br><span class="hljs-keyword">const</span> Home= <span class="hljs-keyword">new</span> myClass(<span class="hljs-string">&quot;said&quot;</span>,<span class="hljs-number">20</span>);<br><span class="hljs-built_in">console</span>.log(Home.name)<span class="hljs-comment">//  said</span><br><br></code></pre></td></tr></table></figure><p>要从其他类继承，请使用 extends 关键字，后跟要继承的类的名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javacript">class myClass &#123;<br>  constructor(name, age) &#123;<br>    this.name = name;<br>    this.age = age;<br>  &#125;<br><br>  sayHello() &#123;<br>    cosnole.log(`Hi $&#123;this.name&#125; your age is $&#123;this.age&#125; `);<br>  &#125;<br>&#125;<br><br>// 继承 myClass 方法和属性<br>class UserProfile extends myClass &#123;<br>  username() &#123;<br>    console.log(this.name);<br>  &#125;<br>&#125;<br><br>const profile = new UserProfile(&#x27;Said&#x27;, 22);<br>profile.sayHello();// Hi Said your age is 22;<br>profile.username();// Said<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript核心概念之执行上下文和栈</title>
    <link href="/index.php/archives/316/"/>
    <url>/index.php/archives/316/</url>
    
    <content type="html"><![CDATA[<blockquote><p>桃翁桃翁，问个问题呢，据说 js 里面有个执行上下文，这个概念是个什么东东哦？据说挺重要的，给我科普科普呗。</p></blockquote><p>Emm… 这个概念非常的抽象，简单来说呢，就是 JS 在执行某段代码的时候做的一些事情。</p><p>具体做的事情就是<strong>定义了变量或函数有权访问的其他数据决定了它们各自的行为(作用域链)。每个执行环境都有一个与之关联的变量对象（variable object),环境中定义的所有变量和函数都保存在这个对象中(变量包括 this、arguments)。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。</strong></p><blockquote><p>哇，还是好抽象啊，你能不能画个图举个栗子呢？</p></blockquote><p>在之前说的执行上下文就是解释器在执行 JS 某段代码的时候做的一些事，那么首先我们把代码分个类。</p><ul><li>Global 代码：代码第一次执行时默认的环境。</li><li>Function 代码：执行到一个函数中。</li><li>Eval 代码：文本在eval函数内部执行。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2974893-253eded34df23288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 1"></p><p>看到这个图相信现在分清楚各种类型的代码，每种类型代码会都会产生执行上下文，我们把 Global 代码产生的执行环境叫<strong>「全局执行上下文」</strong>,把 Function 代码产生的执行环境叫<strong>「执行上下文」</strong>吧，Eval 代码不考虑。</p><blockquote><p>那我看这个图似乎有很多执行上下文(execution context)，这个具体是怎么来的呢？</p></blockquote><p>全局执行上下文只有<strong>一个</strong>，而执行环境的话是<strong>每次函数调用都会产生一个执行上下文</strong>。注意要调用才会产生哦，<strong>不调用是不会产生的。</strong></p><blockquote><p>那这个执行上下文基本知道是个什么东西了，那执行上下文栈又是啥呢？</p></blockquote><p>见名知意，执行上下文栈就是执行上下文（包含全局执行上下文）形成的栈嘛。</p><blockquote><p>那为什么要有这个执行上下文栈呢？</p></blockquote><p>浏览器中 JavaScript 解释器是单线程的，这就是说同一时间代码只会做一件事，那么创建这么多执行上下文，又不能同一时间执行多个上下文，所以就必须要有个顺序，这个顺序就是就是先进后出，这很明显就是一个栈结构嘛。</p><blockquote><p>那我就疑惑了，为啥要先进后出，不先进先出呢？</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2974893-bf3b684eebafc1c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一的执行上下文图"></p><p>我们分析一下图一的代码，结合上图，首先我们看图 1，解释代码的时候首先创建的就是全局上下文，然后再创建 person 的执行上下文，然后再创建 firstName 的上下文，然后再执行完毕 firstName ，就把 firstName 的上下文弹出，再 创建 lastName 的上下文，然后执行完毕，再弹出 lastName 的上下文，然后执行完 person 的上下文，再弹出 person 的上下文，再执行全局上下文，然后全局上下文弹出。</p><p>如下是一张经典的执行上下文栈的图。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-f67c67c18d5539ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图 2"></p><p>默认进入全局上下文。如果你的全局代码中调用了一个函数，那么程序将会进入这个被调用函数的上下文，创建一个新的执行上下文，并把当前上下文放到栈顶。浏览器总是会把当前执行上下文放到栈的顶部，一旦函数执行完成，这个执行上下文就会从栈中移除，返回到栈中的下一个上下文。</p><blockquote><p>这些大概明白了，不过你说在创建执行上下文做的那些事儿，我还是有点迷糊，能再详细说说吗？</p></blockquote><p>那我们首先看点代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例1</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 报错，a is not defined</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例2</span><br><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> a;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 例 <span class="hljs-number">3</span><br>console.log(a); <span class="hljs-regexp">//</span> undefined<br>var a = <span class="hljs-number">666</span>;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例 4</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// window 对象</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例 5</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// [666]</span><br>  <span class="hljs-built_in">console</span>.log(x); <span class="hljs-comment">// 666</span><br>&#125;<br><br>foo(<span class="hljs-number">666</span>);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例 6</span><br><span class="hljs-comment">// 函数表达式</span><br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例 7 </span><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// function() &#123;&#125;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>这 7 个例子相信大家对这些答案都是没有疑惑的，最基础的东西，例 1 报错，a 未定义，很正常。例 2、例 3 输出都是 undefined，说明浏览器在执行 console.log(a) 时，已经知道了 a 是 undefined，但却不知道 a 是 666（例 3）。</p><p>看例 4 就知道，当执行这条语句的时候 this 已经被赋值了。</p><p>在例 5 中展示了在函数体的语句执行之前，arguments 变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。</p><p>然后就是例 6，例 7 中可以看出函数表达式跟变量声明一样，只是给变量赋值成 <strong>undefined</strong>，而函数声明会将会把函数整个赋值了。</p><p>总结在执行上下文做的赋值事情</p><ol><li>变量、函数表达式——变量声明，默认赋值为undefined；</li><li>this——赋值；</li><li>函数声明——赋值；</li></ol><p>执行上下文就介绍到这里，如果你对相关知识还是感到迷惑，比如当在创建执行上下文的时候还有作用域，以及变量对象等概念，后面再一一介绍，不要担心，跟着我的文章走，这块一定能啃动。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript核心概念(1):类型转换</title>
    <link href="/index.php/archives/105/"/>
    <url>/index.php/archives/105/</url>
    
    <content type="html"><![CDATA[<p><img src="https://diycode.b0.upaiyun.com/photo/2018/75860bac6249dc70ac61906ae3f58049.png"></p><p>看到这个是不是有一种想打人的感觉，垃圾 JavaScript，这特么都什么鬼，相信很多人不管是笔试还是面试，都被 JS 的类型转换难道过，相信认真看完我这篇文章，妈妈再也不用担心类型转换的问题了。</p><h2 id="原始值到原始值的转换"><a href="#原始值到原始值的转换" class="headerlink" title="原始值到原始值的转换"></a>原始值到原始值的转换</h2><ol><li><p>原始值转化为布尔值</p><p>  所有的假值(undefined、null、0、-0、NaN、””)会被转化为 false，其他都会被转为 true</p></li><li><p>原始值转化为字符串<br>都相当于 原始值 + “”</p></li><li><p>原始值转为数字</p><ul><li>布尔转数字：true -&gt; 1, false -&gt; 0</li><li>字符串转数字：以数字表示的字符串可以直接会转为字符串，如果字符串头尾有空格会忽略，但是空格在中间，转换结果就是 NaN。</li></ul> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+<span class="hljs-string">&quot; 66&quot;</span> <span class="hljs-comment">// 66</span><br> +<span class="hljs-string">&quot; 6 7 &quot;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="原始值到对象的转换"><a href="#原始值到对象的转换" class="headerlink" title="原始值到对象的转换"></a>原始值到对象的转换</h2><ul><li>null 和 undefined 转对象直接抛异常</li><li>原始值通过调用 String()、Number()、Boolean()构造函数，转换为他们各自的包装对象</li></ul><h2 id="对象到原始值的转换"><a href="#对象到原始值的转换" class="headerlink" title="对象到原始值的转换"></a>对象到原始值的转换</h2><ol><li>对象转为布尔都为 true</li><li>对象到字符串<ul><li>如果对象有 toString() 方法，就调用 toString() 方法。如果该方法返回原始值，就讲这个值转化为字符串。</li><li>如果对象没有 toString() 方法或者 该方法返回的不是原始值，就会调用该对象的 valueOf() 方法。如果存在就调用这个方法，如果返回值是原始值，就转化为字符串。</li><li>否则就报错</li></ul></li><li>对象到数字<ul><li>对象转化为数字做了跟对象转化为字符串做了想同的事儿，不同的是后者是先调用 valueOf 方法，如果调用失败或者返回不是原始值，就调用 toString 方法。</li></ul></li><li>补充。一些常用内置对象 toString 方法和 valueOf 的转换规则<ul><li>toString 相关<br><img src="https://diycode.b0.upaiyun.com/photo/2018/9fe8d2d761eff48c5145e6c7e035a7dc.png"></li></ul></li></ol><ul><li>valueOf 相关<br> <img src="https://diycode.b0.upaiyun.com/photo/2018/656a5a293809ad2628a2afc40fe12bb9.png"></li></ul><h2 id="运算符如何进行类型转换"><a href="#运算符如何进行类型转换" class="headerlink" title="== 运算符如何进行类型转换"></a>== 运算符如何进行类型转换</h2><ol><li>如果一个值是null，另一个值是undefined，则相等</li><li>如果一个是字符串，另一个值是数字，则把字符串转换成数字，进行比较</li><li>如果任意值是true，则把true转换成1再进行比较；如果任意值是false，则把false转换成0再进行比较</li><li>如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的 toString 或者 valueOf 方法。 <strong>js 核心内置类，会尝试 valueOf 先于 toString（可以理解为对象优先转换成数字</strong>）；例外的是 Date，Date 利用的是 toString 转换。非 js 核心的对象，通过自己的实现中定义的方法转换成原始值。</li></ol><h2 id="运算符如何进行类型转化"><a href="#运算符如何进行类型转化" class="headerlink" title="+ 运算符如何进行类型转化"></a>+ 运算符如何进行类型转化</h2><ol><li>如果作为一元运算符就是转化为数字，常常用来将字符串转化为数字 <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">+<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-regexp">//</span>  <span class="hljs-number">2</span><br><span class="hljs-number">2</span>+false <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li>如果作为二元运算符就有两种转换方式<ul><li>两边如果有字符串，另一边一会转化为字符串进行相加</li><li>如果没有字符串，两边都会转化为数字进行相加，对象也根据前面的方法转化为原始值数字。</li><li>如果其中的一个操作数是对象,则将对象转换成原始值，日期对象会通过 toString() 方法进行转换，其他对象通过 valueOf（）方法进行转换，但是大多数方法都是不具备可用的 valueOf() 方法，所以还是会通过 toString() 方法执行转换。</li></ul></li></ol><p>流程图如下：<br><img src="https://diycode.b0.upaiyun.com/photo/2018/75a38c55807695e9283e1a76d5cdf0ca.png"></p><h2 id="实战分析"><a href="#实战分析" class="headerlink" title="实战分析"></a>实战分析</h2><ol><li><p><code>[]+[] // &quot;&quot;</code><br>_1. 首先运算符是 + 运算符而且很明显是二元运算符，并且有对象，所以选择最后一点，操作数是对象，将对象转换为原始值。<br>_2. 两边对象都是数组，左边的数组先调用 valueOf() 方法无果，然后去调用 toString(), 方法，在 toString() 的转化规则里面有『将数组转化为字符串，用逗号分隔』，由于没有其他元素，所以直接是空字符串 “”。<br> <img src="https://diycode.b0.upaiyun.com/photo/2018/30b2c9a257c7b7a780b6a7b125d65efd.png"><br>_3. 因为加号有一边是字符串了，所以另外一边也转为 字符串，所以两边都是空字符串 “”。<br>_4. 所以加起来也是空字符串 “”。</p></li><li><p><code>(! + [] + [] + ![]).length // 9</code></p></li></ol><p>这个题我看球友在做作业的时候理解还是有点误差，所以再单独说一说。<br>_1. 首先我们会看到挺多一元运算符，「+」、「！」，对于一元运算符是右结合性，所以可以画出以下运算顺序。<br><img src="https://diycode.b0.upaiyun.com/photo/2018/75f496bcf7d859f84298761c90f5bdab.png"><br>_2. 对于·<code>+[]</code>，数组是会被转化为数字的而不是字符串，可见「+ 运算符如何进行类型转化」的第一条，所以经过第一步就会转化为<br><code>(!0 + [] + &quot;false&quot;).length </code><br>_3. 第二步比较简单，0 转化为布尔值就是 false，所以经过第二步就转化为<br><code>(true + [] + &quot;false&quot;).length </code><br>_4. 第三步中间的 <code>[]</code>会转为空字符串，在「+ 运算符如何进行类型转化」第二条的第三点，对象会被转转化为原始值，就是空字符，所以经过第三步之后就会变成<br><code>(&quot;true&quot; + &quot;false&quot;).length</code><br>_5. 第五步就比较简单啦，最终就是 <code>&quot;truefalse&quot;.length // 9</code></p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p><img src="https://diycode.b0.upaiyun.com/photo/2018/f8e1e7a0291d6ad042c672cbaff063aa.png"><br>《JavaScript权威指南》中类型转换表格</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>核心概念</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拥有自己的知识体系，形成自己解决问题的方法论</title>
    <link href="/index.php/archives/104/"/>
    <url>/index.php/archives/104/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在星球里群里都有小伙伴说道自己对未来的路比较迷茫，一旦闲下来就不知道自己改干啥，今天我这篇文章就是让你觉得一天给你 25 个小时你都不够用，觉得睡觉都是浪费时间。<br><img src="http://www.taoweng.site/usr/uploads/2018/08/2183640187.png" alt="1.png"></p><p>今天我谈的就是关于【构建知识体系，形成自己解决问题的方法论】，这个话题以前我在<a href="https://mp.weixin.qq.com/s/wkHJ5pvrz01Lb9Nm_i-37Q">给在校准备找工作的同学的几个建议</a>这篇文章中谈到过，但是没有将如何去构建自己的知识体系，这次将深入这个话题进行探讨。</p><h2 id="什么是知识体系"><a href="#什么是知识体系" class="headerlink" title="什么是知识体系"></a>什么是知识体系</h2><p>无论是大到一个星系还是小至一个原子，其本质都是一个个的系统。<br>那我们如何来掌握这个系统呢？通过“框架”来简化对系统构成元素以及元素间有机联系。因此有目的地运用“框架”来思考、学习，能够让我们更全面、更快速、更深入地分析、解决问题，以及更高效地学习新知识和技能。</p><p>简单来说，<strong>知识体系就是一个系统构成元素以及元素之间的有机联系的简化体现。</strong></p><h2 id="知识体系的重要性"><a href="#知识体系的重要性" class="headerlink" title="知识体系的重要性"></a>知识体系的重要性</h2><p>没有完整的个人知识体系框架，即使你在学习单个知识点的时候理解力和速度高于一般人，但你整体的学习效率依然会很低。原因如下：</p><ul><li><strong>对知识的理解就不深。</strong>大部分知识点之间是有联系的，缺少了完整的知识体系框架，你就好似失去了<strong>知识间联系的地图</strong>，对知识的理解就不深。平时我们在遇到问题的时候不知道怎么解决，然后问了下大佬给你说用啥，然后怎么用之后，你就发现我知道这个知识点，但是没想到可以这么用。</li></ul><p>比如以前刚去实习的时候，遇到一个跨域问题，因为后端的数据是早就稳定了的，我只是要去拿几个接口的数据来做点东西，那么我本地调试的时候由于域名是是 locahost，而后端是 xxx.duokan.com, 所以就会有跨域问题，当时我就问我老大我要用代理来解决这个问题吗?他就跟我说你加一条 host ，把 xxx.duokan.com 绑定到 127.0.0.1 就行了，因为我当时知道 host 这个东西，所以就 get 到他的点了，但是由于知识点没有成系统，是散的，就根本想不到 host 和跨域有关系。</p><ul><li><strong>陷入在被动学习当中。</strong>没有完整的个人知识体系框架，你只能是碰到什么问题就被动地去学什么，零散而无系统，从而不自觉地陷入在了被动学习当中。这就跟我在文章的开头提到的小伙伴一样，刚开始还能被动学习，然后就不知道学什么了。</li></ul><p>一旦你形成了知识体系，你就知道自己那些地方要补，那些地方暂时可以不补，就可以主动学习去查漏补缺，就不会再迷茫了，因为你会发现你有太多太多遗漏的东西，根本学不完。</p><ul><li><strong>知识整体积累的速度下降。</strong>知识之间是相关联的，不同的人在经历同一段工作或上同一堂课时会因为知识体系框架的不同，从而导致了不同数量级的经验吸收。</li></ul><h2 id="知识体系的好处"><a href="#知识体系的好处" class="headerlink" title="知识体系的好处"></a>知识体系的好处</h2><ul><li>知识体系 <strong>可以方便地</strong> 给出所学知识的 <strong>地图全貌</strong>。在学习过程中给人进度反馈。</li><li>梳理知识体系，可以提炼出知识的<strong>主干网络</strong>，方便知识的调用。<br>知识体系提供了可拓展性。新学知识可以有规律地添加在原有体系之中。</li><li>知识体系为知识的关联提供的指导，发掘知识点之间的关联，正是创新的核心。</li><li>把孤立的知识点关联起来，是<strong>避免遗忘</strong>的重要手段。</li></ul><p>其实知识体系和解决问题的方法论是相辅相成的，在自己解决问题的时候，会用到知识体系的东西，知识体系的形成，也有部分是通过解决问题来添砖加瓦的。</p><h2 id="怎么构建自己的知识体系"><a href="#怎么构建自己的知识体系" class="headerlink" title="怎么构建自己的知识体系"></a>怎么构建自己的知识体系</h2><p>对于构建知识体系和很多方法论差不多，收集、整理、输出（即思考过程）。</p><ol><li><strong>收集知识点。</strong>现在是互联网很发达的时代，收集知识点，已经完全不是一个问题了，可以通过微信公众号、得到、视频网站、博客、社区等各种路径获取知识，你可以讲这些知识点收集起来后面进行整理，但是我提倡是先看再收藏，而不是收藏了等有空再去看，不然就会造成收藏栏里发现自己收藏了一大堆，然而由于太多就不知道看哪个，最后就不看了。</li><li><strong>整理知识。</strong>整理知识是一个为输出做准备的，在整理的过程你已经有一定的思考了，会建立自己的知识分区，将你认为相似的知识点归为一类，慢慢你也会将你的知识库变得更加丰富。</li><li><strong>输出。</strong>输出是来巩固知识的最佳方法，也许你通过自己的大脑想，觉得很简单，感觉自己会了，其实想通过头脑去想，去检验是否已经掌握了，对于绝大部分人来说都是不可能的，因为一般人的大脑都是无法深入到很多层以及思考全面，但是可以通过训练去让自己思考得越来越深入，越来越全面。</li></ol><p>这话可能说得有点抽象，咱们举个例子来说，大家都知道围棋很难吧，难的是什么，下完每一步棋之后可能的结果太多了，而那些大师就是可以预测下别人下一步，甚至下好几步别人会下的棋子来推测自己下的这步棋下在哪里比较好，而新手是往往做不到的，而像柯洁这种20就拿世界冠军的，也许就是因为他对围棋的天赋，天生对围棋就有很好的大局观，加上自己努力。</p><p>这上面只是谈到了为什么我们不能用大脑来检验自己掌握知识的程度。所以我们可以通过自己的嘴，来给别人讲明白；或者通过写文章站在读者的角度，把自己讲明白。只有能给别人讲明白的东西，才是你真正掌握的东西。</p><ol start="4"><li><strong>通过画思维导图来把知识体系形象化。</strong><br>选择思维导图的软件可以从知乎这个问答里面选择自己喜欢的，合适自己软件。<a href="https://www.zhihu.com/question/19610340">有什么免费的思维导图软件可以推荐？ - 知乎</a><br><img src="http://www.taoweng.site/usr/uploads/2018/08/2158341150.png" alt="思维导图.png"><br>这是以前流传的一篇 WEB 前端工程师的一篇思维导图，也可以说是作者的知识体系，我在这里不评价好与不好，因为每个人的技术栈都不同，但是我们还可以针对这个进行细化。</li></ol><p>比如我们针对我们前端重要的一块 JavaScript，就可以再进行细分，<br>Javascript 需要掌握基本类型、函数、对象、内置对象、DOM、BOM等知识，然后函数要掌握闭包、作用域、this等，对象要掌握原型、new这些等等。</p><p>我就不再扩展了，根据自己的知识形成一个知识体系，然后再解决问题的时候就很容易根据自己的知识体系来解决问题，比如可能你遇到了跨域的问题，你从你的大脑搜索整个知识体系的时候，就可以知道跨域有哪几种方法，然后每种方法的适用场景是什么。</p><p>在形成自己的知识体系的过程中，你就知道自己对哪些知识了解，哪些知识不了解，然后你就会花时间去补充自己不了解的知识，渐渐完善自己的知识体系。</p><p>在形成自己的知识体系之后，你面试就比较胸有成竹，兵来将挡水来土掩。</p><p>你的知识体系就像一张网，面试的过程就是来检验你这张网漏洞有多大的过程，而学习的过程就是就像是给这张网空隙给编织细一点，你的最终目的就是使你这张网的空隙越来越小。</p><h2 id="一些小要求"><a href="#一些小要求" class="headerlink" title="一些小要求"></a>一些小要求</h2><ol><li>需要有一颗爱学习的心。</li><li>需要做一个善于总结的人。</li><li>需要是一个有执行力的人，不然列了很多知识点，不去查漏补缺，没鸟用。</li><li>关注桃翁，关注前端桃园，有问题随时跟我交流。（最后一条纯属扯淡）</li></ol>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>感悟心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>毕业记—我的大学无憾了</title>
    <link href="/index.php/archives/100/"/>
    <url>/index.php/archives/100/</url>
    
    <content type="html"><![CDATA[<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/CBxTibNZG9mGZhb3MCAaIgibmED18YDauibELbic1qz53D0o7sWd1hYNdgicfUBkmHGAZx7Op6RdQ5ia9FsWPjBOWLfQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1" alt="s"></p><p>如果玩抖音的同学，我相信对上面这个图片并不陌生，在六月份的时候疯狂刷这个，但是当时并没有任何感觉，直到我那毕业的那天，提起背包离开学校的那天，我才真正的感受到，我要离开学校了。</p><p>自己已经不是一个学生了，熟悉的学校，熟悉的班级，熟悉的同学，熟悉的老师，这次，真的说再见了。</p><p>还没来得及跟给我传授过知识老师，陪了我四年的大学同学，以及实验室的学弟学妹们好好的说再见，就提着行李，背着书包离开了学校。</p><p>在走的那天，突然想到，那些给我传道受业解惑的老师，那些跟我一起学习上课的同学，那些跟我在实验室辛苦奋斗的都学弟学妹们，也许我们以后就见不到了，莫名的一股泪意席卷而来，包括我现在写这篇文章也是这样，这也行就是人与动物之间感情的差别吧。</p><p>天下无不散之筵席，想给那些没有好好道别的人说，咱们有缘再见，以后我帮得上忙的随便找我。</p><p>之所以在题目取【我的大学无憾了】，主要是因为三件事儿。</p><ol><li><strong>找到了一份满意的工作。</strong>虽然我没能去得了我最想去的腾讯，也因为个人原因没有去实习了半年的小米，但是在现在的蘑菇街工作我还是挺开心，很满意这里的工作氛围以及人文环境。</li><li><strong>在大学中找到了心爱的女朋友。</strong> 都说程序员比较宅，很难找到女朋友，还好我运气好，在毕业之前找到了心爱的她。</li><li><strong>拿到驾照。</strong> 大学有时间真的建议把驾照考了，以后工作了时间成本很高。</li></ol><h2 id="夸夸自己"><a href="#夸夸自己" class="headerlink" title="夸夸自己"></a>夸夸自己</h2><p>我在学习上说是一个学霸呢，但是自我感觉并没有怎么花时间去学习上课的内容，大多数时间都花在专业课上，准确的说是花在敲代码上。</p><p>为啥又说是个学霸呢？因为拿的奖状还是挺多的，四年里，拿了两次甲等、一次乙等(跟甲等的最后一个绩点只差 0.1)，大四由于没课，只有一个实习，不知道老师咋打的分，后来没有拿到。</p><p>然后在其他方面参加的比赛比较多，各种程序设计大赛，数据库设计大赛，以及优秀班干部等等，估计 20 多张奖状，最后毕业前还去申请了校级的优秀毕业生和市级的优秀毕业生，没想到都通过了，市级优秀毕业生咱们一个院也才 5 个名额，这个时候只想对自己说【优秀】。</p><h2 id="吐槽下自己"><a href="#吐槽下自己" class="headerlink" title="吐槽下自己"></a>吐槽下自己</h2><p>在这里想吐槽自己的主要是体重，总结下来就是【肥了】。</p><p>刚入大学的时候我只有 114 斤，作为一个 174 的男生来说，那还是比较瘦的了，想想那个时候自己肚子稍微硬一下，还能看到几块肌肉呢，大一的时候比较闲，没事儿就出去大大篮球，然后对新事物比较好奇，到处跑啥的，运动的比较多。</p><p>到了大二的时候，涨到了 122 左右，因为大二进了学院的创新实验室，从此没有了双休，没有正常的节假日，没有了没有课就是玩的时间。如果早上没有课 8 点 40 之前就得到实验室，晚上一直要干到 10 点 40 才能回寝室，每周要上六天班。每天三点一线，寝室、教室、实验室，周末休息的那天就想着要好好打打游戏，放松下，也没有出去玩，导致体重增加，肚子肥肉增多。</p><p>到了大三同样也如此，绝大部分除了睡觉的时间都是在实验室，很少出去运动，只要在体育课的时候才能好好的运动，直到大三结束的那个暑假，已经 126 了，但是还是没有意识到问题的严重性，感觉还是很正常，也不胖。</p><p>大三结束的那个暑假，我去小米实习了，虽然在北京消费很高，但是总是吃得很饱，几个玩得好的每周都要出去吃好的，结果越吃越胖，直到有一次去吃完火锅回来在旁边的称称了一下，把自己下了一跳，已经 135 了，那个时候才来北京两个月，竟然涨了 9 斤，准备开始减肥了，然而并没有坚持下来，但是尽量在注意，直到我实习半年再回学校 138 了。</p><p>回到学校已经是大四了嘛，就在学校做毕业设计，在学校吃的稍微差点，我也尽量控制自己的食量，现在以及只有 132 了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望自己离开了社会，该变的要变，不该变的别变。比如不要忘记初心而随波逐流，既然选择了做程序员这个行业，目前这几年就应该有工匠精神，把技术专研深，专研透，以后看自己的意愿或者社会的发展再看应该干什么。</p><p>要该变的是该变自己还是学生的身份，作为一个工作人，应该对工作精益求精，尽量不要犯错误，大学的时候犯点错误还能接受，在公司里犯了错可是要付很大的代价的。</p><p>最后感谢大学陪我走过的这些人，可能有些人只是我人生中的过客，但是也给我的人生增添了一份色彩，感谢你们。</p><p>那些在大学里面给过我帮助的人，我会永远记住的，【滴水之恩，涌泉相报】。</p><p>我希望今天我以学校为荣，以后学校以我为荣。</p><p>致我的大学以及青春。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>国外服务器如何选择以及搭建ShadowSocks教程</title>
    <link href="/index.php/archives/99/"/>
    <url>/index.php/archives/99/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>就在前几天，阿里云给我发了短信，还给我打了电话，告诉我我的学生认证已经过期，请尽快续费，要是停了意味着我的博客就不能用了，运营了这么久的博客还是舍不得丢。我是用的阿里云的学生机，1 核 2G的内存 40 个 G 的 SSD，去续费的时候发现一个月 120 多，对于我来说还是太贵了，所以准备买个便宜的国外的服务器，国内的相对比较贵，而且国外的还可以用来搭 SS。</p><p>下面就记录我选择服务器商家，以及怎么使用 vultr，然后再服务器上搭建基础服务和 搭建 SS 的过程。</p><h2 id="VPS-商家如何选择"><a href="#VPS-商家如何选择" class="headerlink" title="VPS 商家如何选择"></a>VPS 商家如何选择</h2><p>在国内比较畅销的海外 VPS 就是搬瓦工和 Vultr了，基本占据中低端VPS的半壁江山了。</p><p>但是对于新手不知道该如何选择，今天在这里给大家做个介绍和推荐</p><h3 id="搬瓦工"><a href="#搬瓦工" class="headerlink" title="搬瓦工"></a>搬瓦工</h3><p>  <strong>搬瓦工</strong>，因其官网网站标识是 BandwagonHost，有点类似 BanWaGong 的拼写，所以我们国内的站长喜欢称作为搬瓦工 VPS。搬瓦工 VPS 是一款性价比较高（据我所知是最高的）的便宜 VPS 主机，且适合入门级网友学习Linux和建站用途。</p><p>下面是一些搬瓦工的选择方案。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-c5d9df695a04567b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/2974893-075c1c3042b972d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/2974893-281d3cc5c03f9898.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/2974893-54a7bcda4cad9c0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>可以看到搬瓦工的 VPS 是相当高的，最低的年付 ￥19.99，一年差不多才 130 多点，一个月十块多，如果是用来科学上网，或者用来学习 linux 操作，那是相当划算的。</p><h3 id="Vultr"><a href="#Vultr" class="headerlink" title="Vultr"></a>Vultr</h3><p>Vultr 是美国知名云服务提供商 Choopa.com 旗下的 VPS 服务，Vultr 母公司 Choopa 一直在为游戏公司提供全球支撑服务，因此该公司在全球 14 个国家及地区部署数据中心，包括日本东京、新加坡、美国洛杉矶、西雅图、英国伦敦、德国等地。可谓公司资金雄厚，体验和服务一流，最重要的是价格亲民。当前最低仅需 $2.5/月，在这个价位的 VPS，单论性价比来说，基本没有对手。唯一能抗衡的也就只有<a href="https://banwagong.haokoucai.top/?f=vultr">搬瓦工</a>了。</p><p>*<strong>配置价格表</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-4193f7257ac6d7e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pei"></p><h3 id="对比结论"><a href="#对比结论" class="headerlink" title="对比结论"></a>对比结论</h3><p>根据自己的理解做出的简单结论</p><h4 id="1-价格对比"><a href="#1-价格对比" class="headerlink" title="1. 价格对比"></a>1. 价格对比</h4><p><a href="http://buy.haokoucai.top/bwg/buy.html?f=vultr&k=sec">搬瓦工</a>以年为付费单位，<strong>最低 19.99 美元/年</strong>(目前有新货)，<strong>常以 29.99/年美元为主</strong>。</p><p><strong><a href="http://buy.haokoucai.top/vultr/?k=sec">Vultr</a>以小时计费</strong>，最低 2.5 美元每月(该方案已经长期缺货，<strong>可以理解没有</strong>)，通常是** 5 美元/月**，一年就 60 美元。</p><p><strong>价格结论搬瓦工比Vultr便宜一半的价格，并且国内连接速度比Vultr快。</strong></p><h4 id="2-简单的使用-VPS"><a href="#2-简单的使用-VPS" class="headerlink" title="2. 简单的使用 VPS"></a>2. 简单的使用 VPS</h4><p>简单的使用指什么呢？就是不常在 VPS 上操作或者对 VPS 性能要求不是很高，比如用来科学上网（用来逛 youtube、fb、google 等）；在 linux 上学习基本操作。</p><p>如果使用场景是这样的话，就可以选择搬瓦工，因为搬瓦工最低的便宜，年付 ￥19.99，而且有 CN2线路（CN2线路为电信海外精品网络线路，ping下来在160ms~180ms左右，速度相对稳定）。Vultr 虽然有月付 $2.5 的，但是基本抢不到。</p><h4 id="3-建站"><a href="#3-建站" class="headerlink" title="3. 建站"></a>3. 建站</h4><p>面向中国用户的网站选择搬瓦工或 Vultr；面向海外用户的网站必选 Vultr。</p><p>搬瓦工在网络连接速度上有较大优势，中国用户访问速度较快且稳定，但 VPS 功能较弱，可以称之为 VPS 提供商。而 Vultr 是一个十足的云厂商，并且在海外用户上优势十分明显，在全球拥有 14 个机房，支持打快照镜像、防火墙策略、私有网络、多IP和IPV6、自定义镜像等诸多功能。</p><h4 id="4-高性能计算-大数据、机器学习"><a href="#4-高性能计算-大数据、机器学习" class="headerlink" title="4. 高性能计算(大数据、机器学习)"></a>4. 高性能计算(大数据、机器学习)</h4><p>这方面毫无疑问，直接 Vultr。</p><h4 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h4><p>想国内访问速度快选<a href="http://buy.haokoucai.top/bwg/buy.html?f=vultr&k=sec">搬瓦工 CN2 服务器</a>，想要 VPS 高品质服务就选 <a href="http://buy.haokoucai.top/vultr/?k=sec">Vultr</a>！</p><h2 id="如何使用-Vultr"><a href="#如何使用-Vultr" class="headerlink" title="如何使用 Vultr"></a>如何使用 Vultr</h2><p>我的需求是搭建博客，同时科学上网，说不定以后会部署其他服务，所以选择了 Vultr 的月付 $5 的方案。</p><h3 id="优惠活动"><a href="#优惠活动" class="headerlink" title="优惠活动"></a>优惠活动</h3><p>目前新用户注册是有优惠的，充 10 美元送 25 美元，如果抢到了 $2.5 / 月的，可以用一年呢，如果你换算成人民币来算这笔账，发现送得挺多的。</p><blockquote><p>注意：本次活动仅支持 Paypal 和信用卡付款，不支持支付宝付款！如果不享受这个活动是支付支付宝付款的。没有 Paypal 账户的去注册一个然后绑定下银行卡就行，10 分钟之内就能搞定。</p></blockquote><h3 id="具体使用方法"><a href="#具体使用方法" class="headerlink" title="具体使用方法"></a>具体使用方法</h3><ol><li>进入这个网址：<a href="https://www.vultr.com/promo25b/?service=promo25b">https://www.vultr.com/promo25b/?service=promo25b</a> 注册用户。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-5f9b679a24a6e9e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注册页面"></li><li>必须充值10刀，用于激活账户(如果没有右侧信息，则代表活动已经结束)<br><img src="https://upload-images.jianshu.io/upload_images/2974893-c5bdc2c2bd692123.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>右上角加号创建VPS，14个地区可以选择，优先选择北美和日本地区。 Los Angeles/Seattle/Silicon Valley/ Tokyo。我选的是洛杉矶的，据说相对较好。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-b2ae58d942e55b03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ol><li>选选择服务器系统的时候尽量选择 linux</li><li>Vultr 计算费用的方式是按小时计费的，可以看到我产生的费用还有零点零几刀，所以你其实可以同时购买多台 VPS，只是费用会相应增加倍数。如果你选择错了地区也可以销毁了重新新建一个。我觉得这种方式比一次把费用全部扣完好多了，因为如果你一段时间不想用服务器了，你可以随时停掉，然后费用不会扣。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-04c3e53e93c9c68a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></li></ol><h3 id="快速安装宝塔面板"><a href="#快速安装宝塔面板" class="headerlink" title="快速安装宝塔面板"></a>快速安装宝塔面板</h3><h4 id="1-通过-SSH-登录链接到-VPS"><a href="#1-通过-SSH-登录链接到-VPS" class="headerlink" title="1. 通过 SSH 登录链接到 VPS"></a>1. 通过 SSH 登录链接到 VPS</h4><h4 id="2-执行命令安装宝塔面板"><a href="#2-执行命令安装宝塔面板" class="headerlink" title="2. 执行命令安装宝塔面板"></a>2. 执行命令安装宝塔面板</h4><ul><li>CentOS安装命令：<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y wget &amp;&amp; wget -O <span class="hljs-keyword">install</span>.sh http://download.bt.cn/<span class="hljs-keyword">install</span>/<span class="hljs-keyword">install</span>.sh &amp;&amp; sh <span class="hljs-keyword">install</span>.sh<br></code></pre></td></tr></table></figure></li><li>Ubuntu/Deepin安装命令：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -O install.sh http:<span class="hljs-regexp">//</span>download.bt.cn<span class="hljs-regexp">/install/i</span>nstall-ubuntu.sh &amp;&amp; sudo bash install.sh<br></code></pre></td></tr></table></figure></li><li>Debian安装命令：<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -O install.sh http:<span class="hljs-regexp">//</span>download.bt.cn<span class="hljs-regexp">/install/i</span>nstall-ubuntu.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure></li><li>Fedora安装命令:<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">wget -O install.sh http:<span class="hljs-regexp">//</span>download.bt.cn<span class="hljs-regexp">/install/i</span>nstall.sh &amp;&amp; bash install.sh<br></code></pre></td></tr></table></figure>根据提示输入 “y” 或者自定义目录，新手不了解的情况下最好不要动。</li></ul><p>等待完成安装过程，出现“安装成功”字样则说明成功安装。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-24fed73bccb5f2fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><h4 id="3-登录面板后台"><a href="#3-登录面板后台" class="headerlink" title="3. 登录面板后台"></a>3. 登录面板后台</h4><p>根据安装成功的提示信息，使用对应的用户名和密码访问面板后台。通常是 <a href="http://ip:8888/">http://IP:8888/</a> ，成功登录后可以将用户名和密码进行修改，避免黑客进行攻击。</p><h4 id="4-安装Web运行环境"><a href="#4-安装Web运行环境" class="headerlink" title="4. 安装Web运行环境"></a>4. 安装Web运行环境</h4><p>这里我们以当前最为流程的Web架构进行演示，即LNMP(Linux + Nginx + MySQL + PHP)或LAMP(Linux + Apache + MySQL + PHP)，这里我们推荐使用LNMP，目前从各方面来看均优于Apache。稍等几分钟即可完成全部安装，建议使用极速安装，速度快，新手友好。</p><h3 id="科学上网，搭建-Shadowsocks-服务"><a href="#科学上网，搭建-Shadowsocks-服务" class="headerlink" title="科学上网，搭建 Shadowsocks 服务"></a>科学上网，搭建 Shadowsocks 服务</h3><h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>yum install m2crypto python-setuptools<br><span class="hljs-variable">$ </span>easy_install pip<br><span class="hljs-variable">$ </span>pip install shadowsocks<br></code></pre></td></tr></table></figure><h4 id="安装完成后配置服务器参数"><a href="#安装完成后配置服务器参数" class="headerlink" title="安装完成后配置服务器参数"></a>安装完成后配置服务器参数</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ vi  <span class="hljs-regexp">/etc/</span>shadowsocks.json<br></code></pre></td></tr></table></figure><p>写入如下配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;<br>    &quot;server&quot;:&quot;0.0.0.0&quot;,<br>    &quot;server_port&quot;:443,<br>    &quot;local_address&quot;: &quot;127.0.0.1&quot;,<br>    &quot;local_port&quot;:1080,<br>    &quot;password&quot;:&quot;123456&quot;,<br>    &quot;timeout&quot;:300,<br>    &quot;method&quot;:&quot;aes-256-cfb&quot;,<br>    &quot;fast_open&quot;: false<br>&#125;<br></code></pre></td></tr></table></figure><p>多端口配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;server&quot;</span>:<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;local_address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>    <span class="hljs-attr">&quot;local_port&quot;</span>:<span class="hljs-number">1080</span>,<br>    <span class="hljs-attr">&quot;port_password&quot;</span>: &#123;<br>         <span class="hljs-attr">&quot;443&quot;</span>: <span class="hljs-string">&quot;443&quot;</span>,<br>         <span class="hljs-attr">&quot;8888&quot;</span>: <span class="hljs-string">&quot;8888&quot;</span><br>     &#125;,<br>    <span class="hljs-attr">&quot;timeout&quot;</span>:<span class="hljs-number">300</span>,<br>    <span class="hljs-attr">&quot;method&quot;</span>:<span class="hljs-string">&quot;aes-256-cfb&quot;</span>,<br>    <span class="hljs-attr">&quot;fast_open&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中server字段与local_address填写之前的IP Address。password是自己用于连接这个shadow socks的密码，自定义就好。</p><h4 id="配置防火墙"><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 安装防火墙</span><br><span class="hljs-variable">$</span> yum install firewalld<br><span class="hljs-comment"># 启动防火墙</span><br><span class="hljs-variable">$</span> systemctl <span class="hljs-built_in">start</span> firewalld<br></code></pre></td></tr></table></figure><h4 id="开启防火墙相应的端口"><a href="#开启防火墙相应的端口" class="headerlink" title="开启防火墙相应的端口"></a>开启防火墙相应的端口</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 开启端口号 443</span><br>$ firewall-cmd <span class="hljs-params">--permanent</span> <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=443/tcp</span><br>$ firewall-cmd <span class="hljs-params">--reload</span><br></code></pre></td></tr></table></figure><h4 id="启动-Shadowsocks-服务"><a href="#启动-Shadowsocks-服务" class="headerlink" title="启动 Shadowsocks 服务"></a>启动 Shadowsocks 服务</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ ssserver -c <span class="hljs-regexp">/etc/</span>shadowsocks.json<br></code></pre></td></tr></table></figure><p>后台运行应用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ nohup ssserver -c <span class="hljs-regexp">/etc/</span>shadowsocks.json &amp;<br></code></pre></td></tr></table></figure><p>完成服务端的搭建之后，客户端就很容易了。</p>]]></content>
    
    
    <categories>
      
      <category>基础教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VPS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么javascript经常被黑？</title>
    <link href="/index.php/archives/96/"/>
    <url>/index.php/archives/96/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个问题是知乎上有人邀我回答的，感觉挺有意思的，所以发出来大家讨论下</p><h3 id="1-语言自身问题"><a href="#1-语言自身问题" class="headerlink" title="1. 语言自身问题"></a>1. 语言自身问题</h3><p>Javascript 之父在花 10 天设计出来的，再牛逼的人，10 天设计出来的肯定会有很多设计不合理的东西，哪些不合理的东西，可以去看《JavaScript语言精粹》，导致这本语言一直是最具争论的一门语言。</p><p>但是背负着这么大的舆论，那么多很烂的特性，还要兼容各种浏览器，js 还能发展得这么好，web前端，移动，服务端，桌面端，甚至游戏，物联网，机器学习等，可见那些好的特性还是非常好的，具体可以看我的这篇文章–<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247483812&idx=1&sn=cbd6d86c9b2ef574a1cdfd900f1d1faf&chksm=ea0162c8dd76ebdeb995d71506d63277ecba8abb38dd27ce324844bf1b2b9945833043b7f8ac&mpshare=1&scene=1&srcid=062125hGYjz36xXvKau0zLPk#rd">Javascript 是最好的语言，不服来辩</a>。</p><h3 id="2-开发者水平差距太大"><a href="#2-开发者水平差距太大" class="headerlink" title="2. 开发者水平差距太大"></a>2. 开发者水平差距太大</h3><p>js 这门语言虽然能做的事儿很多，主要还是用在写前端上，对于前端这门职业，相对其他方向比较简单，容易上手，不需要太多计算机基础知识，导致刚培训出来的，或者自学的同学，可能见的世面比较少，学了点 node，会用 express 了，就说自己是全栈，所以就黑前端，前端一想就是 js 不好</p><h3 id="3-javascript-相对还是比较简单"><a href="#3-javascript-相对还是比较简单" class="headerlink" title="3. javascript 相对还是比较简单"></a>3. javascript 相对还是比较简单</h3><p>有没有发现，越简单的越容易被人黑，比如 vue，vue 被黑的次数比 react 多多了，说 vue 是新手玩的，没水平，就连正妹也说过类似的话，我记得是在哪里看到过他在某个群里说过的，如果是p的就忽略。但是简单就不代表不好，简单能达到同样功能不应该更伟大吗？</p><h3 id="4-门槛低"><a href="#4-门槛低" class="headerlink" title="4. 门槛低"></a>4. 门槛低</h3><p>社区高水平的不多，或者说门槛太低，什么人都有。</p><p>这个我就拿 emacs 社区举例，emacs 社区是真的好，文档质量超高，目前是我见到社区质量最好的，因为门槛高，学 emacs 的大部分都是真正喜欢敲代码的，而不是喜欢撕逼的，跟第二点一样，前端圈水平低的太多，导致 js 被黑。</p><h3 id="5-前端发展太快"><a href="#5-前端发展太快" class="headerlink" title="5. 前端发展太快"></a>5. 前端发展太快</h3><p>前端发展太快， js 框架层出不穷，然后经常会有各种框架之间的撕逼，某某框架好啥啥啥的，才会有大漠老师事件等，这种机会让其他圈看笑话了，说我们前端圈是真的乱，好好敲代码不好嘛，争哪个框架好有啥意义，又不是你写的，争赢了自己脸上又不贴金，在此引用狼叔说的，少抱怨，多做事。有本事自己写一个框架然后说服别人你这框架比尤大的 vue 好。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>最后我觉得 javascript 挺好的，然后希望作为前端的我们，静下心来好好学习，别让其他圈的看我们的笑话，最后还是想说， <a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247483812&idx=1&sn=cbd6d86c9b2ef574a1cdfd900f1d1faf&chksm=ea0162c8dd76ebdeb995d71506d63277ecba8abb38dd27ce324844bf1b2b9945833043b7f8ac&mpshare=1&scene=1&srcid=062125hGYjz36xXvKau0zLPk#rd">Javascript 是最好的语言，不服来辩</a>。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 是最好的语言，不服来辩</title>
    <link href="/index.php/archives/95/"/>
    <url>/index.php/archives/95/</url>
    
    <content type="html"><![CDATA[<p>看到这个标题相信很多人就要开始跟我争论了，PHP 才是最好的语言，那就请原谅下，你说是就是，我们来看看就知道了。</p><p>有一条 Atwood 定律：any application that can be written in JavaScript, will eventually be written in JavaScript</p><p>翻译一下就是：任何可以用 JavaScript 来写的应用，最终都将用 JavaScript 来写</p><p>要是没看到过这句话的人可能又要开始说了，Atwood 是谁，他说最终会就会啊。</p><p>那我们来了解一下他，说那些多少年的编程经验啊，这些都没啥用，只要说一点，就能知道这个人也不是等闲之辈，他是 stack overflow 的联合创始人，还是牛逼吧，如果你说你不知道 stackoverflow，那么对不起，那么我们不能做朋友了（开玩笑的，不知道的去了解下吧）</p><h2 id="Javascript-可以做什么"><a href="#Javascript-可以做什么" class="headerlink" title="Javascript 可以做什么"></a>Javascript 可以做什么</h2><h3 id="1-Web-前端"><a href="#1-Web-前端" class="headerlink" title="1.  Web 前端"></a>1.  Web 前端</h3><p>相信这个这个是毫无疑问的，在 Web 前端的地位目前是没有任何语言能撼动它的霸主地位。<br><img src="https://upload-images.jianshu.io/upload_images/2974893-fd552485a3ae95dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="2-后端-Nodejs"><a href="#2-后端-Nodejs" class="headerlink" title="2. 后端 Nodejs"></a>2. 后端 Nodejs</h3><p>Node.js 是一个 Javascript 运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装。Node.js 对一些特殊用例进行优化，提供替代的 API，使得V8在非浏览器环境下运行得更好。</p><p>使 Javascript 走向了服务端，这使得 Web 应用仅用一种语言即可完成。</p><h3 id="3-桌面应用"><a href="#3-桌面应用" class="headerlink" title="3. 桌面应用"></a>3. 桌面应用</h3><blockquote><p>代表 Electron ，还有 Node-webkit 、heX</p></blockquote><p>Electron 是由 Github 开发，用 HTML，CSS 和 JavaScript 来构建跨平台桌面应用程序的一个开源库。 Electron 通过将 Chromium  和 Node.js 合并到同一个运行时环境中，并将其打包为 Mac，Windows 和 Linux 系统下的应用来实现这一目的。</p><h3 id="4-移动端应用"><a href="#4-移动端应用" class="headerlink" title="4. 移动端应用"></a>4. 移动端应用</h3><blockquote><p>代表 React Native，Weex 生态还不完善</p></blockquote><p>React Native (简称RN) 是 Facebook 于 2015 年 4 月开源的跨平台移动应用开发框架，是 Facebook 早先开源的 JS 框架 React 在原生移动应用平台的衍生产物，目前支持 iOS 和安卓两大平台。RN 使用 Javascript 语言，类似于 HTML 的 JSX，以及CSS 来开发移动应用，因此熟悉 Web 前端开发的技术人员只需很少的学习就可以进入移动应用开发领域。做到了一套代码可以运行在 Web、安卓和 IOS 上。</p><h3 id="5-游戏"><a href="#5-游戏" class="headerlink" title="5. 游戏"></a>5. 游戏</h3><blockquote><p>代表 Cocos2d-js 和 Unity 3D，还有 Pomelo、Bearcat</p></blockquote><p>世界上最流行的 2D 游戏引擎之一 Cocos2d 和最流行的 3D 游戏引擎之一均支持 JS 开发游戏。</p><p>Cocos2d 主要开发中小型的 2D 游戏而 Unity 3D 主要用于开发大型的 3D 游戏。</p><h4 id="Cocos2d-JS"><a href="#Cocos2d-JS" class="headerlink" title="Cocos2d-JS"></a>Cocos2d-JS</h4><p>Cocos2d-JS 是跨全平台的游戏引擎，采用原生 JavaScript 语言，可发布到包括 Web 平台，iOS，Android，Windows Phone8，Mac，Windows 等平台，引擎基于MIT 开源协议，完全开源，免费，易学易用，拥有活跃的社区支持。Cocos2d-JS 让2D 的游戏编程门槛更低，使用更加容易和高效。和其他类似游戏框架相比，它定义了更加清晰的2D游戏编程的基本组件，采用易学易用的 API 设计，并采用全球领先、具备原生性能的脚本绑定解决方案实现游戏的跨原生平台发布，开发效率更高，使用上最简单。</p><h4 id="Unity-3D"><a href="#Unity-3D" class="headerlink" title="Unity 3D"></a>Unity 3D</h4><p>Unity 3D 可以用 javascript 开发，也可以用 C# 开发。</p><h3 id="6-物联网"><a href="#6-物联网" class="headerlink" title="6. 物联网"></a>6. 物联网</h3><blockquote><p>代表 Cylon.js，还有 IoT.js</p></blockquote><p>Cylon.js 是一个为机器人学和物联网服务的开发的 Javascript 框架。它支持 19 种不同硬件软件平台。我们的目标，是将开发软件装置变得和开发网页一样简单。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-dbf8fa842d9274a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这是 2017 年 Github 最流行的 15 种语言排行榜，可以看到 Javascript 的项目数是第二名的两倍，Javascript 之所以这么流行，我想原因之一也是因为这门语言所涉及的范围太广了。</p><p>看到这里，我只想说<br><img src="https://upload-images.jianshu.io/upload_images/2974893-ef43bb322c79a3bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="还有谁"></p><h2 id="将你擅长的语言编译为JavaScript"><a href="#将你擅长的语言编译为JavaScript" class="headerlink" title="将你擅长的语言编译为JavaScript"></a>将你擅长的语言编译为JavaScript</h2><p>看到 Javascript 无孔不入，啥都能做，是不是在担心现在不会怎么办，不要担心，现在有很多工具帮你将你擅长的语言编译成 Javascript</p><h3 id="将-Java-编译成-Javascript"><a href="#将-Java-编译成-Javascript" class="headerlink" title="将 Java 编译成 Javascript"></a>将 Java 编译成 Javascript</h3><ul><li><p>  <a href="https://github.com/nurv/BicaVM">BicaVM</a>：一个使用JavaScript实现的JVM，可以运行60%的Java字节码</p></li><li><p>  <a href="http://ceylon-lang.org/">Ceylon</a>：一个可编译为JavaScript的、模块化的、静态类型JVM语言</p></li><li><p>  <a href="http://int3.github.com/doppio/about.html">Doppio</a>：一个使用 Coffeescript 实现的JVM，使得 Java 程序可以运行在任何 JavaScript 引擎上</p><h3 id="将-C-C-代码编译为-JavaScript"><a href="#将-C-C-代码编译为-JavaScript" class="headerlink" title="将 C/C++ 代码编译为 JavaScript"></a>将 C/C++ 代码编译为 JavaScript</h3><p>C/C++ 如今也可以用来编写Web应用程序，同样可以将它们编译为 JavaScript。一些工具如下。</p></li><li><p>  <a href="http://www.emscripten.org/">Emscripten</a>：Mozilla 开发的 LLVM 后端，可以将任何通过 LLVM 前端（比如 C/C++ Clang）生成的 LLVMIR 中间码编译成 JavaScript 代码。</p></li><li><p>  <a href="http://lethalman.hostei.com/maja/index.html">mala</a>：可以将 vala 代码（vala代码在编译时，首先会编译为 C 代码）编译为 JavaScript</p></li><li><p>  <a href="http://www.mandreel.com/">Mandreel</a>：可以将 C++ 和 Objective-C 代码编译为高度优化的JavaScript源码</p></li><li><p>  <a href="http://cluecc.sourceforge.net/">Clue</a>：一个 C 语言编译器，可以将 C 语言代码编译为高质量的 Lua、Javascript 或 Perl 代码。</p></li></ul><h3 id="将Python代码编译为JavaScript"><a href="#将Python代码编译为JavaScript" class="headerlink" title="将Python代码编译为JavaScript"></a>将Python代码编译为JavaScript</h3><p>可以使用如下工具将 Python 代码编译为 JavaScript 代码。</p><ul><li><p>  <a href="http://brython.info/index_en.html">Brython</a>：用于替换网页上的 JavaScript 代码，允许使用 Python 来编写脚本，并直接在网页上执行</p></li><li><p>  <a href="https://github.com/andrewschaaf/pyxc-pj">PYXC-PJ</a>：可以将 Python 转换为JavaScript，并会产生一个行/列号映射文件</p></li><li><p>  <a href="http://pyjaco.org/demo">Pyjaco</a>：可以将 Python 转换为 JavaScript</p></li><li><p>  <a href="http://pyjs.org/">Pyjamas</a>：Python to JS转换器</p></li><li><p>  <a href="https://github.com/anandology/pyjs">Pyjs</a>：Python to JS转换器</p></li></ul><h3 id="将Ruby代码编译为JavaScript"><a href="#将Ruby代码编译为JavaScript" class="headerlink" title="将Ruby代码编译为JavaScript"></a>将Ruby代码编译为JavaScript</h3><p>　　在Ruby领域，有一个使用JavaScript实现的Ruby标准库—— <a href="http://rubyjs.org/index.html">RubyJS</a>，它实现了Ruby中的所有方法，如Array、Numbers、Time等。Ruby之父松本行弘称“如果我必须编写JavaScript代码，我会使用RubyJS”。</p><p>　　另外，你也可以使用如下工具将Ruby代码编译为JavaScript代码。</p><ul><li><p>  <a href="https://github.com/mattknox/8ball">8ball</a>：一个可以将Ruby（或Ruby子集）的源码转换为JavaScript源码的编译器</p></li><li><p>  <a href="https://github.com/whitequark/coldruby">ColdRuby</a>：一个Ruby 1.9 MRI字节码编译器和JS运行时，包括一个C++运行时以及用于本地执行的V8引擎</p></li><li><p>  <a href="http://hotruby.yukoba.jp/">HotRuby</a>：可以在浏览器内部或Flash平台上运行由YARV编译的Ruby操作码</p></li><li><p>  <a href="http://opalrb.org/">Opal</a>： 一个Ruby to JavaScript编译器，可用于任何JS环境</p></li><li><p>  <a href="http://rb2js.rubyforge.org/">rb2js</a>：一个Ruby to JavaScript编译器</p></li><li><p>  <a href="https://github.com/jessesielaff/red">Red</a>：允许你以 Ruby 的方式编写代码，然后以 JavaScript 的方式运行代码</p><h3 id="将-NET-代码编译为-JavaScript"><a href="#将-NET-代码编译为-JavaScript" class="headerlink" title="将 .NET 代码编译为 JavaScript"></a>将 .NET 代码编译为 JavaScript</h3></li></ul><p>　　你可以使用如下工具将 C# 、.NET 代码编译为 JavaScript 代码。</p><ul><li><p>  <a href="https://github.com/vannatech/blade">Blade</a>：一个 Visual Studio 扩展，可以将 C# 代码转换为 JavaScript</p></li><li><p>  <a href="http://jsc.sourceforge.net/">jsc</a>：可将 .NET 程序重新编译为 JavaScript、ActionScript、PHP 或 Java 程序</p></li><li><p>  <a href="https://github.com/kevingadd/JSIL">JSIL</a>：可将MSIL（.NET字节码）转换为 JavaScript</p></li><li><p>  <a href="http://www.saltarelle-compiler.com/">Saltarelle</a>：可将 C# 代码编译为 Javascript</p></li><li><p>  <a href="http://sharpkit.net/">SharpKit</a>（商业工具）：可将 C# 代码编译为 Javascript</p></li><li><p>  <a href="http://projects.nikhilk.net/ScriptSharp">Script#</a>： 可将 C# 代码编译为 Javascript</p></li></ul><p>可能这篇文章被吐槽的比较多，特别是标题，我只想说，你说的都对，我只是个标题党。</p><p>每种语言都有自己的适用场景，没有任何一种语言能啥都做得好，根据自己的需要选择就行，我这里知识做一个类似科普，万万没想到 Javascript 这么强大。</p><p>下面是我公众号，欢迎来辩</p><p><img src="http://www.taoweng.site/usr/uploads/2018/08/2153731188.jpg" alt="qrcode_for_gh_39aba8571ae1_258.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给在校准备找工作的同学的几个建议</title>
    <link href="/index.php/archives/91/"/>
    <url>/index.php/archives/91/</url>
    
    <content type="html"><![CDATA[<ol><li>了解 vim</li><li>养成 git 规范</li><li>学深比学广更重要</li><li>拥有自己的知识体系，形成解决问题的方法论</li></ol><h2 id="了解-vim"><a href="#了解-vim" class="headerlink" title="了解 vim"></a>了解 vim</h2><p>Vim 被誉为”编辑器之神”，这可不是虚的。</p><p>在我用了 vim 半年之后，我建议我身边的每一位程序员都去学习 vim 。</p><p>因为一旦你学会了 vim 的操作，你就像中了毒一样，你会讨厌鼠标，讨厌在你敲着敲着键盘，突然又要去移动光标，因为把手从键盘移动到鼠标上的时间远远大于手指在键盘按键的切换。</p><p>而且你会希望在所有的编辑器上都装有 vim 插件，不管是 vscode，还是 idea，还是 emacs；不管是自己的电脑还是别人的电脑；不管是敲代码的编辑器还是用来看网页的浏览器。</p><p>还好，所希望的都有，每一个可以装插件的编辑器都有 vim 插件，甚至浏览器也有 vimum。</p><p>当你真正习惯上了 vim 以后，你会迫不及待的想要一个机械键盘，因为你敲代码大部分时间都用在了键盘上，鼠标已经不再那么重要了。</p><p>机械键盘推荐红轴，青轴和茶轴虽然自己敲着很舒服，手感很好，但是比较影响其他人，键盘声太吵了，黑轴就不考虑了，码字太累了，不适合程序员。</p><p>我个人用过青轴和红轴，青轴给我的感觉就是码代码是一颗一颗的，听着那声音自己觉得很舒服，敲代码很有感觉。</p><p>而红轴给我的感觉就是敲代码的时候你会忘记你手上的键盘，给我一种手、键盘合一的感觉，把精力完全集中在码代码上，感受不到敲键盘的感觉。</p><p>最后说的就是先学 vim 的基本操作，然后装个插件在你现在的编辑器上练习就行了，不需要直接用 vim 编辑器。</p><p>因为你直接用 vim 编辑器，作为一个新手，不会配置插件，快捷键等，没有提示，没有高亮。你在写项目的时候会很痛苦，你就用你熟悉的编辑器高亮，代码提示这些是你以前搞好了的，所以实际应用起来难度小很多。</p><p>为了推荐更多人程序员学习 vim ，我还自己写了一篇<a href="https://mp.weixin.qq.com/s?__biz=MzI1ODk2Mjk0Nw==&mid=2247483662&idx=1&sn=8d9e14e0b583f02bfc29d726d889c49a&chksm=ea016262dd76eb745893de4d10c98c5edf56a3c21ff1f817e5e40b9aa563c1028e30b97387bc&mpshare=1&scene=1&srcid=0522If3l13mrVdZnJaMXJwsw#rd">入门文章</a>，有兴趣的可以看看。</p><p>我周围的人，只要是用 vim 敲过代码的，从没有人说过用 vim 敲代码不好用而放弃用的，只会对 vim 爱得越来越深。</p><h2 id="Git-规范"><a href="#Git-规范" class="headerlink" title="Git 规范"></a>Git 规范</h2><p>Git 作为我认为最优秀的版本管理工具，那是程序员的利器，必须用得游刃有余。</p><p>而我今天要说的不是怎么用好 git，如果需要可以留言给我，我后面写一篇或者一个系列。</p><p>我想说的是规范，不要以为 commit 随便写就行了，其实 commit 的规范程度一部分体现了你这个人做事的态度，是否端正，严谨。</p><p>我拿我在 某米工作的时候举个例子，我有个朋友那组的有个学姐，她的 commit 很随意，完全不能体现她提交代码的内容，比如，哈哈；放假了，好开心；bug；也不说是什么 bug，导致我那个同学根本不知道她提交了什么代码。</p><p>也不知道她做了那些事儿，在一个团队中，这是一件很蛋疼的事儿。</p><p>特别要是老大或者同事想做 review 的时候，看到这么糟糕的 commit 定会对你的印象大打折扣。</p><p>如果你是个实习生，估计就不容易转正了，因为会觉得你是一个很随便的人。</p><p>我平常所用的规范来自于阮老师的规范。<br>链接： <a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></p><h2 id="深度比广度重要"><a href="#深度比广度重要" class="headerlink" title="深度比广度重要"></a>深度比广度重要</h2><p>现在还在学校的同学，可能经常听学长们这么说，在面试的时候既要考你的深度，也要考你的广度，所谓深度简单点说就是对某个知识点的掌握程度，而广度就是你知道多少个知识点。</p><p>举个例子，也许你会经常听到那些面试过的人回来这么说，那个面试官一直抓住一个问题不放，知道他打不出来为止，这就是在探究掌握的深度。</p><p>然后也会有这种问题，你会什么什么吗？你了解什么什么？你用过什么什么？这就是在看你的广度。</p><p>所以一些在校学生就不知道自己应该去扩展自己的宽度，应该去学新知识，还是挖掘深度，再去研究以前的知识。</p><p>我也面试过不少大厂，也拿了几个 offer，以及自己实习的时候跟一些工作多年的老司机谈过话。</p><p>最后给出的答案是深度比广度重要。</p><p>我来以我的角度谈谈为什么深度比广度重要。</p><p>不知道你身边有没有这样的事儿发生，有个人（A 同学）拿到了一个好点的 offer，但和他一起的（B 同学）可能你觉得技术比他还厉害的没有拿到，然后你问那个拿到 offer 的同学，他说他是运气好。</p><p>分析一下这个事儿，会发现，其实有可能确实运气原因，比如</p><ul><li><p>他们俩不是同一个面试官，然后导致两个面试官问的题不同，以及面试官的判断标准不同。</p></li><li><p>他们俩是同一个面试官，但是 A 同学和 B 同学的技术不同，A 同学技术栈跟面试官的技术栈重合性比较多，因为经统计，那些面试官更喜欢找跟自己更相似的人，因为面试官觉得自己比较优秀，跟他相似度越高，会认为这个面试者也比较优秀。</p></li></ul><p>前面这两种基于运气的情况下，当然肯定 A 同学有实力的，基础不扎实，运气来了也抓不住。</p><p>那我们怎么才能让运气来了就能抓住呢？ </p><p>我的建议就是先深度再广度，深度可以体现一个人对知识「打破砂锅问到底」的精神，，对于不知道的问题喜欢探索，也许你就精通了一门框架（前端比如 React），对于其他框架只是了解，但是这样也比熟练使用好几个框架面试成功几率大得多，因为如果你遇到 React 技术栈的面试官，你是大概率能过的。对于熟练使用好几个框架而不精通的，就是这种，面试官问你会什么什么吗？答，我会啊，然后问深一点就不知道了，这种过的几率就要小很多。</p><p>所以为了运气来了的时候你就能抓住，好好挖掘你的深度很重要。</p><p>如果你在考虑我是应该把以前的东西巩固一下，还是该去学新知识，你仔细思考一下，你对以前熟悉的知识深度够不够，够了再去学新知识，不要啥都会，被面试官问的时候，啥都不会（这是我昨天晚上跟我们班一个培训出来的同学聊的时候的出来的，他说培训的时候学了很多东西，然后我一问他框架原理，都答不上来，得出的结论就是只会用 API）。</p><p>然后我说的是深度比广度更重要对于在校生来说，而不是广度不重要，给你说这个的目的是在你不知道应该学新东西，还是巩固以前知识的建议。</p><h2 id="拥有自己的知识体系，形成解决问题的方法论"><a href="#拥有自己的知识体系，形成解决问题的方法论" class="headerlink" title="拥有自己的知识体系，形成解决问题的方法论"></a>拥有自己的知识体系，形成解决问题的方法论</h2><p>巩固基础，拥有自己的知识体系，形成解决问题的方法论，这个要求是我去小米实习我老大第一周给我说的东西。</p><p>当时我其实很不理解，所谓的知识体系是什么，还要谈到方法论这种东西，感觉一脸懵逼，经过我这么久的思考实践，我谈谈我的理解。</p><p>其实知识体系和解决问题的方法论是相辅相成的，在自己解决问题的时候，会用到知识体系的东西，知识体系的形成，也有部分是通过解决问题来添砖加瓦的。</p><p>什么是知识体系呢？</p><p>可以说是一个思维导图，这个思维导图就是你所掌握的知识的一个汇总，或者没掌握，你觉得需要应该掌握的知识。比如作为一个前端工程师，你应该会 HTML、CSS、Javascript、前端框架、HTTP 相关知识、web 安全相关知识等等。</p><p>关于 Javascript 需要掌握基本类型、函数、对象、内置对象、等知识，</p><p>然后函数要掌握闭包、作用域、this等，对象要掌握原型、new这些等等。</p><p>我就不再扩展了，根据自己的知识形成一个知识体系，然后再解决问题的时候就很容易根据自己的知识体系来解决问题，比如可能你遇到了跨域的问题，你从你的大脑搜索整个知识体系的时候，就可以知道跨域有哪几种方法，然后每种方法的适用场景是什么。</p><p>在形成自己的知识体系的过程中，你就知道自己对哪些知识了解，哪些知识不了解，然后你就会花时间去补充自己不了解的知识，渐渐完善自己的知识体系。</p><p>在形成自己的知识体系之后，你面试就比较胸有成竹，兵来将挡水来土掩。</p><p>你的知识体系就像一张网，面试的过程就是来检验你这张网漏洞有多大的过程，而学习的过程就是就像是给这张网空隙给编织细一点，你的最终目的就是使你这张网的空隙越来越小。</p><p><img src="http://www.taoweng.site/usr/uploads/2018/05/2855389845.jpg" alt="qrcode_for_gh_39aba8571ae1_860.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6之路之模块详解</title>
    <link href="/index.php/archives/88/"/>
    <url>/index.php/archives/88/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="何为模块"><a href="#何为模块" class="headerlink" title="何为模块"></a>何为模块</h3><p>一个模块只不过是一个写在文件中的 JavaScript 代码块。</p><p>模块中的函数或变量不可用，除非模块文件导出它们。</p><p>简单地说，这些模块可以帮助你在你的模块中编写代码，并且只公开应该被你的代码的其他部分访问的代码部分。</p><h3 id="为什么要使用模块"><a href="#为什么要使用模块" class="headerlink" title="为什么要使用模块"></a>为什么要使用模块</h3><ol><li>增加可维护性：由于每个模块都是独立的，每个人写的代码是不会相互影响的，在维护代码的时候很好排查是哪个模块出错。</li><li>可复用性：在日常的开发中，特别是大点的项目，代码的可复用性就更重要了，也许你会用复制粘贴的形式，但是直接一个 import 命令就可以搞定，岂不快哉。</li><li>避免命名污染：在 javascript 脚本中，所有的 js 文件的顶级作用域创建的变量，会被添加到共享的全局作用域，这就会导致不同的人开发的代码可能会有相同的变量名，导致变量名污染。</li></ol><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="导出模块"><a href="#导出模块" class="headerlink" title="导出模块"></a>导出模块</h3><p>导出模块所用的命令是 export。</p><p>前面也提到一个模块就是一个 javascript 文件，在这个模块中定义的变量，外部是无法获取到的，只有通过 export 导出的变量其他模块才可以用</p><p>最简单的导出方式就是在声明的变量、函数、类前面加一个 export </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export1.js </span><br><br><span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;桃翁&#x27;</span>;<br><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;欢迎关注公众号：前端桃园&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 导出类</span><br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 私有函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">privateFunction</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是私有函数，外部访问不了我&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：</p></blockquote><ol><li>被导出的函数或者类，都必须要有名称，意思就是说不能用这种方式导出匿名函数或者匿名类。</li><li>privateFunction 函数，没有加 export 命令，被当做这个模块的私有变量，其他模块是访问不到的。</li></ol><p>除了上面那种导出方式，还有另外一种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export2.js</span><br><br><span class="hljs-comment">// 导出变量</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;桃翁&#x27;</span>；<br><br><span class="hljs-comment">// 导出函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 导出类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">newName</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = newName;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 私有函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">privateFunction</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是私有函数，外部访问不了我&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; name, print, Person &#125;<br></code></pre></td></tr></table></figure><p>上面这种写法导入一组变量，与 export1.js 是等价的。</p><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><p>导入的模块可以理解为是生产者（或者服务的提供者），而使用导入的模块的模块就是消费者。</p><p>导入模块的命令是 import, import 的基本形式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; var1, var2 &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./example.js&#x27;</span><br></code></pre></td></tr></table></figure><p>import 语句包含两部分：一是导入需要的标识符，二是模块的来源。</p><blockquote><p>注意：浏览器中模块来源要以「/」或者 「./」 或者 「../」开头 或者 url 形式，不然会报错。</p></blockquote><p>例如我们导入 export1.js 模块，可以这么导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import1.js</span><br><span class="hljs-keyword">import</span> &#123; name, print, Person &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export1.js&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 桃翁</span><br><br><span class="hljs-built_in">console</span>.log(print()); <span class="hljs-comment">// 欢迎关注公众号：前端桃园</span><br><br><span class="hljs-comment">// 报错, 不能定义相同名字变量</span><br><span class="hljs-keyword">let</span> name = <span class="hljs-number">2333</span>; <br><br><span class="hljs-comment">// 报错，不能重新赋值</span><br>name = <span class="hljs-string">&quot;小猪&quot;</span>;<br></code></pre></td></tr></table></figure><p>可以看到导入绑定(这里不理解绑定，文章后面会解释)时，形式类似于对象解构，但实际上并无关联。</p><p>当导入绑定的时候，绑定类似于使用了 const 定义，意味着不能定义相同的变量名，但是没有暂时性死区特性(但是在 深入理解ES6 这本书里面说是有暂时性死区限制，我在 chrome 上测试了的，读者希望也去试下，到底受不受限制)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-number">2333</span>;<br></code></pre></td></tr></table></figure><p>上面这行代码会报错。</p><h4 id="命名空间导入"><a href="#命名空间导入" class="headerlink" title="命名空间导入"></a>命名空间导入</h4><p>这种导入方式是把整个生产者模块当做单一对象导入，所有的导出被当做对象的属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascirpt">// import2.js<br>import * as namespace from &#x27;./export1.js&#x27;<br><br>console.log(namespace.name); // 桃翁<br><br>console.log(namespace.print()); // 欢迎关注公众号：前端桃园<br></code></pre></td></tr></table></figure><h2 id="重命名导入导出"><a href="#重命名导入导出" class="headerlink" title="重命名导入导出"></a>重命名导入导出</h2><p>有时候你并不想导出变量的原名称，需要重新命名,这个时候只需要使用 as 关键字来制定新的名字即可。</p><h3 id="重命名导出"><a href="#重命名导出" class="headerlink" title="重命名导出"></a>重命名导出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// export3.js</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; print <span class="hljs-keyword">as</span> advertising &#125;<br></code></pre></td></tr></table></figure><h3 id="导重命名入"><a href="#导重命名入" class="headerlink" title="导重命名入"></a>导重命名入</h3><p>拿上面导出的举例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// import3.js</span><br><span class="hljs-keyword">import</span> &#123; advertising <span class="hljs-keyword">as</span> print &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export3.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> advertising); <span class="hljs-comment">// &quot;undefined&quot;</span><br><br><span class="hljs-built_in">console</span>.log(print()); <span class="hljs-comment">// 欢迎关注公众号：前端桃园 </span><br></code></pre></td></tr></table></figure><p>此代码导入 advertising 函数并重命名为了 print ，这意味着此模块中 advertising 标识符不存在了。</p><h3 id="default-关键字"><a href="#default-关键字" class="headerlink" title="default 关键字"></a>default 关键字</h3><p>default 关键字是用来做默认导入导出的。</p><h4 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// defaultExport.js</span><br><br><span class="hljs-comment">// 第一种默认导出方式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// 第二种默认导出方式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> print;<br><br><span class="hljs-comment">// 第三种默认导出方式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; print <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;<br></code></pre></td></tr></table></figure><p>default 这个关键字在 JS 中具有特殊含义，既可以作为同命名导出，又标明了模块需要使用默认值。</p><blockquote><p>注意： 一个模块中只能有一个默认导出。 </p></blockquote><h4 id="默认导入"><a href="#默认导入" class="headerlink" title="默认导入"></a>默认导入</h4><p>默认导入和一般的导入不同之处就是不需要写大括号了，看起来更简洁。</p><p>把上面 defaultExport.js 模块导出的作为例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> print <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defaultExport.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(print()); <span class="hljs-comment">// 欢迎关注公众号：前端桃园 </span><br></code></pre></td></tr></table></figure><p>那如果既有默认的又有非默认的怎么导入呢？看例子就明白了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// defaultImport1.js</span><br><br><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;桃翁&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;欢迎关注公众号：前端桃园&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> &#123; name, print <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span> &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// defaultImport2.js</span><br><br><span class="hljs-keyword">import</span> print, &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./defaultImport1.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(print()); <span class="hljs-comment">// 欢迎关注公众号：前端桃园</span><br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 桃翁</span><br></code></pre></td></tr></table></figure><p>混合导入需要把默认导入的名称放在最前面，然后用逗号和后面非默认导出的分割开。</p><blockquote><p>思考了很久是否应该加上进阶内容，本来是想写入门级系列的，但是想了想，还是都写进来吧，入门的看入门前面基础，深入理解的看进阶。</p></blockquote><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>进阶部分主要介绍 模块的几个特性</p><ul><li>静态执行</li><li>动态关联</li><li>模块不会重复执行</li></ul><h3 id="静态执行"><a href="#静态执行" class="headerlink" title="静态执行"></a>静态执行</h3><p>所谓静态执行其实就是在编译阶段就需要确定模块的依赖关系，那么就会出现 import 命令会优先于模块其他内容的执行，会提前到编译阶段执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// static1.js</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;佩奇&#x27;</span>);<br><br><span class="hljs-keyword">import</span> &#123; nouse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./static2.js&#x27;</span><br><br><span class="hljs-comment">// static2.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nouse</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是不需要的&#x27;</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;小猪&#x27;</span>);<br></code></pre></td></tr></table></figure><p>可以看到最后输出的应该是「小猪」先输出，而「佩奇」后输出，可以得出虽然 static2.js 在后面引入，但是会被提升到模块的最前面先执行。</p><p>这也是我前面所说的不受暂时性死区原因之一，在这里可以写一个例子试试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// static3.js</span><br><span class="hljs-built_in">console</span>.log(nouse());<br><br><span class="hljs-keyword">import</span> &#123; nouse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./static2.js&#x27;</span><br><br><span class="hljs-comment">// 结果：</span><br><span class="hljs-comment">// 小猪</span><br><span class="hljs-comment">// 我是不需要的</span><br></code></pre></td></tr></table></figure><p>经检验确实是可以在 import 之前使用导入的绑定。</p><p>静态执行还会导致一个问题，那就是不能动态导入模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">if</span> (flag) &#123;<br>    <span class="hljs-keyword">import</span> &#123; nouse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./static3.js&#x27;</span><br>&#125;<br><br><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">import</span> &#123; <span class="hljs-string">&#x27;no&#x27;</span> + <span class="hljs-string">&#x27;use&#x27;</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./static3.js&#x27;</span><br><br></code></pre></td></tr></table></figure><p>因为 import 是静态执行的，所以在静态(词法)分析阶段，是没法得到表达式或者变量的值的。</p><p>但是为了解决这个问题，因为了 import() 这个函数，这个算扩展内容吧，写太多了我怕没人看完了，后面会有扩展阅读链接。</p><h3 id="动态关联"><a href="#动态关联" class="headerlink" title="动态关联"></a>动态关联</h3><p>所谓的动态关联，其实就是一种绑定关系, 这是 ES6 非常重要的特性，一定仔细阅读。</p><p>在 ES6 的模块中，输出的不是对象的拷贝，不管是引用类型还是基本类型, 都是动态关联模块中的值，。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// dynamic1.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;桃翁&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">newName</span>) </span>&#123;<br>    name = newName;<br>&#125;<br><br><span class="hljs-comment">// dynamic2.js</span><br><span class="hljs-keyword">import</span> &#123; name, setName &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dynamic1.js&#x27;</span><br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 桃翁</span><br><br>setName(<span class="hljs-string">&#x27;不要脸&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 不要脸</span><br></code></pre></td></tr></table></figure><p>奇迹般的发现在 dynamic2.js 模块中可以修改 dynamic1.js 模块里面的值, 并且反应到 name 绑定上（这个是重点，这个反应到了消费者模块）, 所以我们把导入的变量叫做绑定。</p><p>在生产者模块导出的变量与消费者模块导入的变量会有一个绑定关系，无论前者或者后者发生改变，都会互相影响。</p><blockquote><p>注意区分在一个文件或模块中基本类型的赋值，两者是互不影响的。</p></blockquote><h3 id="模块不会重复执行"><a href="#模块不会重复执行" class="headerlink" title="模块不会重复执行"></a>模块不会重复执行</h3><p>这个特性比较好理解，就是如果从一个生产者模块中分别导入绑定，而不是一次性导入，生产者模块不会执行多次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// noRepeat1.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;桃翁&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> age = <span class="hljs-string">&#x27;22&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我正在执行。。。&#x27;</span>);<br><br><span class="hljs-comment">// noRepeat2.js</span><br><span class="hljs-keyword">import</span> &#123; name &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./noRepeat1.js&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; age &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./noRepeat1.js&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(name);<br><span class="hljs-built_in">console</span>.log(age);<br><br><span class="hljs-comment">// 结果</span><br><span class="hljs-comment">// 我正在执行。。。</span><br><span class="hljs-comment">// 桃翁</span><br><span class="hljs-comment">// 22</span><br></code></pre></td></tr></table></figure><p>虽然导入了两次，但是 noRepeat1.js 只有执行一次。若同一个应用（注意是同一个应用不是模块）中导入同一个模块，则那些模块都会使用一个模块实例，意思就是说是一个单例。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>码字不易，写技术文章是真的累，作者花的时间至少是读者读的时间的十倍。在此想到阮老师写了那么多文章，不知道是花了多少时间，竟然还有人这么恨他，攻击他的网站。</p><p>我在文章中给我公众号打了很多广告，在此抱个歉，刚运营的公众号，需要拉点粉丝，不喜欢的注重内容就好。</p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><a href="https://www.zcfy.cc/article/native-ecmascript-modules-dynamic-import-2572.html" title="原生ECMAScript模块： 动态 import()">原生ECMAScript模块： 动态 import()</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桃园周刊 2018-5-14</title>
    <link href="/index.php/archives/87/"/>
    <url>/index.php/archives/87/</url>
    
    <content type="html"><![CDATA[<h3 id="如何更好的编写-async-函数"><a href="#如何更好的编写-async-函数" class="headerlink" title="如何更好的编写 async 函数"></a><a href="https://segmentfault.com/a/1190000014836153?utm_source=index-hottest" title="何更好的编写async函数">如何更好的编写 async 函数</a></h3><p>虽然 async/await 方式来处理异步请求，已经是比较非常好的方式了，但是有时候新手会乱用导致性能堪忧，这篇文章作者总结了他在项目迁移中更好的编写 aysnc 函数的方法。</p><h3 id="实现双向绑定-Proxy-比-defineproperty-优劣如何"><a href="#实现双向绑定-Proxy-比-defineproperty-优劣如何" class="headerlink" title="实现双向绑定 Proxy 比 defineproperty 优劣如何?"></a><a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" title="实现双向绑定Proxy比defineproperty优劣如何?">实现双向绑定 Proxy 比 defineproperty 优劣如何?</a></h3><p>双向绑定其实已经是一个老掉牙的问题了,只要涉及到 MVVM 框架就不得不谈的知识点。</p><p>可以实现双向绑定的方法有很多, KnockoutJS 基于观察者模式的双向绑定, Ember 基于数据模型的双向绑定, Angular 基于脏检查的双向绑定,本篇文章我们重点讲面试中常见的基于数据劫持的双向绑定。</p><h3 id="深度剖析：如何实现一个-Virtual-DOM-算法"><a href="#深度剖析：如何实现一个-Virtual-DOM-算法" class="headerlink" title="深度剖析：如何实现一个 Virtual DOM 算法"></a><a href="https://github.com/livoras/blog/issues/13" title="深度剖析：如何实现一个 Virtual DOM 算法">深度剖析：如何实现一个 Virtual DOM 算法</a></h3><p>本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。</p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>三板斧使你走上人生巅峰</title>
    <link href="/index.php/archives/81/"/>
    <url>/index.php/archives/81/</url>
    
    <content type="html"><![CDATA[<p>在我目前的认知里，我觉得未来有三个技能是需要掌握的，分别是：写作、编程、理财。我相信如果这三个技能都掌握了，我相信你里财富自由之路已经不远了。</p><p>想要走上财富自由，主要看你的「睡后」收入，就是在你睡觉的时候还有的输入，比如你录视频卖、写书、做自媒体写文章、理财等等，程序员如果增加「睡后」输入，请看 <a href="https://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&mid=2650663649&idx=1&sn=04a2ad1e9bf8585de749f58f7b63eb39&chksm=87d137beb0a6bea82ce9776ae82e84be17e2e20e019c8a308618ebb42251f1743a519368249b&mpshare=1&scene=23&srcid=05094XfTsgXBbt7YUVqbtaBx#rd">Stromzhang 的 这篇文章</a> 。这些都会让你在你睡觉了之后还有收入，跟你上班出售自己的时间相比，你花在这些能增加「睡后」收入的时间可以重复卖这些时间。</p><p>比如一个作家花一年的时间写了一本书，可以畅销十年；那些做自媒体的写出一款爆文，到处转发，也可以流行好多天。</p><p>所以如何增加「睡后」收入，才是通往财富自由之路的关键。</p><h2 id="第一板斧：写作"><a href="#第一板斧：写作" class="headerlink" title="第一板斧：写作"></a>第一板斧：写作</h2><p>在那么多的只能加睡后收入的方法里面，为什么我选择了写作？</p><p>因为写作是大多数人都可以参与进来的，不需要有太多的专业性技能，而且操作方便，在任何地方都可以写，没有时间空间的限制。</p><p>李笑来在他的财富自由之路里面也说过，写作是通往财富自由的必备技能。</p><p>下面简单介绍几种写作的好处：</p><h3 id="1-表达能力"><a href="#1-表达能力" class="headerlink" title="1. 表达能力"></a>1. 表达能力</h3><p>写作可以锻炼你的表达能力，因为写作其实就是在把自己所想的用文字表达出来，如果你能通过文字清晰的表达出来，那么我相信通过语言表达出来也不成问题了。</p><p>一旦你的表达能力得以提升，那么在人际交往的时候可以清楚的表达自己的观点。与老板沟通的时候可以清楚的把自己所干的活表达出来，让老板知道你的工作量，你用你的时间和工作能力，减少了老板的时间，他才会感激你；与同事交流清楚表达自己的观点，可以让同事们觉得你是一个有条理，很理性的人，等等例子，一旦你表达能力提升了，你的人际关系不会差。</p><h3 id="2-记录世界记录你"><a href="#2-记录世界记录你" class="headerlink" title="2. 记录世界记录你"></a>2. 记录世界记录你</h3><p>「记录世界记录你」是快手的广告，在这里借用一下，很适合给写作打广告。</p><p>快手也是日活上亿的一款APP，快手用视频可以记下你生活的点点滴滴，并且与其他人分享。我们用写作可以记录下生活的点滴，可以记录你的日记，以后可以留给你老了之后回忆；可以记录你的随想，让你可能会忘记的东西持久化；可以记录下你学习的笔记或者举一反三的知识，来加深你对知识点的理解……</p><p>你可以用写作记录下整个你所出的世界，以及你整个人生所经历的事儿，所想的想法，所学到的知识。这不就是记录世界记录你吗？想想是不是一件很酷的事儿</p><p>别想了，开始写吧！</p><h3 id="3-钱，快到兜里来"><a href="#3-钱，快到兜里来" class="headerlink" title="3. 钱，快到兜里来"></a>3. 钱，快到兜里来</h3><p>对于赚钱我相信大家都特别感兴趣吧。</p><p>很多人也许误以为只有作家才能通过写作来赚钱吧！那么你就少知道了一个赚钱之道。</p><p>你可以通过运营公众号来赚钱，说说三种运营公众号赚钱的方式：</p><ol><li>流量主<br>当你的公众号达到 5000 关注人数的时候，就可以开通广告服务，广告大概一次点击 1 块钱，原创能达到 1.5 元</li><li>软文推文<br>当你的公众号有一定影响力之后，一般就会有一些培训机构来让你帮他写软文打广告。希望大家看到喜欢的公众号有这种广告，不要抵触，有收入才有动力输出。</li><li>营销<br>如果你有一些付费专栏，或者知识星球，或者付费的视频课之类的，也可以做营销。</li></ol><p>当然还有很多理由驱使我写作，我就列了几个我觉得对我影响比较大的方面，希望大家早早加入这个圈子，早点财富自由。</p><h2 id="第二板斧：编程"><a href="#第二板斧：编程" class="headerlink" title="第二板斧：编程"></a>第二板斧：编程</h2><p>作为一个程序员的我，肯定编程对于我来说至关重要，但是为什么鼓励全民学编程呢？</p><p>我鼓励大家学编程，但是没鼓励大家都去当程序员。外面都说程序员是『钱多人傻死得早』，可见程序员是多么辛苦的一门职业，其实无论哪门职业，只要你想赚更多的钱，就得花更多的时间。</p><p>但是我觉得每个人都应该学点编程，理由如下：</p><h3 id="1-学会一种思考方式"><a href="#1-学会一种思考方式" class="headerlink" title="1. 学会一种思考方式"></a>1. 学会一种思考方式</h3><p>编程可以帮我们完成工作，但没有明确的实用性，重要的是我们把它看做思考的镜子，学习如何思考，你思考的问题清晰与否，对错与否，把代码敲出来运行一下就知道了。</p><p>学习编程会叫你如何思考，就像学法律一样，学法律的人未必都成为律师，但法律教你一种思考方式。</p><h3 id="2-编程可以培养冷静和逻辑化思维"><a href="#2-编程可以培养冷静和逻辑化思维" class="headerlink" title="2. 编程可以培养冷静和逻辑化思维"></a>2. 编程可以培养冷静和逻辑化思维</h3><p>要知道程序行为的对错，都是计算机运行错误，不会被个人意志左右，这让你冷静下来思考你赋予给计算机的算法是哪里错了。</p><p>在软件的世界里，每个细节都是环环相扣，不可能出现没有原因的问题，没有无因之果，锻炼你的逻辑化思维。</p><h2 id="第三板斧：理财"><a href="#第三板斧：理财" class="headerlink" title="第三板斧：理财"></a>第三板斧：理财</h2><p>在文章的开头，已经提到了「睡后」收入，理财就是一种很好的方式来增加睡后收入。</p><p>因为整个社会是存在着通货膨胀的，也就是说如果你把现金放在家里，甚至是存在银行，你的钱是会贬值的。</p><p><img src="https://upload-images.jianshu.io/upload_images/2974893-b7e83b6a21b902d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2018年各大银行大额存单利率表"></p><p>据统计，每年的通货膨胀是 6%~12%，根据上表，5 年利率最高的定期存款也才 4%，所以说存银行是没办法跑赢通货膨胀的。</p><p>由此可以看到我们就算为了跑赢通货膨胀也要学理财，让钱生钱。</p><p>理财的种类有很多种：储蓄、炒金、基金、炒股、国债、债券、外汇、保险、P2P。</p><p>每种理财不是每个人都适合，一般风险高的收益高，风险低的收益低，怎么来取舍这就是我们需要学习的。</p><blockquote><p>提示：理财的前提是你本金越多，赚的才有可能更多，所以应该先努力赚钱，赚取更多的本金，然后一边学习理财。在我目前掌握的理财知识来看，指数基金是一种相对适合大多数人的一种理财方式。</p></blockquote><p>最后，如果想获取写作的资料（包括书籍、视频），可以关注公众号 前端桃园，回复「写作」免费领取，或者加微信 lijian1076629390 免费领取。</p>]]></content>
    
    
    <categories>
      
      <category>观点与感想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>桃园周刊 2018-5-5</title>
    <link href="/index.php/archives/74/"/>
    <url>/index.php/archives/74/</url>
    
    <content type="html"><![CDATA[<p>###<a href="https://zhuanlan.zhihu.com/p/35211052" title=" Mvvm 前端数据流框架精讲"> Mvvm 前端数据流框架精讲</a><br>带大家了解什么是 mvvm，mvvm 的原理，以及近几年产生了哪些演变。</p><p>同时借 mvvm 这个话题拓展到对各类前端数据流方案的思考，形成对前端数据流整体认知，帮助大家在团队中更好的做技术选型。</p><h3 id="译-RxJS-游戏之贪吃蛇"><a href="#译-RxJS-游戏之贪吃蛇" class="headerlink" title="译-RxJS 游戏之贪吃蛇"></a><a href="https://zhuanlan.zhihu.com/p/35457418" title="[译] RxJS 游戏之贪吃蛇">译-RxJS 游戏之贪吃蛇</a></h3><p>众所周知，Web 发展的很快。如今，响应式编程和 Angular 或 React 这样的框架一样，已经是 Web 开发领域中最热门的话题之一。响应式编程变得越来越流行，尤其是在当今的 JavaScript 世界。从命令式编程范式到响应式编程范式，社区已经发生了巨大的变化。然而，许多开发者还是十分纠结，常常因为响应式编程的复杂度(大量 API)、思维转换(从命令式到响应式)和众多概念而畏缩。</p><p>该应用使用 HTML5、JavaScript 和 RxJS 来将编程事件循环 (programmatic-event-loop) 的应用转变成响应事件驱动 (reactive-event-driven) 的应用。</p><h3 id="前端性能优化之浏览器渲染优化-——-打造60FPS页面"><a href="#前端性能优化之浏览器渲染优化-——-打造60FPS页面" class="headerlink" title="前端性能优化之浏览器渲染优化 —— 打造60FPS页面"></a><a href="https://github.com/fi3ework/Blog/issues/9">前端性能优化之浏览器渲染优化 —— 打造60FPS页面</a></h3><p>该文仅针对高性能渲染进行分析。详细的讲解了 CSS 优化 和 Javascript 的优化，一篇非常深入的文章</p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6之路之块级作用域</title>
    <link href="/index.php/archives/70/"/>
    <url>/index.php/archives/70/</url>
    
    <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域指变量所作用的范围，在 Javascript 中有两种作用域：</p><ul><li>全局作用域</li><li>函数作用域</li></ul><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>变量提升（Hoisting）被认为是， Javascript 中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。具体表现就是所有通过 var 声明的变量会提升到当前作用域的最前面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(temp); <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(temp);  <br>    <span class="hljs-keyword">var</span> temp;<br>&#125;<br><br>foo(); <span class="hljs-comment">// ReferenceError: temp is not defined</span><br>bar(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>可以看到用 var 声明了的并不会报错。因为其实函数 bar 等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> temp;<br>    <span class="hljs-built_in">console</span>.log(temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>大多数类 C 语言语法的语言都拥有块级作用域。在一个代码块（括在一对花括号中的一组语句）中定义的所有变量在代码块的外部是不可见的。定义在代码块中的变量在代码块被执行结束后会变释放掉。这是件好事。</p><p>糟糕的是，尽管 Javascript 的代码貌似支持块级作用域，但实际上 Javascript 并不支持（就是因为有变量提升）。这个混淆之处可能成为错误之源。</p><p>所以在 ES6 中规定了 let 和 const 来支持块级作用域。但是，是不是真的提升就不存在了呢，可以看下面暂时性死区这部分。</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>let 可以理解为『更完美的 var』，使用方法很简单；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>使用方法基本和 var 相同，而且声明的变量只在其块和子块中可用，这点也与 var 相同。 二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">var</span> temp = <span class="hljs-number">5</span>;<br>         <span class="hljs-built_in">console</span>.log(temp);<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">） &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">if</span>(<span class="hljs-literal">true</span>) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">let</span> temp = <span class="hljs-number">5</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-built_in">console</span>.log(temp);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">console</span>.log(temp);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">foo(); <span class="hljs-comment">// 5 和 5</span></span></span><br><span class="hljs-params"><span class="hljs-function">bar(); <span class="hljs-comment">// 5 和 &quot;ReferenceError: temp is not defined</span></span></span><br></code></pre></td></tr></table></figure><p>let 声明的变量的作用域只是外层块，而不是整个外层函数。</p><p>我们可以利用这个特性来替代立即执行函数（IIFE）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// IIFE</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> temp = xxx;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        other code</span><br><span class="hljs-comment">    */</span><br>&#125;())<br><br><span class="hljs-comment">// 块级</span><br>&#123;<br>    <span class="hljs-keyword">let</span> temp = xxx;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        other code</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>const 的用法跟 let 差不多，但是 const 一定要初始化, 不初始化是会报错的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> temp = <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 没有初始化报错</span><br><span class="hljs-keyword">const</span> t; <span class="hljs-comment">// SyntaxError: Missing initializer in const declaration</span><br></code></pre></td></tr></table></figure><p>const 是块级作用域，const 跟 let 的语义相似，就是用来声明常量的，一旦声明了就不能更改。值得注意的是 const 声明的变量记录的是指针，不可更改的是指针,如果 const 所声明的是对象，对象的内容还是可以修改的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 重新赋值声明导致报错</span><br><span class="hljs-keyword">const</span> PI = <span class="hljs-number">3.14</span>;<br>PI = <span class="hljs-number">3.1415926</span>; <span class="hljs-comment">// TypeError: Assignment to constant variable.</span><br><br><span class="hljs-comment">// 给对象增加属性不会导致 obj 的指针变化，所以不会报错</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span> &#125;;<br>obj.bar = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">console</span>.log(obj); <span class="hljs-comment">// &#123;foo: 2, bar: 3&#125;</span><br></code></pre></td></tr></table></figure><h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><p>使用 let 或 const 声明的变量，在声明没有到达之前，访问该变量都会导致报错，就连一直以为安全的 typeof 也不再安全。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// TDZ1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// TDZ 开始</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> temp);<br>    <span class="hljs-keyword">let</span> temp = <span class="hljs-number">5</span>; <span class="hljs-comment">// TDZ 结束</span><br>&#125;<br><br>foo(); <span class="hljs-comment">// ReferenceError: temp is not defined</span><br></code></pre></td></tr></table></figure><p>报的错是 ReferenceError，如果使用 var 声明的话，temp 输出应该是 undefined，从 let 声明的变量的块的第一行，到声明变量之间的这个区域被称作暂时性死区（TDZ）。凡是在这个区域使用这些变量都会报错。    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// TDZ2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> temp);<br>&#125;<br><br>bar(); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>看到上面两个例子仔细思考有没有觉得想到点什么？</p><p>在函数里没有用 let 声明 temp 的时候，temp 是 undefined，讲道理在 let 声明前也应该是 temp，然而 foo 函数却报了错，证明了就算是在未到达 let 声明的地方，但是在用 let 之前已经起到了作用。这是不是说明其实 let 也有提升，只是在 TDZ 使用的时候报错了，而不是 undefined。</p><p>事实上，当 JS 引擎检视下面的代码块有变量声明时，对于 var 声明的变量，会将声明提升到函数或全局作用域的顶部，而对 let 或 const 的时候会将声明放在暂时性死区内。任何在暂时性死区内访问变量的企图都会导致“运行时”错误（runtime error）。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。</p><h2 id="禁止重复声明"><a href="#禁止重复声明" class="headerlink" title="禁止重复声明"></a>禁止重复声明</h2><p>在同一个块内，let 和 const 不能声明相同的标识符。禁止的情况包括：</p><ul><li>let 或 const 和 let 或 const</li><li>var 和 let 或者 const</li><li>函数参数与 let 或 const</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// let 和 let</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// let 和 const</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// var 与 let</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 函数参数与 let</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params">foo</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上情况都是会报 SyntaxError。但是在嵌套的作用域内使用 let 声明同一变量是被允许的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br><br>&#123;<br>    <span class="hljs-comment">// 不会报错</span><br>    <span class="hljs-keyword">let</span> = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// other code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时因为是 let 和 const 是块级作用域，声明的变量在当前块使用完之后就会被释放，所以就算使用相同的标识符也不会覆盖外部作用域的变量, 而 var 是会覆盖外部作用域的变量的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bar = <span class="hljs-number">1</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> bar = <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(bar);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">zoo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bar = <span class="hljs-number">1</span>;<br>    &#123;<br>        <span class="hljs-keyword">var</span> bar = <span class="hljs-number">2</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">console</span>.log(bar);<br>&#125;<br><br>foo(); <span class="hljs-comment">// 1</span><br>zoo(); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在 ES6 的发展阶段，被广泛认可的变量声明方式是：默认情况下应当使用 let 而不是 var<br>。对于多数 JS 开发者来说， let 的行为方式正是 var 本应有的方式，因此直接用 let<br>替代 var 更符合逻辑。在这种情况下，你应当对需要受到保护的变量使用 const 。</p><p>在默认情况下使用 const ，而只在你知道变量值需要被更改的情况下才使用 let 。这在代码中能确保基本层次的不可变性，有助于防止某些类型的错误。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>两个思考题，我会把答案放在评论中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 思考题 1</span><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">let</span> foo;<br>    <span class="hljs-keyword">break</span>;<br>    <br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">let</span> foo; <span class="hljs-comment">// TypeError for redeclaration.</span><br>    <span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 思考题 2</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">let</span> foo = (foo + <span class="hljs-number">2</span>); <br>   &#125;<br>&#125;<br>bar();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你不知道的黑客</title>
    <link href="/index.php/archives/68/"/>
    <url>/index.php/archives/68/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我相信大家对于『黑客』这个词并不陌生，特别是对我们搞计算机的人来说，那是相当的熟悉。</p><p>在一般人的眼里『黑客』（hacker）就是入侵计算机的人，就是『计算机犯罪』的同义词。但是，它的原意并非如此。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>在 20 世纪 60 年代初，麻省理工学院有一个学生团体叫做『铁路模型技术俱乐部』，他们把难题的解决方法称为 hack。</p><p>这里，hack作为名词有两个意思，既可以指很巧妙或很便捷的解决方法，也可以指比较笨拙、不那么优雅的解决方法。两者都能称为hack，不同的是，前者是漂亮的解决方法（cool hack 或 neat hack），后者是丑陋的解决方法（ugly hack 或 quick hack）。hack 的字典解释是砍（木头），在这些学生看来，解决一个计算机难题就好像砍倒一棵大树。那么相应地，完成这种 hack 的过程就被称为 hacking，而从事 hacking 的人就是 hacker，也就是黑客。</p><p>所以在 20 世纪 60 年代，『黑客』这个词是一种能力的象征，而且自称黑客的人他们比如包含着高度的革新、独树一帜的风格、精湛的技艺，也就是说在其他人的眼中，他们就是大佬。</p><p>自由软件基金会创始人理查德·斯托尔曼认为黑客的行为必须同时满足，好玩、高智商、探索精神三个特点才是真正的黑客。这也是黑客所追求的三种价值，而不是实用性或金钱。</p><blockquote><p>从这个意思出发，我们有时也会用到这个，比如我平时在实现某一个功能的时候，用常规的方法解决不了（或者说当时想不到科学的解决方法），用了一半不是那么科学的方法(或者不知道为什么这种方法就可以解决这个问题)的时候，我们也许会说我们用了一种 hack 的方式来解决了这个问题，并且会在这个方法写上一个注释标识是 hack，因为有可能其他人不知道为什么要这么用。</p></blockquote><h2 id="黑客精神"><a href="#黑客精神" class="headerlink" title="黑客精神"></a>黑客精神</h2><p>在史蒂文·利维出版的黑客著作 —- 《黑客：计算机革命的英雄》中，将黑客的价值观总结为六条『黑客伦理』：</p><ol><li>使用计算机以及所有有助于了解这个世界本质的食物都不应该收到任何限制。任何事情都应该亲手尝试。</li><li>信息应该全部免费</li><li>不信任权威，提倡去中心化</li><li>判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准</li><li>你可以用计算机创造美和艺术</li><li>计算机使生活更美好</li></ol><p>根据这六条『黑客理论』，黑客价值的核心原则可以概括为：分享、开放、民主、计算机的自由使用、进步。</p><p>历史上一些最优秀的程序员都是『黑客』。包括 Unix 创始人丹尼斯·里奇和肯·汤普森，Linux 创始人莱纳斯·托瓦兹，『开源运动』创始人埃里克·雷蒙德，微软公司创始人比尔·盖茨等等。正式黑客把计算机推向了更高的高度。</p><h2 id="『黑客』被误解的原因"><a href="#『黑客』被误解的原因" class="headerlink" title="『黑客』被误解的原因"></a>『黑客』被误解的原因</h2><p>根据『黑客伦理』，黑客就是不服从管教，具有叛逆精神，根据史蒂文·利维描述的就是：“对于黑客来说，关着门就是一种挑衅，而锁着门就是一种侮辱。 ······ 黑客相信，只有有助于改进现状、探索未知，人们就应该被允许自由地使用各种工具和信息。当一个黑客需要一样东西来帮助自己创造、探索或者改正某种设备时，他不会自找麻烦，不会接受那些财产专有权的荒谬概念。”</p><p>他们侵入计算机系统的原因不是为了自己利益，而是为了自由，跟那些计算机罪犯是不同的。</p><p>然而，在 20 世纪 80年代初，一帮青少年黑客入侵了美国和加拿大的一些计算机系统，被《新闻周刊》封面报道的标题就是『小心：黑客在行动』，这件事被广泛报道，在报道时媒体就把黑客的行为注意在一个很窄的方面：入侵系统。同时，那些入侵计算机的程序员也自称『黑客』，从此黑客在大众心中就成了有害人群。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>真正的黑客致力于改变世界，让世界运转得更好。</p><p>我们把传统意义上的黑客称之为 hacker，而那些而已入侵计算机系统的人应该称为 cracker（入侵者）。</p><p>作为程序员的我们都应该以传统意义的黑客为目标努力，也许你就是下一个黑客，下一个改变世界的人。</p><p>整篇文章大部分内容来自于《黑客与画家》，可以推荐给大家都去看下这本书，感受一下那个时代正真的黑客精神。<br>**<br>最后，大家可以在评论里面留言，你心目中最伟大的黑客都有谁。**</p><blockquote><p>大家好，我是桃翁，我为自己代言！</p></blockquote><p>个人微信公众号<br><img src="https://user-gold-cdn.xitu.io/2018/3/20/1624401bdefb8018?w=430&h=430&f=jpeg&s=22318" alt="个人微信公众号"></p>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黑客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>备忘录</title>
    <link href="/index.php/archives/62/"/>
    <url>/index.php/archives/62/</url>
    
    <content type="html"><![CDATA[<ul><li>了解fetch 和 xmlrequesthttp 的区别</li><li>实现一个模板引擎</li><li>学习函数式编程<br><a href="https://github.com/getify/Functional-Light-JS">https://github.com/getify/Functional-Light-JS</a></li><li>JavaScript框架设计2<img src="http://www.taoweng.site/usr/uploads/2018/11/2165918455.jpg" alt="_WWZ2531.jpg"><br><img src="http://www.taoweng.site/usr/uploads/2018/11/2560550698.jpg" alt="_WWZ2530.jpg"><img src="http://www.taoweng.site/usr/uploads/2018/11/2165918455.jpg" alt="_WWZ2531.jpg"></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>像素相关概念：PPI、DPI、设备像素、独立像素</title>
    <link href="/index.php/archives/146/"/>
    <url>/index.php/archives/146/</url>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎访问我的<a href="http://www.taoweng.site/">个人站点</a> </p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我相信对于像素，英文「pixel」，缩写「px」，这个概念并不陌生吧，不管是设计师设计图片用的单位 px，还是前端工程师在 css 里面的单位 px等等，很多领域都会用到这个单位，但是当我问他们一些问题的时候，基本上都答得不好。</p><p>比如：</p><ul><li>iPhone 6 的分辨率是 750 x 1334 像素，然而我们我们在写 css 的时候是以 375 x 667 来调的；</li><li>为什么我们做的一个网页在 pc 端可以正常显示，在移动端也可以正常显示，但是有时候又不正常显示；</li><li>我们如果在 pc 端把浏览器的宽度调到只有 200px 宽，里面写一个 100px 宽的 div ，然后再调整浏览器的放大为 200%，然后这个 div 可以充满整个显示器。 </li></ul><p>如果都能答上来，已经很不错了哦！</p><h2 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h2><blockquote><p>定义：是指在由一个数字序列表示的图像中的一个最小单位，称为像素。 —- 百度百科</p></blockquote><p>注意: 我觉得这里最关键的是『单位』，像素是一个单位，而不是一个点，我认为理解为一个长度单位比较好理解，后面我会解释为什么我会觉得是一个长度单位比较好理解。</p><p>我在很多文章里看到的定义是，像素就是组成图像的一个一个的点，这会让人感觉像素是个面积单位，我觉得这样有点不妥，并不是不对，要根据上下文而定。</p><p>比如 设备像素比(device pixels ratio)，简称 DPR，DPR = 设备像素 / 设备独立像素。现在我们就拿 iPhone 6 来做例子，我们可以通过 window.devicePixelRatio 获取设备的 DPR 为 2，设备独立像素，在这里可以认为是 css 像素，整个 iPhone 6 的像素点就有 375 * 667 个。</p><p>然后根据上面的公式得出：<br>总设备像素 = 总 css 像素 * 2 = 375  x  667 x 2 。然而实际上总的设备像素是 750 x 1334 个像素点。<br>如果我们把像素理解为一个长度单位，那么这个 2 就是 水平的总设备像素 = 2 * 水平的 css 像素 = 2 x 375，垂直的总设备像素 = 2 x 667. 所以总的像素点的个数就等于 = 4 x 375 x 667 = 750 x 1334.<br><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275c239a9e1e3f?w=577&h=572&f=png&s=104249" alt="image.png"></p><p>前面这个例子有可能现在还看不懂，不明白设备像素、设备独立像素这些概念，后面介绍了再来理解可能容易点，现在就是想带着它是个长度单位来理解。其实 DPR = 设备像素 / 设备独立像 （是在同一个方向，一维的）</p><h2 id="设备像素（DP）"><a href="#设备像素（DP）" class="headerlink" title="设备像素（DP）"></a>设备像素（DP）</h2><blockquote><p>定义： 设备像素又称物理像素，其尺寸大小是不会变的，从显示屏从工厂出来的那刻起，物理像素点就不会变了。</p></blockquote><p>实例：<br>iPhone 6 的分辨率是750 x 1334 ，那么这个 750 就是代表 750 的物理像素，是从手机出厂的那刻起，就不会变了，750 表示的就是手机的宽是 750px。这个应该比较好理解。</p><h2 id="设备独立像素（DIP）"><a href="#设备独立像素（DIP）" class="headerlink" title="设备独立像素（DIP）"></a>设备独立像素（DIP）</h2><blockquote><p>定义：设备独立像素又称逻辑像素，其尺寸大小是相对的。是一种物理测量单位，基于计算机控制的坐标系统和抽象像素。</p></blockquote><p>其实这个也很好理解，逻辑像素嘛，不就是我们平时用的 CSS 像素么，在 Android 中交设备独立像素。所以 设备独立像素 = CSS 像素。</p><h2 id="设备像素比（DPR）"><a href="#设备像素比（DPR）" class="headerlink" title="设备像素比（DPR）"></a>设备像素比（DPR）</h2><blockquote><p>设备像素比 DPR(devicePixelRatio) 是默认缩放为100%的情况下，设备像素和CSS像素的比值。 DPR = 设备像素 / 设备独立像素（是在同一个方向，一维的）</p></blockquote><p>这个概念主要是为了移动设备提出来的，最开始没有 DPR 的概念。但是随着技术的发展，从 iPhone 4 开始，苹果公司将 iPhone 4 的分辨率提高了一倍，但是尺寸没有变化，这意味着大小相同的屏幕上，像素多了一倍(一个方向上，像素点其实是 4 倍)，但是屏幕的尺寸没有变化，因为以前设备像素与逻辑像素的比例一直是 1 ： 1，都没人去关心这个，而 iPhone 4 的 DPR 为 2 了，所以就有了 DPR 的概念。这也诞生了 retina视网膜屏幕，后面讲 PPI 的时候再具体说。</p><h2 id="DPI-和-PPI"><a href="#DPI-和-PPI" class="headerlink" title="DPI 和 PPI"></a>DPI 和 PPI</h2><p>前方高能，这两个概念比较容易搞混，新手常常难以区分，包括百度百科所给的概念都互相矛盾，属于难点。<br><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275c239a5da508?w=863&h=564&f=png&s=148049" alt="image.png"></p><p>在百度百科上，PPI 定义是每英寸（英寸是个长度单位）所包含的像素数目。而后面又说单位面积的像素数目跟多，图像越清晰。一会儿又说是单位长度，一会儿又说是单位面积。因为英寸是长度单位，就是用来描述线段的，那么所包含的像素数目，此时像素我所理解的是长度单位；而后者说单位面积像素数量，此时我只能理解成像素是一个面积单位。这会让没有真正理解像素或者 PPI 的人迷惑。</p><p>现在我还是拿 iPhone 6 的例子来说明到底 PPI 应该是个啥。</p><p>我们都知道 iPhone 6 的分辨率是 750 x 1344，对角线长度是 4.7 英寸，PPI 是 326（不知道这些的自己查），但是这个 326 是怎么来的呢？现在我们就来计算下</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275c239a9771d3?w=454&h=510&f=png&s=16599" alt="手机尺寸图"><br>~~<br>因为我们并不知道手机的长宽的尺寸，一般厂商只会给对角线的尺寸。<br>设：长尺寸为 x 英寸，宽的尺寸为 y 英寸，那么就可以得到手机面积 s为： s = x^2 + y^2  (1)，<br>根据勾股定理可以得到 （4.7 英寸）^2 =  x^2 + y^2   (2)<br>根据 （1）（2）可得  s = x^2 + y^2 =  （4.7 英寸）^2</p><p>现在我们把总面积算出来了，然后再来算总的像素个数。一般像素点是正方形，所以一个点为一个像素平方。所以有：</p><p>750 px * 1344 px = 750 x 1344 px^2（注意单位是像素平方）</p><p>此时就有 PPI = 750 x 1344 px^2 / （4.7 英寸）^2 = √ 750 x 1344 px / 4.7 英寸~~</p><blockquote><p>所以就有 PPI 等于每平方英寸的像素点个数（1 个像素点为 1 平方像素），单位是 px^2/ 英寸^2 ; 也等于每英寸多少像素。</p></blockquote><p>所以说其实百度百科那个解释说错也有错，说没错也没错，只是说比较容易让人误解。看到这里我相信应该大家都明白 PPI 道理是什么了吧。</p><p> DPI（Dots Per Inch）和 PPI（Pixels Per Inch）都描述了图像的分辨率（或清晰度），但它们不是同一件事。PPI 描述了一英寸数字屏幕上显示的正方形像素的数量（通常在 67-300 之间）。另一方面，DPI 是指打印文档中墨水物理点的数量的打印术语。它们俩其实是差不多的，只是在使用的范围不一样，因为「点」这个还是比较抽象的，当使用电脑屏幕的时候，就是像素点；而当你打印或者印刷东西的时候，就是喷墨点。或者你可以把我们刚推出来来的等式，如果是每平方英寸像素点个数就可以理解为 DPI，每英寸像素理解有 PPI。</p><p>PPI 越高，看起来越清晰。</p><h3 id="Retina-显示屏"><a href="#Retina-显示屏" class="headerlink" title="Retina 显示屏"></a>Retina 显示屏</h3><p>Retina 显示屏是苹果公司首先提出来的，具备足够高像素密度（指的是 PPI 大于 300 的）而使得人体肉眼无法分辨其中单独像素点的液晶屏。最初采用该种屏幕的产品是 iPhone 4，其屏幕分辨率为 640 x 960（每英寸像素数为 326 ppi）。这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275c239c036cb7" alt="图片来源于维基百科"></p><blockquote><p>注意：Retina 不是分辨率，也不是单独指PPI，而是指视觉效果。retin屏幕指在正常视线距离内，肉眼很难看到像素的的屏幕。脱离视线距离谈retina就是流氓，50寸的1080P电视，你50CM内看大果粒，50米外看就是retina屏幕。</p></blockquote><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>下一篇文章也是跟这相关的，谈 移动端的适配问题(ppi 适配、resolution 适配、 dpr 适配)，理解移动端的三种 viewport 。</p><blockquote><p>大家好，我是桃翁，我为自己代言！</p></blockquote><p>个人微信公众号，尽量坚持每周一篇干货<br><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275c239be26272?w=430&h=430&f=jpeg&s=22318" alt="个人微信公众号"></p><p>参考文章：<br><a href="https://99designs.com/blog/tips/ppi-vs-dpi-whats-the-difference/">PPI vs. DPI: what’s the difference?</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>像素</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何将多个 maven 项目统一管理</title>
    <link href="/index.php/archives/51/"/>
    <url>/index.php/archives/51/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在我们一个人采用微服务构架的时候，我们会创建很多个 maven 项目。然后如果从 IDE 里面导入项目就要导入很多次，为了方便统一管理，我们可以将多个 maven 放在一个 项目里统一管理，然后我们导入项目的时候就可以直接导入一个项目就 OK。</p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ul><li>在多个项目的父目录建立一个文件夹，创建一个 pox.xml 文件<br>代码规则</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lxr<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maiba_be<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-comment">&lt;!-- packaging 把 jar 改成 pox --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 这里面放每个微服务的 artifactId--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>goodsService<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 为了解决依赖版本问题 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Camden.SR3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><ul><li>每个微服务项目的 pox.xml 更改</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>goodsService<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 这里的 artifactId 更改为父 pox.xml 的 artifactId --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.lxr<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maiba_be<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 下面的依赖 根据需求 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim 入门指南</title>
    <link href="/index.php/archives/50/"/>
    <url>/index.php/archives/50/</url>
    
    <content type="html"><![CDATA[<blockquote><p>个人站点：<a href="http://www.taoweng.site/">桃园</a></p></blockquote><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><h3 id="0-1-简介"><a href="#0-1-简介" class="headerlink" title="0.1 简介"></a>0.1 简介</h3><p>vim 被誉为『编辑器之神』，与之同时代的 emacs 被誉为『神之编辑器』。可以看得出 vim 在编辑器的地位是很高的，得益于 vim 的指法，敲起代码来如行云流水。特别膜拜创始人创始出这么方便的敲代码的指法，这篇文章就是来带你入坑 vim 指法操作。</p><h3 id="0-2-前端的我为什么要学习-vim"><a href="#0-2-前端的我为什么要学习-vim" class="headerlink" title="0.2 前端的我为什么要学习 vim"></a>0.2 前端的我为什么要学习 vim</h3><p>在当今前端开发工具百花齐放的时代（VS Code、Sublime、Atom 以及 IDE Webstorm），我为什么还要介绍 20 多年前开发的一个老古董呢？在这里我想说的是出身虽然老，但是所带来的价值并没有减,一旦习惯了 vim 的指法之后，你会觉得不用 vim 操作写代码会觉得很不习惯，甚至不知道怎么操作。然而用在支持 vim 指法的编辑上写代码你会觉得如行云流水，如果再配个机械键盘，简直是享受，特别符合极客的风格。</p><p>一旦学会了 vim 的指法，会让你终身受益，至少在你敲代码的年代会收益，毫无夸张, 它会让你摆脱烦人的，在敲代码的时候频繁的移动鼠标，这也是 vim 的设计理念之一 – 脱离鼠标。</p><h3 id="0-3-文章适用读者"><a href="#0-3-文章适用读者" class="headerlink" title="0.3 文章适用读者"></a>0.3 文章适用读者</h3><p>本篇文章比较适合前端开发者，因为我也只是用 vim 在前端领域做过一些开发，其他领域我没有发言权。</p><h3 id="0-4-Q-amp-A"><a href="#0-4-Q-amp-A" class="headerlink" title="0.4 Q&amp;A"></a>0.4 Q&amp;A</h3><p>Q：你推荐 vim 是要我们完全放弃以前的编辑器而投入 vim 的怀抱吗？</p><p>A：当然不是。首先 vim 的学习成本还是很高的，因为他跟平时我们用的编辑器敲代码的方式根本不同，因为它是不用鼠标的，纯键盘操作。你想想如果你在你的 vs code 上不用鼠标操作，你上下左右全靠方向键，那敲代码的速度得有多慢。而且初学者想把 vim 打造成一个自己的 IDE 还是很有难度的。所以我这里推荐的是，不管是你的 vs code、sublime等，装一个 vim 插件。我在 vs code 上试过，很爽，只不过现在投身到 emacs 的怀抱了。</p><blockquote><p>虽然我用 emacs 了，我还是会装 vim 插件（Evil）。如果有兴趣，下次可以推荐一下 spacemacs 。</p></blockquote><p>开题说了这么多，就是想吸引一下大家，觉得 vim 的指法是值得去学习的，接下来进入正题。</p><h2 id="1-助记符"><a href="#1-助记符" class="headerlink" title="1 助记符"></a>1 助记符</h2><p>vim 上的所有定义的快捷键都是有一定的意义的，在这里我先把常用的一些列出来。</p><h3 id="1-1-正则表达式相关"><a href="#1-1-正则表达式相关" class="headerlink" title="1.1 正则表达式相关"></a>1.1 正则表达式相关</h3><ul><li>$ ： 移动光标到行尾</li><li>^ :  移动光标到当前行的第一个字母位置。</li></ul><h3 id="1-2-移动类（motion）"><a href="#1-2-移动类（motion）" class="headerlink" title="1.2 移动类（motion）"></a>1.2 移动类（motion）</h3><p>h（左）、l（右）、j（上）、k（下）、f（front）、b（back）、u（up）</p><h3 id="1-3-操作类（operator）"><a href="#1-3-操作类（operator）" class="headerlink" title="1.3 操作类（operator）"></a>1.3 操作类（operator）</h3><p>d（delete）、i（insert）、a（append）、c（change）、y（copy）、p（paste）</p><h3 id="1-4-一般的缩写"><a href="#1-4-一般的缩写" class="headerlink" title="1.4 一般的缩写"></a>1.4 一般的缩写</h3><p>w（word）、s（sentence）</p><h2 id="2-理解-vim-中三种常用模式"><a href="#2-理解-vim-中三种常用模式" class="headerlink" title="2 理解 vim 中三种常用模式"></a>2 理解 vim 中三种常用模式</h2><p>vim 里面有好几种模式，但是因为我这里介绍的是在目前的编辑器里面装 插件，所以像命令模式这种用来保存文件、退出文件的就不介绍了。</p><ol><li>Nomal mode（默认模式，因为使用该模式场景最多，所有定为默认模式）。</li><li>Insert mode （插入模式–少用，用了它 vim 就成 「哑巴」了）。</li><li>Visual mode（可视模式，取名叫光标模式或者选择模式可能还比较好理解）</li></ol><h3 id="2-1-三种模式之间的转换关系"><a href="#2-1-三种模式之间的转换关系" class="headerlink" title="2.1 三种模式之间的转换关系"></a>2.1 三种模式之间的转换关系</h3><p><img src="https://user-gold-cdn.xitu.io/2018/3/20/1624401bddd4add7?w=1068&h=1130&f=png&s=403058" alt="图片来源参考文章"></p><h2 id="3-教程篇"><a href="#3-教程篇" class="headerlink" title="3 教程篇"></a>3 教程篇</h2><p>当我们记住上面的助记符之后，我们就可以像写英文短语一样操作了。</p><blockquote><p>vim 快捷键语法：[operator][count][motion]，例如 删两个单词就是<br>d2w，operator 和 motion 我已经在前面给出来一些了。</p></blockquote><h3 id="3-1-移动光标"><a href="#3-1-移动光标" class="headerlink" title="3.1 移动光标"></a>3.1 移动光标</h3><h4 id="3-1-1-最基本的-h、j、k、l"><a href="#3-1-1-最基本的-h、j、k、l" class="headerlink" title="3.1.1 最基本的 h、j、k、l"></a>3.1.1 最基本的 h、j、k、l</h4><p>最基本的上下左右移动（跟键盘上下左右的键盘效果相同，但是往往方向键在键盘的右下方，离主键盘区较远，这个也相对比较有优势）：</p><ul><li>h：光标向左移动</li><li>j：光标向下移动</li><li>k：光标向上移动</li><li>l：光标向右移动</li></ul><p>移动属于 motion，所以在前面加上「count」就可以移动多行了，比如向上移动 10 行，就可以 10k。往往编辑器会有行号，定位需要做个加减法，如果采用的是相对行号，用这个就比较方便。不懂相对行号的同学看下图就懂了。<br><img src="https://user-gold-cdn.xitu.io/2018/3/20/1624401bdee388e5?w=846&h=616&f=png&s=60797" alt="相对行号"></p><h4 id="3-1-2-快速移动"><a href="#3-1-2-快速移动" class="headerlink" title="3.1.2 快速移动"></a>3.1.2 快速移动</h4><p>w：光标往前移动一个词<br>b：光标向后移动一个词<br>0：移动光标到当前行首<br>^：移动光标到当前行的第一个字母位置(注意与 0 的区别)<br>$：移动光标到行尾<br>fx：移动光标到当前行的下一个 x 处（x为任意字母）<br>tx：和上面一个命令类似，移动到 x 的左边一个位置<br>)：移动光标到下一个句子<br>( ：移动光标到上一个句子<br>{：移动光标到上一段<br>}：移动光标到下一段</p><h4 id="3-1-3-快速定位"><a href="#3-1-3-快速定位" class="headerlink" title="3.1.3 快速定位"></a>3.1.3 快速定位</h4><p>在刚才介绍了通过相对行号来进行移动到行的光标，还有采用绝对定位来移动的。那就是 gg。<br>语法： [num]gg</p><ul><li>2gg : 光标移动到第 2 行</li><li>gg： 光标移动到文件首部</li><li>G：移动到文件胃部</li><li>H：移动到屏幕上面</li><li>M：移动到屏幕中间</li><li>L：移动到屏幕下面</li></ul><p>书签功能：这个功能也是很方便，很少有编辑器有的功能，单独列出来讲，强烈推荐。</p><ul><li>m<x>：给当前行加入书签，x 为任意字母（m 是 mark ）</li><li>` <x>： 单引号加上刚才 m 之后的字母，就会调整到刚才标记的那一行</li></ul><h3 id="3-1-3-屏幕滚动"><a href="#3-1-3-屏幕滚动" class="headerlink" title="3.1.3 屏幕滚动"></a>3.1.3 屏幕滚动</h3><ul><li>Ctrl + b：向上移动一屏（Foward首字母小写）</li><li>Ctrl + f：向下移动一屏（Backward首字母小写）</li><li>Ctrl + d：向下滚动半屏内容（Down首字母小写）</li><li>Ctrl + u：向上滚动半屏内容（Up首字母小写）</li></ul><h3 id="3-2-剪切、复制、粘贴"><a href="#3-2-剪切、复制、粘贴" class="headerlink" title="3.2 剪切、复制、粘贴"></a>3.2 剪切、复制、粘贴</h3><ul><li>d[n]w：剪切后面 n 个单词的内容，dw 是剪切当前单词</li><li>[n]dd：剪切n行的内容, dd 为剪切当前行</li><li>D：剪切光标后到行尾的内容</li><li>yy/Y：复制当前行的内容</li><li>p：粘贴到光标后</li><li>P：粘贴到光标前</li></ul><p>在 normal 模式下是没有删除操作的，d 这种删除也是剪切。</p><blockquote><p>以上全是 normal 模式</p></blockquote><h3 id="3-3-编辑模式"><a href="#3-3-编辑模式" class="headerlink" title="3.3 编辑模式"></a>3.3 编辑模式</h3><p>在前面也说了，进入编辑模式也就变成了「哑巴」vim 了，就跟一般的编辑器没什么区别了。很多人就知道用 i 可以进入，还有很多命令可以让你聪明的进入。</p><ul><li>i：在光标处插入（insert首字母小写）</li><li>I：在行首插入（insert首字母大写）</li><li>a：在光标处后一个字符插入（append首字母小写）</li><li>A：在行尾插入（append首字母大写）</li><li>o：在上一行插入</li><li>O：在下一行插入</li><li>s：清除当前字符并进入插入模式</li><li>cc/S：清除当前行并进入插入模式</li><li>cw: 清除当前单词并进入插入模式<h3 id="3-4-可视模式"><a href="#3-4-可视模式" class="headerlink" title="3.4 可视模式"></a>3.4 可视模式</h3>要是前面都学会了，可视模式就比较简单了，而且你将会经常用到这个模式。我会把这个模式称做「选择模式」，接下来我们就来探索一下是如果选择的。</li></ul><p>其实也就两个关键的点：v（字符选择）、V（行选择）</p><h4 id="3-4-1-v（小写-v）"><a href="#3-4-1-v（小写-v）" class="headerlink" title="3.4.1 v（小写 v）"></a>3.4.1 v（小写 v）</h4><p>在 normal 模式下，按一下 v，然后可以按 l，重复按 l，你会发现右边的在一直被选中（高亮的部分）。同样的操作，按了 v，然后再练习一下按 h、j、k。</p><p>选中的目的是什么呢？就是为了进行一些编辑操作，比如删除 d (实质是剪切)、复制 y。</p><blockquote><p>小提示，常常选中之后用 c 也是比较好的选择哦，剪切并进入插入模式。</p></blockquote><h4 id="3-4-2-V（大写-V）"><a href="#3-4-2-V（大写-V）" class="headerlink" title="3.4.2 V（大写 V）"></a>3.4.2 V（大写 V）</h4><p>V 就是选中行，也很简单。按了 V 之后，然后按 j、k，就可以上下选择行了，然后一次性删除 d、复制 y，就比较方便。</p><h3 id="3-5-组合操作"><a href="#3-5-组合操作" class="headerlink" title="3.5 组合操作"></a>3.5 组合操作</h3><p>这个功能就比较强悍了，很适用，强烈推荐。<br>先来记公式：operator + i|a + scope</p><blockquote><p>operator 就是我们前面提到的插入（c）、剪切（d）、复制（y）以及选择（v），i 表示 scope 范围内，a 表示包含 scope 标签，scope 就是操作的范围了。</p></blockquote><p>实例：<br>以下如果将 i 换成 a，则会将符号也包含进去</p><ul><li>vib（选中小括号内的内容）</li><li>viB（选中大括号内的内容）</li><li>vi”（选中双引号内的内容）</li><li>vi’（选中单引号内的内容）</li><li>vi&lt;（选中尖括号内的内容）</li></ul><h3 id="3-6-撤回、查找、替换"><a href="#3-6-撤回、查找、替换" class="headerlink" title="3.6 撤回、查找、替换"></a>3.6 撤回、查找、替换</h3><ul><li>u： 撤回上次操作(效果跟 command + z 效果一样)</li><li>/|?xxx：表示在整篇文档中搜索匹配xxx的字符串, / 表示向下查找, ? 表示向上查找.其中xxx可以是正规表达式。查找到以后, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.</li><li>:%s/original/replacement：检索第一个 “original” 字符串并将其替换成 “replacement”</li><li>:%s/original/replacement/g： 检索并将所有的 “original” 替换为 “replacement”</li><li>:%s/original/replacement/gc：检索出所有的 “original” 字符串，但在替换成 “replacement” 前，先询问是否替换</li></ul><p>这些操作一般编辑器都自带有很好的快捷键，记不住也没啥。</p><h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><p>我写这篇文章的目的不是为了总结什么知识点（其实当你 vim 用熟了，这些命令完全形成肌肉记忆了，根本不用记下来），或者说想发篇文章之类的，仅仅是想给 vim 做一个宣传，让更多的人接触 vim，让更多的开发者在开发上效率更高。如果你觉得这篇文章对你有帮助，请转发给更多的人让他们都了解了解。</p><p>最后想提醒的就是，对于这些快捷键，死记是很难记完的，根据我总结的一些语义话的方式去记，有公式的记公式，可能要快一点，然后就是多实践，敲多了自己就记住了。我刚开始学的时候，还不知道有那些助记符，基本完全靠死记硬背，我就是用一张纸，然后把命令手写抄到纸上，放在我的电脑旁，忘了就马上拿来看看，别说，效果还挺好的。</p><p>祝你们好运！</p><blockquote><p>大家好，我是桃翁，我为自己代言！</p></blockquote><p>个人微信公众号<br><img src="https://user-gold-cdn.xitu.io/2018/3/20/1624401bdefb8018?w=430&h=430&f=jpeg&s=22318" alt="个人微信公众号"></p><p>参考文章：<br><a href="https://baike.baidu.com/item/Vim/60410">VIM 百度百科</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzI4MDEwNzAzNg==&mid=2649444567&idx=1&sn=98d69cb0005e80312b1f126afe790aed&chksm=f3a271a4c4d5f8b2fa1fb343e641292df4a5295d26f6c7ad1583bbf44ee4f352035586416ef8&mpshare=1&scene=23&srcid=0103o58Y5CLe1jrliq7AoD9s%23rd">如何用Vim提高开发效率</a></p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript数据结构之数组栈队列</title>
    <link href="/index.php/archives/42/"/>
    <url>/index.php/archives/42/</url>
    
    <content type="html"><![CDATA[<h2 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h2><p>数组是平时使用最常用的数据结构，在JavaScript中数组是动态的分配大小,在这里我不会介绍JavaScript里面数组的所有的方法，而是针对数据结构这个方向谈谈所用到的方法。</p><h3 id="1-1-创建和初始化数组"><a href="#1-1-创建和初始化数组" class="headerlink" title="1.1 创建和初始化数组"></a>1.1 创建和初始化数组</h3><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs smali">//创建空数组<br>var<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>Array();<br>//[]<br><br>//初始化数组<br>var<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>Array(1,2,3); <br>var<span class="hljs-built_in"> array </span>= Array.of(1,2,3);//ES6的方法<br>//[1,2,3]<br><br>//创建大小为5的数组<br>var<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>Array();//ES6的方法<br>//[undefined,undefined,undefined,undefined,undefined]<br><br>//给数组赋值<br>var<span class="hljs-built_in"> array </span>=<span class="hljs-built_in"> new </span>Array();<br>array[0] = 1 ;<br>array[1] = 2 ;<br>array[2] = 3 ;<br>//[1,2,3]<br></code></pre></td></tr></table></figure><h3 id="1-2-添加元素"><a href="#1-2-添加元素" class="headerlink" title="1.2 添加元素"></a>1.2 添加元素</h3><h4 id="1-2-1往数组后添加元素"><a href="#1-2-1往数组后添加元素" class="headerlink" title="1.2.1往数组后添加元素"></a>1.2.1往数组后添加元素</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">number</span>[<span class="hljs-built_in">number</span>.length] = <span class="hljs-number">4</span>;<br><span class="hljs-comment">//[1,2,3,4]</span><br><br><span class="hljs-comment">//或者</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">number</span>.push(<span class="hljs-number">4</span>);<br><span class="hljs-comment">//[1,2,3,4]</span><br></code></pre></td></tr></table></figure><h4 id="1-2-2往数组前面添加元素"><a href="#1-2-2往数组前面添加元素" class="headerlink" title="1.2.2往数组前面添加元素"></a>1.2.2往数组前面添加元素</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">number</span>.unshift(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//[0,1,2,3]</span><br><span class="hljs-built_in">number</span>.unshift(-<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>);<br><span class="hljs-comment">//[-2,-1,0,1,2,3]</span><br><br></code></pre></td></tr></table></figure><h4 id="1-2-3往数组的任意位置插入元素"><a href="#1-2-3往数组的任意位置插入元素" class="headerlink" title="1.2.3往数组的任意位置插入元素"></a>1.2.3往数组的任意位置插入元素</h4><p>运用splice方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//在索引1后面添加2，3，4</span><br><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-built_in">number</span>.splice(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>);<br><span class="hljs-comment">//[1,2,3,4,5,6]</span><br></code></pre></td></tr></table></figure><h3 id="1-3-删除元素"><a href="#1-3-删除元素" class="headerlink" title="1.3 删除元素"></a>1.3 删除元素</h3><h4 id="1-3-1-删除第一位"><a href="#1-3-1-删除第一位" class="headerlink" title="1.3.1 删除第一位"></a>1.3.1 删除第一位</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><span class="hljs-built_in">number</span>.shift();<br><span class="hljs-comment">//[2,3]</span><br></code></pre></td></tr></table></figure><h4 id="1-3-2-删除任意位置"><a href="#1-3-2-删除任意位置" class="headerlink" title="1.3.2 删除任意位置"></a>1.3.2 删除任意位置</h4><p>使用splice方法删除数组任意位置的元素</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">var numebr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-regexp">//</span>如果想删除元素<span class="hljs-number">3</span><br>number.splice(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><span class="hljs-regexp">//</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><br><span class="hljs-regexp">//</span>如果想删除元素<span class="hljs-number">4</span>，<span class="hljs-number">5</span><br>number.splice(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h3 id="1-4-排序"><a href="#1-4-排序" class="headerlink" title="1.4 排序"></a>1.4 排序</h3><h4 id="1-4-1-反序"><a href="#1-4-1-反序" class="headerlink" title="1.4.1 反序"></a>1.4.1 反序</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-built_in">number</span>.reverse();<br><span class="hljs-comment">//[1,2,3]</span><br><br></code></pre></td></tr></table></figure><h4 id="1-4-2-自然排序"><a href="#1-4-2-自然排序" class="headerlink" title="1.4.2 自然排序"></a>1.4.2 自然排序</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> numebr = [2,3,4,1,3,7];<br>number.<span class="hljs-keyword">sort</span>();<br><span class="hljs-comment">//[1,2,3,3,4,7]</span><br></code></pre></td></tr></table></figure><h4 id="1-4-3-自定义排序"><a href="#1-4-3-自定义排序" class="headerlink" title="1.4.3 自定义排序"></a>1.4.3 自定义排序</h4><p>这个自定义排序跟java里面实现comparator接口一个意思。用处可大了。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>];<br><span class="hljs-built_in">number</span>.sort();<br><span class="hljs-comment">//[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p>仿佛看起有点不对啊，我们应该想要的是<br>[1,2,3,4,5,6,7,8,9,10,11,12,13],这个时候我们就用自定义排序来解决这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compare</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(a &lt; b)&#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a &gt; b)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-built_in">number</span>.sort(compare);<br><span class="hljs-comment">//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]</span><br></code></pre></td></tr></table></figure><p>这还只是最简单的，也可以对任何对象类型进行数组排序。例如，对象Person有名字和年龄属性，我们希望根据年龄排序</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var friends = [<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;李晨&#x27;</span>,age:<span class="hljs-number">40</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;范冰冰&#x27;</span>,age:<span class="hljs-number">35</span>&#125;];<br><br><span class="hljs-keyword">function</span> comparePerson(a,b)&#123;<br>    <span class="hljs-keyword">if</span>(a.age &lt; b.age)&#123;<br>        <span class="hljs-keyword">return</span>  -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(a.age &gt; b.age)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>friends<span class="hljs-built_in">.sort</span>(comparePerson);<br>//[<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;范冰冰&#x27;</span>,age:<span class="hljs-number">35</span>&#125;,<span class="hljs-built_in">&#123;name</span>:<span class="hljs-string">&#x27;李晨&#x27;</span>,age:<span class="hljs-number">40</span>&#125;]<br></code></pre></td></tr></table></figure><h3 id="1-5-搜索"><a href="#1-5-搜索" class="headerlink" title="1.5 搜索"></a>1.5 搜索</h3><p>搜索有两个方法：indexOf方法返回与参数匹配的第一个元素的索引，lastIndexOf返回与参数匹配的最后一个元素的索引。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> <span class="hljs-built_in">number</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">56</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">4</span>];<br><span class="hljs-built_in">number</span>.indexOf(<span class="hljs-number">3</span>);<span class="hljs-comment">//1</span><br><span class="hljs-built_in">number</span>.lastIndexOf(<span class="hljs-number">3</span>)<span class="hljs-comment">//3</span><br></code></pre></td></tr></table></figure><h2 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h2><p>栈是一种遵循后进先出(LIFO)原则的有序集合。新添加的或待删除的元素都保存在栈的末尾，称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，旧元素都接近栈底。在JavaScript中变量保存和函数调用都是用栈存储的。</p><p>首先创建一个类来表示一个栈，需要一种数据结构来保存栈里的元素。这里我们就选择刚学的数组：var items = [];<br>接下来，为我们的栈声明一些方法：</p><ul><li>push(elements(s)):添加一个（或几个）新元素到栈顶</li><li>pop():移除栈顶的元素，同时返回被移除的元素</li><li>peek():获取栈顶的元素，不对栈做出任何修改</li><li>isEmpty():如果栈里没有任何元素就返回true,否则返回false；</li><li>clear():清空栈</li><li>size():返回栈元素的个数</li></ul><p>如果上一节数组认真看了，我相信用JavaScript实现一个栈是非常简单的。在这里就直接来代码了，不用一个方法一个方法去解释了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> items = [];<br>    <br>    <span class="hljs-built_in">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>)</span>&#123;<br>        items.push(element);<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.pop();<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items[items.length-<span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.length === <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.length;<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        items = [];<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.print = <span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(items.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-队列"><a href="#3-队列" class="headerlink" title="3. 队列"></a>3. 队列</h2><p>队列是遵循先来先服务(FIFO)原则的一组有序的项。队列在尾部添加新元素，并从顶部移除元素。最新添加的元素排在队列的末尾。</p><p>在现实生活中常见的例子就是排队。<br>在计算机科学中，一个常见的例子就是打印队列，先点击打印的文档会被先打印。</p><h3 id="3-1-创建队列"><a href="#3-1-创建队列" class="headerlink" title="3.1 创建队列"></a>3.1 创建队列</h3><p>同样先创建一个类来表示一个队列。需要用到的数据结构同样是数组var items = [];<br>声明可用的方法：</p><ul><li>enqueue(element(s)):向队尾添加一个（或多个）新的项</li><li>dequeue():移除队列的第一（即排在队列最前面的）项，并返回被移除的元素。</li><li>front():返回队列中第一个元素</li><li>isEmpty():如果队列中不包含元素返回true，否则返回false</li><li>size():返回队列包含元素的个数<h4 id="完整的Queue类"><a href="#完整的Queue类" class="headerlink" title="完整的Queue类"></a>完整的Queue类</h4></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> items = [];<br>    <br>    <span class="hljs-built_in">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>)</span>&#123;<br>        items.push(element);<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.shift();<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.front = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items[<span class="hljs-number">0</span>];<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.length === <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        items = [];<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.size = <span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> items.length;<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(items.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-优先队列"><a href="#3-2-优先队列" class="headerlink" title="3.2 优先队列"></a>3.2 优先队列</h3><p>在优先队列中，元素被赋予优先级。当访问元素的时，具有最高优先级的元素先删除。优先队列具有最高进先出的行为特征。例如：医院的急救室为病人赋予优先级（这个优先级可以指病情严重的成程度），具有最高优先级的病人最先得到治疗。</p><p>实现一个优先队列有两种选项：</p><ol><li>设置优先级，然后在正确的位置添加元素；</li><li>用入列操作添加元素，然后按照优先级移除它们。</li></ol><p>我们这里采用第一种。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PriorityQueue</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> items = [];<br>    <br>    funciton <span class="hljs-function"><span class="hljs-title">QueueElement</span>(<span class="hljs-params">element,priority</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.element = element;<br>        <span class="hljs-built_in">this</span>.priority = priority;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comparePriority</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(a.priority &gt; b.priority)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>         <span class="hljs-keyword">if</span>(a.priority &lt; b.priority)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-built_in">this</span>.enqueue = <span class="hljs-function"><span class="hljs-title">funciton</span>(<span class="hljs-params">element,priority</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> queueElement = <span class="hljs-keyword">new</span> QueueElement(element,priority);<br>        <br>        items.push(queueElement);<br>        <br>        items.sort(comparePriority);<br>    &#125;<br>    <br>    <span class="hljs-comment">//其它方法和默认的Queue实现相同</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然，这个enqueue的实现方法很多种，我这效率不是最高的，但是容易理解。将插入的元素根据优先级排个序，那么先出去的就是优先级最高的了。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6之路--Symbol</title>
    <link href="/index.php/archives/41/"/>
    <url>/index.php/archives/41/</url>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎访问我的<a href="http://www.taoweng.site/">个人站点</a></p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用，表示独一无二的值。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。它是JavaScript语言的第七种数据类型，前6种分别是：Undefined、Null、Boolean、String、Number、Object。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>Symbol([description])</p></blockquote><h4 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters</h4><p>description : 可选的字符串。可用于调试但不访问符号本身的符号的说明。如果不加参数，在控制台打印的都是Symbol，不利于区分。</p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><pre><code>var s1 = Symbol(&#39;symbol1&#39;);s1 //Symbol(symbol1); </code></pre><p>因为Symbol函数返回的值都是独一无二的，所以Symbol函数返回的值都是不相等的。</p><pre><code>//无参数var s1 = Symbol();var s2 = Symbol();s1 === s2 // false//有参数 var s1 = Symbol(&#39;symbol&#39;); var s2 = Symbol(&#39;symbol&#39;);  s1 === s2 //false</code></pre><h2 id="2-作为属性名的Symbol"><a href="#2-作为属性名的Symbol" class="headerlink" title="2. 作为属性名的Symbol"></a>2. 作为属性名的Symbol</h2><p>由于每一个Symbol值都是不相等的，那么作为属性标识符是一种非常好的选择。</p><h3 id="定义方式："><a href="#定义方式：" class="headerlink" title="定义方式："></a>定义方式：</h3><pre><code>let symbolProp = Symbol();var obj = &#123;&#125;;obj[symbolProp] = &#39;hello Symbol&#39;;//或者var obj = &#123;    [symbolProp] : &#39;hello Symbol&#39;;&#125;//或者var obj = &#123;&#125;;Object.defineProperty(obj,symbolProp,&#123;value : &#39;hello Symbol&#39;&#125;);</code></pre><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>定义属性的时候只能将Symbol值放在方括号里面，否则属性的键名会当做字符串而不是Symbol值。同理，在访问Symbol属性的时候也不能通过点运算符去访问，点运算符后面总是字符串，不会读取Symbol值作为标识符所指代的值.</p><h3 id="Symbol类型定义常量"><a href="#Symbol类型定义常量" class="headerlink" title="Symbol类型定义常量"></a>Symbol类型定义常量</h3><p>常量的使用Symbol值最大的好处就是其他任何值都不可能有相同的值，用来设计switch语句是一种很好的方式。例如：消除魔术字符串（这里留给读者思考，如果有什么疑问，可以给我留言）</p><h2 id="3-Symbol-for-Symbol-keyFor"><a href="#3-Symbol-for-Symbol-keyFor" class="headerlink" title="3. Symbol.for(),Symbol.keyFor()"></a>3. Symbol.for(),Symbol.keyFor()</h2><h3 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h3><p>对于Symbol.for方法需要记住两点:</p><ol><li>Symbol.for()所返回的Symbol值的作用域是==整个代码库==（包括不同的iframe或者service worker），是一个全局的变量,第一次产生的时候就会登记下来。</li><li>调用Symbol.for()的时候，如果在全局环境中检索给定的key是否存在，如果不存在才会新建一个值,而Symbol()不会，Symbol()每次返回的都是不同的值。</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><br><span class="hljs-built_in">Symbol</span>.<span class="hljs-keyword">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-built_in">Symbol</span>.<span class="hljs-keyword">for</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); //<span class="hljs-literal">true</span><br> <br><span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>); //<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h3><p>Symbol.keyFor方法返回一个已登记的Symbol类型的值的key。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var s1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span><span class="hljs-keyword">for</span>(&#x27;foo&#x27;);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>key<span class="hljs-constructor">For(<span class="hljs-params">s1</span>)</span> <span class="hljs-comment">//&quot;foo&quot;</span><br><br>var s2 = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">foo</span>&#x27;)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Symbol</span>.</span></span>key<span class="hljs-constructor">For(<span class="hljs-params">s2</span>)</span>;<span class="hljs-comment">//undefiend</span><br></code></pre></td></tr></table></figure><p>上面的代码中，变量s2属于未登记的Symbol值，所以返回undefined</p><h2 id="4-属性名的遍历"><a href="#4-属性名的遍历" class="headerlink" title="4. 属性名的遍历"></a>4. 属性名的遍历</h2><p>Symbol作为属性名，虽然不是私有属性，但是在for…in,for…of循环中，Object.keys(),Object.getOwnPropertyNames()都不会获取到。通常通过两种方法达到Symbol属性的遍历。</p><ol><li>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有Symbol值的属性。</li><li>Reflect.ownKeys()可以返回所有类型的键名，包括包括常规的键名和Symbol键名.</li></ol><p>下面给出一个例子来解释上面所有的。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var obj = &#123;&#125;;<br>var a = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">a</span>&#x27;)</span>;<br>var b = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">b</span>&#x27;)</span>;<br><br>obj<span class="hljs-literal">[<span class="hljs-identifier">a</span>]</span> = &#x27;hello&#x27;;<br>obj<span class="hljs-literal">[<span class="hljs-identifier">b</span>]</span> = &#x27;world&#x27;;<br><br><span class="hljs-comment">//获取不到</span><br><span class="hljs-keyword">for</span>(var i <span class="hljs-keyword">in</span> obj)&#123;<br>    console.log(i); <span class="hljs-comment">//无输出</span><br>&#125;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyNames(<span class="hljs-params">obj</span>)</span>;<span class="hljs-comment">//[]</span><br><br><br><span class="hljs-comment">//可以获取</span><br>var objectSymbols = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertySymbols(<span class="hljs-params">obj</span>)</span>;<br>objectSymbols<span class="hljs-comment">// [Symbol(a), Symbol(b)]</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Reflect</span>.</span></span>own<span class="hljs-constructor">Keys(<span class="hljs-params">obj</span>)</span>;<span class="hljs-comment">//[Symbol(a), Symbol(b)]</span><br></code></pre></td></tr></table></figure><p>以Symbol值作为名称的属性不会被常规方法遍历所得到。我们可以利用这个特性，为对象定义一些非私有但又希望只用于内部的方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var size = <span class="hljs-constructor">Symbol(&#x27;<span class="hljs-params">size</span>&#x27;)</span>;<br><br><span class="hljs-keyword">class</span> Collection &#123;<br>    constructor<span class="hljs-literal">()</span>&#123;<br>        this<span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span> = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    add(item)&#123;<br>        this<span class="hljs-literal">[<span class="hljs-identifier">this</span>[<span class="hljs-identifier">size</span>]</span>] = item;<br>        this<span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>++;<br>    &#125;<br>    <br>    static size<span class="hljs-constructor">Of(<span class="hljs-params">instance</span>)</span>&#123;<br>        return instance<span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>;<br>    &#125;<br>&#125;<br><br>var x = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Collection()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>size<span class="hljs-constructor">Of(<span class="hljs-params">x</span>)</span>; <span class="hljs-comment">//0</span><br><br>x.add(&#x27;foo&#x27;);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>size<span class="hljs-constructor">Of(<span class="hljs-params">x</span>)</span>; <span class="hljs-comment">//1</span><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>keys(x)<span class="hljs-comment">//[&#x27;0&#x27;]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertyNames(<span class="hljs-params">x</span>)</span> <span class="hljs-comment">//[&#x27;0&#x27;]</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">OwnPropertySymbols(<span class="hljs-params">x</span>)</span> <span class="hljs-comment">//[Symbol(size)]</span><br><br></code></pre></td></tr></table></figure><p>上面的代码中，对象x的size属性是一个Symbol值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。如果对ES6定义类方面还不清楚的，可以先不看这段，或者自己查查资料，后面的文章我也会分享出来，总的来说现在JavaScript的新标准越来越像Java了，比如新增的const、let块级作用域，class定义类等等。</p><h3 id="内置的Symbol值"><a href="#内置的Symbol值" class="headerlink" title="内置的Symbol值"></a>内置的Symbol值</h3><p>除了自己定义的Symbol值外，JavaScript有一些内置的Symbol表示的内部语言行为不在ECMAScript 5及以前暴露给开发者。这些Symbol可以被访问被下列属性:</p><h4 id="1-Symbol-iterator"><a href="#1-Symbol-iterator" class="headerlink" title="1. Symbol.iterator"></a>1. Symbol.iterator</h4><p>返回对象的默认迭代器的方法。被for…of使用</p><h4 id="2-Symbol-math"><a href="#2-Symbol-math" class="headerlink" title="2. Symbol.math"></a>2. Symbol.math</h4><p>与字符串匹配的方法，也用于判断对象是否可以用作正则表达式.被 String.prototype.match()使用。</p><h4 id="3-Symbol-replace"><a href="#3-Symbol-replace" class="headerlink" title="3. Symbol.replace"></a>3. Symbol.replace</h4><p>一种方法取代匹配字符串的子串。被String.prototype.replace()使用。</p><h4 id="4-Symbol-search"><a href="#4-Symbol-search" class="headerlink" title="4. Symbol.search"></a>4. Symbol.search</h4><p>返回与正则表达式匹配的字符串内返回索引的方法。被String.prototype.search()使用。</p><h4 id="5-Symbol-split"><a href="#5-Symbol-split" class="headerlink" title="5. Symbol.split"></a>5. Symbol.split</h4><p>在与正则表达式匹配的索引处拆分字符串的方法。被String.prototype.split()使用.</p><h4 id="6-Symbol-hasInstance"><a href="#6-Symbol-hasInstance" class="headerlink" title="6. Symbol.hasInstance"></a>6. Symbol.hasInstance</h4><p>确定构造函数对象是否将对象作为实例识别的方法。被instanceof使用</p><h4 id="7-Symbol-isConcatSpreadable"><a href="#7-Symbol-isConcatSpreadable" class="headerlink" title="7. Symbol.isConcatSpreadable"></a>7. Symbol.isConcatSpreadable</h4><p>一个布尔值，指示对象是否应该被扁平化为数组元素。被Array.prototype.concat()使用.</p><h4 id="8-Symbol-unscopables"><a href="#8-Symbol-unscopables" class="headerlink" title="8. Symbol.unscopables"></a>8. Symbol.unscopables</h4><p>从关联对象的环境绑定中排除其自身和继承的属性名称的对象值。被with使用</p><h4 id="9-Symbol-species"><a href="#9-Symbol-species" class="headerlink" title="9. Symbol.species"></a>9. Symbol.species</h4><p>用于创建派生对象的构造函数。</p><h4 id="10-Symbol-toPrimitive"><a href="#10-Symbol-toPrimitive" class="headerlink" title="10. Symbol.toPrimitive"></a>10. Symbol.toPrimitive</h4><p>将对象转换为原始值的方法。</p><h4 id="11-Symbol-toStringTag"><a href="#11-Symbol-toStringTag" class="headerlink" title="11. Symbol.toStringTag"></a>11. Symbol.toStringTag</h4><p>用于对象的默认描述的字符串值。被Object.prototype.toString()使用.</p><blockquote><p>我这里没给出具体的例子，针对这11个属性。忘读者自己主动去把这几个属性搞懂，对理解有些方法是非常有用的。</p></blockquote><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://es6.ruanyifeng.com/#docs/symbol">阮一峰的ES6标准入门</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol|-JavaScript|MDN</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在spacemacs中支持editorconfig</title>
    <link href="/index.php/archives/37/"/>
    <url>/index.php/archives/37/</url>
    
    <content type="html"><![CDATA[<p>editorconfig 是在项目存储库中有一个名为 .editorconfig 的文件，这样参与的开发者的编辑和 ide 可以自动调整。</p><p>有一个 emacs/spacemacs 模式，可以很容易地在以下步骤中进行集成：</p><ol><li>将 editorconfig 添加到 dotspacemacs-additional-packages。</li><li>将（editorconfig-mode 1）添加到 dotspacemacs/user-config。</li></ol><p>更多的细节记录在插件库的 <a href="https://github.com/editorconfig/editorconfig-emacs#readme">README</a>。</p><h2 id="源码片段"><a href="#源码片段" class="headerlink" title="源码片段"></a>源码片段</h2><p>第一步：添加插件到 additional packages:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">dotspacemacs-additional-packages<br>&#x27;(<br>  editorconfig<br>  )<br></code></pre></td></tr></table></figure><p>第二步：从你的 user-config 激活插件：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lisp">(<span class="hljs-name">defun</span> dotspacemacs/user-config ()<br>  (<span class="hljs-name">editorconfig-mode</span> <span class="hljs-number">1</span>)<br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>emacs</tag>
      
      <tag>spacemacs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>草稿</title>
    <link href="/index.php/archives/29/"/>
    <url>/index.php/archives/29/</url>
    
    <content type="html"><![CDATA[<p><img src="http://www.taoweng.site/usr/uploads/2018/01/1397637167.jpg" alt="QQ20180106-0.JPG"><br><img src="http://www.taoweng.site/usr/uploads/2020/03/1113982871.png" alt="公众号二维码修订版.png"><br><img src="http://www.taoweng.site/usr/uploads/2020/03/3784295006.png" alt="公众号二维码.png"><br><img src="http://www.taoweng.site/usr/uploads/2019/11/692186374.png" alt="头像"><br><img src="http://www.taoweng.site/usr/uploads/2020/03/1970600719.jpg" alt="IMG_3410.JPG"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ES6之对象的扩展</title>
    <link href="/index.php/archives/24/"/>
    <url>/index.php/archives/24/</url>
    
    <content type="html"><![CDATA[<h3 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1. 属性的简洁表示法"></a>1. 属性的简洁表示法</h3><p>ES6允许直接写入变量和函数作为对象的属性和方法。意思就是说允许在对象中只写属性名，不用写属性值。这时，属性值等于属性名称所代表的变量。下面分别举一个例子来说明：</p><span id="more"></span><h4 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPoint</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> &#123;x,y&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fucntion <span class="hljs-function"><span class="hljs-title">getPoint</span>(<span class="hljs-params">x,y</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span> ;<br>    <span class="hljs-keyword">var</span> y = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>:x,<span class="hljs-attr">y</span>:y&#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">getPoint();<span class="hljs-comment">//&#123;x:1,y:10&#125;</span><br></code></pre></td></tr></table></figure><h4 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;simply function&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">fun</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;simply function&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.fun();<span class="hljs-comment">//simply function</span><br></code></pre></td></tr></table></figure><h3 id="2-属性名表达式"><a href="#2-属性名表达式" class="headerlink" title="2. 属性名表达式"></a>2. 属性名表达式</h3><p>ES6里允许定义对象的时候用表达式作为对象的属性名或者方法名，即把表达式放在方括号里。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> propKey = <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    <br><span class="hljs-keyword">let</span> obj = &#123;<br>    [propKey] : <span class="hljs-literal">true</span>,<br>    [<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-string">&#x27;bc&#x27;</span>] : <span class="hljs-number">123</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><pre><code>obj.foo; //trueobj.abc ; //123</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    [<span class="hljs-string">&#x27;h&#x27;</span>+<span class="hljs-string">&#x27;ello&#x27;</span>]()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><pre><code>obj.hello();//hello world</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>属性名表达式与简介表达式不能同时使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//错误的</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> baz = &#123; [foo] &#125;;<br><br><span class="hljs-comment">//正确</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-keyword">var</span> baz = &#123; [foo] : <span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><p>这个比较容易理解，直接阐述文字。</p><p>函数的name属性返回函数名。对象方法也是函数，因此也有函数名。</p><ul><li>一般情况方法的name属性返回函数名</li><li>如果是取值函数会在函数名前加”get”</li><li>如果是存值函数会在函数名前加”set”</li><li>如果bind方法创建的函数会在函数名前加”bound”</li><li>如果是Function构造函数创建的函数，会在函数名前加”anonymous”</li><li>如果对象的方法是一个Symbol值，那么name属性返回的是这个Symbol值的描述</li><li></li></ul><h3 id="Oject-is"><a href="#Oject-is" class="headerlink" title="Oject.is()"></a>Oject.is()</h3><p>Object.is()用来比较两个值yan’ge严格相等。与严格比价运算符（===）的行为基本一致。不同之处只有两个：一是 +0 不等于 -0 ，二是NaN等于自身</p><pre><code>+0 === -0 //trueNaN === NaN //falseObject.is(+0,-0);//falseObject.is(NaN,NaN);//true</code></pre><h3 id="Oject-assign"><a href="#Oject-assign" class="headerlink" title="Oject.assign()"></a>Oject.assign()</h3><p>Object.assign()方法是用于将源对象的可枚举属性复制到目标对象。它至少需要两个参数，第一是目标对象，后面的全是源对象。</p><h4 id="注意：-1"><a href="#注意：-1" class="headerlink" title="注意："></a>注意：</h4><ul><li>每个参数必须是对象，否则会报TypeError错误。</li><li>如果目标对象与源对象有同名属性，或多个源对象有同名的属性，则后面的属性会覆盖前面的属性</li><li>Object.assign只复制自身属性，不可枚举的属性和继承属性不会被复制</li><li>属性名为Symbol值的属性，也会被Object。assign复制。</li></ul><p>demo：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> target = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">b</span>:<span class="hljs-number">2</span>&#125;;<br><br><span class="hljs-keyword">var</span> source1 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">c</span>:<span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">var</span> source2 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">d</span>:<span class="hljs-number">6</span>&#125;;<br><br><span class="hljs-built_in">Object</span>.assign(target,source1,source2);<br>target<span class="hljs-comment">//&#123;a:3,b:2,c:5,d:6&#125;</span><br></code></pre></td></tr></table></figure><ul><li>Object.assign可用于处理数组，但是会将其视为对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.assign([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]);<br><span class="hljs-comment">//[4,5,3]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="其他用处"><a href="#其他用处" class="headerlink" title="其他用处"></a>其他用处</h4><ul><li>为对象添加属性</li><li>为对象添加方法</li><li>克隆对象</li><li>合并多个对象</li><li>为属性指定默认值</li></ul><p>具体例子参考阮一峰的<a href="http://es6.ruanyifeng.com/#docs/object">ES6标准入门</a></p><h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><p>对象的没个属性都有一个描述对象(Descriptor)，可通过Object.getOwnPropertyDescriptor(object,prop),object表示对象，prop表示对象的里的一个属性，用的时候需要加上引号。描述对象里面有个enumerable（可枚举性）属性，来描述该属性是否可枚举。</p><p>ES5中会忽略enumerable为false的属性</p><ul><li>for…in循环：只遍历对象自身和继承的可枚举属性（包含继承）</li><li>Object.keys():返回对象自身的所有可枚举属性的键名</li><li>Json.stringify():只串行化对象自身的可枚举属性</li></ul><p>ES6新增的操作</p><ul><li>Object.assign(): 只复制对象自身的可枚举属性</li><li>Reflect.enumerate(): 返回所有for…in循环会遍历的属性（包含继承）</li></ul><h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6中一共有6中方法可以遍历对象的属性。</p><ul><li>for…in循环遍历对象自身和继承的可枚举的属性（不含Symbol属性）</li><li>Object.keys(obj)返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性，但是包含不可枚举属性）</li><li>Object.getOwnPropertySymbols(obj)返回一个数组，包含对象自身的所有Symbol属性。</li><li>Relect.ownKeys(obj)返回一个数组，包含对象的所有属性，包含属性名是Symbol或者字符串，也不管是否可枚举。</li><li>Reflect.enumerate(obj)返回一个Iterator对象，遍历对象自身的和继承的所有可枚举属性（不含Symbol）,与for…in相同</li></ul><p>以上6种方法遍历对象的属性遵守同样的属性遍历次序规则</p><ul><li><p>首先遍历所有属性名为数值的属性，按照数字排序</p></li><li><p>其次遍历所有属性名为字符串的属性，按照生成时间排序</p></li><li><p>最后遍历所有属性名为Symbol值的属性，按照生成时间排序 </p><p>  Reflect.ownkeys({[Symbol()]:0,b:0,10:0,2:0,a:0})<br>  //[‘2’,’10’,’b’,’a’,Symbol()]</p></li></ul><h3 id="proto-属性，Object-setPrototypeOf-Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-Object-getPrototypeOf" class="headerlink" title="proto 属性，Object.setPrototypeOf(),Object.getPrototypeOf()"></a><strong>proto</strong> 属性，Object.setPrototypeOf(),Object.getPrototypeOf()</h3><h4 id="proto-属性"><a href="#proto-属性" class="headerlink" title="proto 属性"></a><strong>proto</strong> 属性</h4><p>（前后应该有两个下划线，这里没显示出来）。用来读取或者设置当前对象的prototype对象。但是一般不直接对这个属性进行操作，而是通过Object.setProtortypeOf()（写操作）、Object.getPrototypeOf()（读操作）或者Object.create()（生成操作）代替。</p><h4 id="Object-setProtortypeOf"><a href="#Object-setProtortypeOf" class="headerlink" title="Object.setProtortypeOf()"></a>Object.setProtortypeOf()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> proto = &#123;&#125;;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">x</span> : <span class="hljs-number">10</span>&#125;;<br><span class="hljs-built_in">Object</span>.setProtortypeOf(obj,proto);<br><br>proto.y = <span class="hljs-number">20</span>;<br>proto.z = <span class="hljs-number">40</span>;<br><br>obj.x <span class="hljs-comment">//10</span><br>obj.y <span class="hljs-comment">//20</span><br>obj.z <span class="hljs-comment">//40</span><br></code></pre></td></tr></table></figure><h4 id="Object-getProtortypeOf"><a href="#Object-getProtortypeOf" class="headerlink" title="Object.getProtortypeOf()"></a>Object.getProtortypeOf()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br><br><span class="hljs-keyword">var</span> rec = <span class="hljs-keyword">new</span> Rectangle();<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(rec) === Rectangele.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><p>ES7中提案，将rest参数/扩展运算符（…）引入对象。</p><h4 id="Rest参数"><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h4><p>Rest参数用于从一个对象取值，相当于将所有可遍历尚未被读取的属性，分配到制定的对象上。所有的键及其值都会复制到新对象上。需要注意的是rest参数的复制是浅复制，并且也不会复制继承自原型对象的属性。</p><p>简单的demo<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;x,y,...k&#125; = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">y</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">z</span>:<span class="hljs-number">4</span>,<span class="hljs-attr">a</span>:<span class="hljs-number">5</span>&#125;;<br>x <span class="hljs-comment">//2</span><br>y <span class="hljs-comment">//3</span><br>k <span class="hljs-comment">//&#123;z:4,a:5&#125;</span><br></code></pre></td></tr></table></figure></p><h4 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>扩展运算符用于取出参数对象的所有可遍历属性，复制到当前对象中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> z = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span> ,<span class="hljs-attr">b</span>:<span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">let</span> n = &#123;...z&#125;;<br>n <span class="hljs-comment">//&#123;a:3,b:4&#125;</span><br></code></pre></td></tr></table></figure><p>扩展运算符还可以合并两个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123; <span class="hljs-attr">c</span>:<span class="hljs-number">5</span>,<span class="hljs-attr">d</span>:<span class="hljs-number">6</span> &#125;;<br><span class="hljs-keyword">let</span> b = &#123; <span class="hljs-attr">e</span>:<span class="hljs-number">7</span>,<span class="hljs-attr">f</span>:<span class="hljs-number">8</span> &#125;;<br><span class="hljs-keyword">let</span> ab = &#123;...a,...b&#125;;<br>ab <span class="hljs-comment">//&#123;c:5,d:6,e:7,f:7&#125;</span><br></code></pre></td></tr></table></figure><p>扩展运算符还可以自定义属性，会在新对象中覆盖掉原有参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = &#123;<span class="hljs-attr">x</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> aWithOverides = &#123;...a,<span class="hljs-attr">x</span>:<span class="hljs-number">3</span>,<span class="hljs-attr">y</span>:<span class="hljs-number">4</span>&#125;;<br>aWithOverides <span class="hljs-comment">//&#123;x:3,y:4&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES6</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个例子来谈react的两大优势</title>
    <link href="/index.php/archives/20/"/>
    <url>/index.php/archives/20/</url>
    
    <content type="html"><![CDATA[<p>今天我想谈的react的优势有两点：</p><ol><li>声明式写法更符合人性</li><li>减少dom操作使性能得以提升</li></ol><p>现在我们就写一个最简单的计数例子来比较传统的jquery和react。</p><span id="more"></span><p>jquery方式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn_click&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;button&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./jquery-3.2.1.js&quot;</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      $(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        $(<span class="hljs-string">&quot;#btn_click&quot;</span>).click(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-comment">/* Act on the event */</span></span><br><span class="javascript">          <span class="hljs-keyword">var</span> clickCounter = $(<span class="hljs-string">&quot;#value&quot;</span>);</span><br><span class="javascript">          <span class="hljs-keyword">var</span> count = <span class="hljs-built_in">parseInt</span>(clickCounter.text(),<span class="hljs-number">10</span>);</span><br><span class="javascript">          clickCounter.text(count+<span class="hljs-number">1</span>);</span><br><span class="javascript">        &#125;);</span><br><span class="javascript">      &#125;)</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="react方式"><a href="#react方式" class="headerlink" title="react方式"></a>react方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span>&#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.onClickButton = <span class="hljs-built_in">this</span>.onClickButton.bind(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">count</span> : <span class="hljs-number">0</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">onClickButton</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      <span class="hljs-attr">count</span> : <span class="hljs-built_in">this</span>.state.count + <span class="hljs-number">1</span><br>    &#125;);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn_click&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.onClickButton&#125;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span>&#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看懂了上面上个例子，现在我们就开始比较了。</p><h3 id="jQuery的工作方式"><a href="#jQuery的工作方式" class="headerlink" title="jQuery的工作方式"></a>jQuery的工作方式</h3><p>命令式编程，所谓命令式就是你需要告诉计算机一步一步怎么做。</p><h4 id="在jquery的解决方案中，"><a href="#在jquery的解决方案中，" class="headerlink" title="在jquery的解决方案中，"></a>在jquery的解决方案中，</h4><ol><li>找到clickCount的按钮，挂上一个匿名事件处理函数，在事件处理函数汇总，</li><li>选中那个需要修改的DOM元素，</li><li>读取其中文本值，</li><li>加已修改</li><li>然后修改这个DOM元素。</li></ol><p>其中只有第4步是用js处理，不用跟DOM打交道的，做前端的都知道在性能优化中，重要的一条就是减少DOM操作。</p><p>选中一些DOM元素，然后对这些元素做一些操作，这种模式是一种很容易理解的模式。以至于John Resig一创造出jQuery就被世间普遍认可。但是，对于庞大的项目，代码结构复杂，难以维护，性能也跟不上。</p><h3 id="React的工作方式"><a href="#React的工作方式" class="headerlink" title="React的工作方式"></a>React的工作方式</h3><p>声明式编程，你只需要告诉计算机你需要什么就行了，不需要关心怎么去做的。</p><p>现在用统一通俗的例子来比较jQuery的命令和React的声明式。React是一个聪明的建筑工人，而jQuery是一个比较傻的建筑工人，开发者你是一个建筑工程师，如果是jQuery这个建筑工人为你工作，你不得不事无巨细地告诉jQuery“如何去做”，要告诉他这面墙要拆掉重建，那面墙上要新开一个窗户，反之，如果是React这个建筑工人为你工作，你所要做的就是告诉这个工人“我想要什么样子”，只需要把图纸递给React这个工人，他就会替你搞定一切，当然他不会把整个建筑拆掉重建，而是很聪明地把这次的图纸和上次的图纸做一个对比，发现不同之处，然后只去做适当的修改就完成任务了。</p><h4 id="react的解决方式"><a href="#react的解决方式" class="headerlink" title="react的解决方式"></a>react的解决方式</h4><p>在第一构建出DOM树之后，还会构建出一个Virtual DOM，是对DOM树的抽象，是一个JavaScript对象，重新渲染的时候，会对比这一次产生的Virtual DOM和上一次渲染的Virtual DOM，对比发现差异之后，只需修改真正的DOM树时就只需要触及差别中的部分就行，对于diff算法比较复杂，后面我也会整理出来和大家分享。</p><p>以刚才的例子。其实改变的只有span里的内容数字，所以react对于其他的DOM元素都不需要触及，于是执行类似下面的语句，就完成了任务。</p><p>document.getElementByID(“value”).innerHTML = “1”;<br>相对于jQuery还要去访问，操作那么多次DOM，性能是大大的提高了。</p><blockquote><p>纯属个人愚见，有什么错误的还希望大佬指出来。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础知识</title>
    <link href="/index.php/archives/19/"/>
    <url>/index.php/archives/19/</url>
    
    <content type="html"><![CDATA[<p>数据库基础知识</p><span id="more"></span><ol><li><p>需要掌握一定的商业知识</p></li><li><p>建模：程序流程图、数据流程图DFD、时序图、状态图</p></li><li><p>软件开发阶段：系统规划、系统分析、系统实施、运行维护、测试阶段</p></li><li><p>E-R图:由实体、属性、关系组成</p></li><li><p>实体间的关系：基数、元、关联</p></li><li><p>使用关联的情况：</p><ul><li>两个实体间的关系存在自身的属性</li><li>实体间存在多元关系</li></ul></li><li><p>表的主键：不能重复而且不能为空。例如 学号、身份证号，如果不能从已有字段中提取出一个字段、可以自己设置一个没有实际意义的字段</p></li><li><p>外键 的使用</p></li><li><p>约束条件：主键（primary key）约束、外键（foreign key）约束、唯一性（unique）约束、<br>默认值（default）约束、非空（not NULL）约束、检查（check）约束</p></li><li><p>创建表时，先创建父表，再创建字表； 字表的外键字段与父表的主键字段的                 数据类型相同</p></li><li><p>选数据类型：数据类型越简单越好 尽量用整数代替字符串  所以主键用整数插询效    率较高 存储IP地址时也可以用整数</p></li><li><p>为了支持中文简体 字符集设置为gbk 为了支持外键约束 存储引擎设置为InnoDB</p></li><li><p>复制表格：</p><ul><li>create table 新表名 like 原表；</li><li>create table 新表名 select *from 原表</li></ul></li><li><p>修改字段信息：</p><ul><li>删除字段：alter table 表名 drop 字段名</li><li>添加字段名：alter table 表名 新字段名数据类型【约束条件】【first|after 就字段名】</li><li>修改字段名：alter table 表名 change 旧字段名 新字段名 数据 类型</li><li>修改数据类型：alter table 表名 modify 字段名 数据类型</li></ul></li><li><p>插入新纪录：insert into 表名【（字段列表）】 values（值列表）注意：向char  varchar  text 以及日期型的字段插入数据时，字段值要用单引号括起来</p></li><li><p>批量插入多条记录：insert into 表名【（字段列表）】 values（值列表1）、（值列表2）、…..；</p></li><li><p>修改表记录：update 表名；Set 字段名 1=值1，字段名2=值2……【where条件表达式】（while子句指定了表中的哪些记录需要修改，若省略了where子句，则表示              修改表中的所有记录）</p></li><li><p>删除表：delete from 表名【where 条件表达式】Select语句：</p></li><li><p>Select字段列表（“，分隔” 用“as”关键字分隔）From 数据源【where 条件表达式】【group by 分组字段【having 条件表达式】】【order by 排序字段【asc|desc】】（数据源可以是表也可以是视图）（asc升序 desc降序）（多表查询的时候，同名字字段前必须加表名前缀，中间用“.”）</p></li><li><p>过滤记录：</p><ul><li>distinct 过滤结果集中的重复记录；Distinct 字段名 from 数据源</li><li>limit查询某几行记录。Select 字段列表 From 数据源  Limit 【start，】length；（limit接受一个或两个整数参数，start表示从第几行记录开始检索，length表示检索多少行记录。表中第一行记录的start值为0（不是1））</li></ul></li><li><p>使用from子句指定数据源（两种）</p><ul><li>其中一种语法：From 表名1 【连接类型】 join 表名2 on 表1和表2之间的连接条件<ul><li>内连接</li><li>外链接（左连接，右连接）。例如：左连接 意味着查询结果集中包含表1的全部记录 ，然后表1按指定的连接条件与表2进行连接。若表2中没有满足连接条件的记录，则结果集中表2相应的字段填入NULL</li></ul></li></ul></li><li><p>多表连接：from 表1 【连接类型】 join 表1 on 表1和表2之间的连接条件，【连接类型】 join 表3 on 表2和表3的连接条件</p></li><li><p>NULL与NULL不能使用等比较运算符比较。可以用 is not 或者not</p></li><li><p>逻辑运算符：“and” “or” “！” “【not】..and..” “【not】in 数学集合”</p></li><li><p>字符串表达式 【not】 like 模式 （可以理解为一个正则表达式）字符集设置为gbk_chinese_ci或者 gbk2312_chinese_ci 模式匹配时英文字母不区分大小写，而设置为gbk_bin或者gbk_2312_bin时要区分（模式是一个字符串，包括普通字符和通配符）通配符：“%” 匹配零个或多个字符组成的任意字符串_(下划线) 匹配任意一个字符</p></li><li><p>order by 字段名1 【asc|desc】 【…，字段名n 【asc|desc】</p></li><li><p>Group by子句对记录分组统计Group by 字段列表【         - having 条件表达式】 【with rollup】单独用group by意义不大 一般与聚合函数集合 （看例子）</p></li><li><p>group by子句与having</p><ul><li>Having用于设置分组或聚合函数的过滤筛选条件</li><li>在select语句 先对where进行筛选  接着group by子句对where的输出分组，最后having子句从分组的结果中再进行筛选。语法：Select 字段列表   From 数据源   Where 条件表达式  Group by 分组字段 having 条件表达式</li></ul></li><li><p>group by子句与group_concat（）</p><ul><li>group_concat（）与concat（）有一个功能相同，另外还可以用逗号将字段的值连接起来（看例子）</li></ul></li><li><p>group by</p><ul><li>With rollup函数  在分组最后添加一条汇总信息</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数式编程笔记</title>
    <link href="/index.php/archives/18/"/>
    <url>/index.php/archives/18/</url>
    
    <content type="html"><![CDATA[<p>过去编程方式主要是以命令式编程为主，什么意思呢？简单说电脑的思维方式和我们人类的思考方式是不一样的。我们人类的大脑擅长的是分析问题，提出一个解决问题的方案，电脑则是生硬的执行指令，命令式编程就像是给电脑下达命令，让电脑去执行一样，现在主要的编程语言（比如：Java，C，C++等）都是由命令式编程构建起来的。<br>​ 而函数式编程就不一样了，这是模仿我们人类的思维方式发明出来的。例如：操作某个数组的每一个元素然后返回一个新数组，如果是计算机的思考方式，会这样想：创建一个新数组=&gt;遍历旧数组=&gt;给新数组赋值。如果是人类的思考方式，会这样想：创建一个数组方法，作用在旧数组上，返回新数组。这样此方法可以被重复利用。而这就是函数式编程了。</p><span id="more"></span><ol><li>高阶函数可以接受函数作为参数，或者返回一个函数结果或者两者同时。</li><li>闭包就是一个函数的作用域，这个作用域通过指向改函数的引用保持存活</li><li>科里化（参数缓存，延迟执行）</li><li>组合函数 马上计算</li><li>声明式与命令式</li><li>reduce</li></ol><p>自己实现数组中的map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.map=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr,func</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> results = [];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,len = a.length;i&lt;leni++)&#123;<br>        <span class="hljs-keyword">if</span>(i <span class="hljs-keyword">in</span> a)&#123;<br>            results[i] = f.call(<span class="hljs-literal">null</span>,a[i],i,a);<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己实现数组中的reduce</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.reduce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,f,initial</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>,len = a.length,accumulator;<br>    <br>    <span class="hljs-comment">//以特定的初始值开始，否则第一个取值自a</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">arguments</span>.length &gt; <span class="hljs-number">2</span>)&#123;<br>        accumulator = initial;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//找到数组中第一个已定义的索引</span><br>        <span class="hljs-keyword">if</span>(len = <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();<br>        <span class="hljs-keyword">while</span>(i&lt;len)&#123;<br>            <span class="hljs-keyword">if</span>(i <span class="hljs-keyword">in</span> a)&#123;<br>                accumulator = a[i++];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i == len) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(i &lt; len)&#123;<br>        <span class="hljs-keyword">if</span>(i <span class="hljs-keyword">in</span> a)&#123;<br>            accumulator = f.call(<span class="hljs-literal">undefined</span>,accumulator,a[i],i,a);<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> accumulator;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>函数式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cenos下安装node.js和mongodb</title>
    <link href="/index.php/archives/17/"/>
    <url>/index.php/archives/17/</url>
    
    <content type="html"><![CDATA[<h2 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h2><p>下载源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src/<br>wget https://nodejs.org/dist/v8.6.0/node-v8.6.0.tar.gz<br></code></pre></td></tr></table></figure><span id="more"></span><p>解压源码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxvf node-v8.6.0.tar.gz<br></code></pre></td></tr></table></figure><p>编译安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> node-v8.6.0<br>./configure --prefix=/usr/<span class="hljs-built_in">local</span>/node/8.6.0<br>make<br>make install<br></code></pre></td></tr></table></figure><p>遇到错误</p><p>make[1]: g++：命令未找到<br>make[1]: *** [/usr/local/src/node-v8.6.0/out/Release/obj.target/icuucx/deps/icu-small/source/common/utrie2_builder.o] 错误 127<br>rm 8f388ce961ec8cc8196f595f16fdcc7694a5fb89.intermediate<br>make[1]: Leaving directory `/usr/local/src/node-v8.6.0/out’<br>make: *** [node] 错误 2<br>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install gcc-c++<br></code></pre></td></tr></table></figure><p>配置NODE_HOME，进入profile编辑环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/profile<br></code></pre></td></tr></table></figure><p>设置nodejs环境变量，在 export PATH USER LOGNAME MAIL HOSTNAME HISTSIZE HISTCONTROL 一行的上面添加如下内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#set for nodejs</span><br><span class="hljs-built_in">export</span> NODE_HOME=/usr/<span class="hljs-built_in">local</span>/node/0.10.24<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$NODE_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>:wq保存并退出，编译/etc/profile 使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>验证是否安装配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><p>npm模块安装路径<br>/usr/local/node/8.6.0/lib/node_modules/</p><h2 id="mongodb安装"><a href="#mongodb安装" class="headerlink" title="mongodb安装"></a>mongodb安装</h2><p>下载安装包<br>下载地址：<a href="https://www.mongodb.com/download-center#community">https://www.mongodb.com/download-center#community</a><br>下载的时候自己根据自己的系统和版本下载<br>解压tgz安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf mongodb-linux-x86_64-3.4.9.tgz<br></code></pre></td></tr></table></figure><p>将解压包拷贝到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mv mongodb-linux-x86_64-3.4.9.tgz/ /usr/<span class="hljs-built_in">local</span>/mongodb<br></code></pre></td></tr></table></figure><p>MongoDB 的可执行文件位于 bin 目录下，所以可以将其添加到 PATH 路径中</p><p>用vi打开profile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/profile<br></code></pre></td></tr></table></figure><p>classpath添加路径<br>export CLASSPATH=/usr/local/mongodb/bin;</p><p>使profile生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>关于linux详细更多的添加环境变量只是<a href="http://www.jianshu.com/p/ac2bc0ad3d74">点我</a></p>]]></content>
    
    
    <categories>
      
      <category>基础教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node</tag>
      
      <tag>centos</tag>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2017文章汇总</title>
    <link href="/index.php/archives/16/"/>
    <url>/index.php/archives/16/</url>
    
    <content type="html"><![CDATA[<p>2017年微信收藏的文章</p><span id="more"></span><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585582&amp;idx=1&amp;sn=6985baf8b8dac1a2956197da42e3ff1d&source=41#wechat_redirect">优化浏览器关键渲染路径 - 开启性能优化之旅</a></p><p><a href="https://mp.weixin.qq.com/s/LgwTCzBgYWBe2JFXg8YMtQ">高性能滚动 scroll 及页面渲染优化</a></p><p><a href="https://mp.weixin.qq.com/s/qy-jGSwHfDYErmStMeeqrg">理论 | HTML写法对gzip压缩率的影响</a></p><p><a href="https://mp.weixin.qq.com/s/mXNDAMPtvqcmJVmeymUadQ">唯快不破：Web 应用的 13 个优化步骤</a></p><p><a href="https://mp.weixin.qq.com/s/CVf6W9E-kc5e3Xxt11F6hA">进阶|鹅厂大神用Node直出实现网页”瞬开”…</a></p><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p><a href="https://mp.weixin.qq.com/s/t7jci1w-qL3AIEGgXXOceQ">网页性能管理详解</a></p><p><a href="https://mp.weixin.qq.com/s/ZAa1LNPwb7S8i7XYRPB1jw">写给后端程序员的HTTP缓存原理介绍</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585932&idx=1&sn=dce6450188649f8d160dac07aa3de683&chksm=8891ab68bfe6227ec4d4af4226802e5d132c32058509b9131914cb4563f32ea49406b1f7a9c2&mpshare=1&scene=23&srcid=1218780D0D1ZbXoOWFLr6xj5#rd">【年底补课】HTTP缓存机制</a></p><h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><p><a href="https://mp.weixin.qq.com/s/ZrbGggsOMBqxRmbZ3sdbCA">Web 动画帧率（FPS）计算</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585459&amp;idx=1&amp;sn=77035da29ed58237d778d893faf8f573&source=41#wechat_redirect">使用浏览器开发者工具检查CSS动画性能</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651553292&idx=3&sn=b58991ff60f1edfcfafe647c33f2886e&chksm=8025a9cdb75220dbe58f20af4a32afda89cd72e32aef9281a0b134b7ddff2a544db1fc420bd0&mpshare=1&scene=23&srcid=1218AvobKtmrK0Ik3thnpqcB#rd">盒子端 CSS 动画性能提升研究</a></p><h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><p><a href="https://mp.weixin.qq.com/s/K14eNpHK6QEcKzsHB5R52Q">Javascript图片预加载详解</a></p><p><a href="https://mp.weixin.qq.com/s/DcucyI2qQsHfhBnaP51Lag">JavaScript 中 4 种常见的内存泄露陷阱</a></p><p><a href="https://mp.weixin.qq.com/s/TICoQUpVDFOEDUIZPuCJ0A">深入 JavaScript 数组：进化与性能</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651553281&idx=3&sn=438970bf1e2f774f667948e2767bf66b&chksm=8025a9c0b75220d6640f2b738247c574ef648267f06b383ade9e603498806c5c1df4c523f4eb&mpshare=1&scene=23&srcid=1215imFJOwC30CtfJPelwVOX#rd">JavaScript 性能优化技巧分享</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651553229&idx=3&sn=addd2b503936d73d4686f7922d5fdf9c&chksm=8025aa0cb752231a2a5a47a0cf66f413d3535595fffcb46b86387049a6f22a3752a0d2c82c0c&mpshare=1&scene=23&srcid=1206mO7nQ3CWprzujjrwxoPL#rd">JavaScript 的时间消耗</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650840711&idx=1&sn=b1f6120c1810e09efd7891889f9db38b&chksm=80d3b5eeb7a43cf8c257825d6fcf531bb75ad72462c99b8797f9ecb86bf092b35fc2b2c74381&mpshare=1&scene=23&srcid=1130kZU7I1n4kTKMzErok9BT#rd">JavaScript 性能优化的小知识总结</a></p><h2 id="基本技能"><a href="#基本技能" class="headerlink" title="基本技能"></a>基本技能</h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p><a href="https://mp.weixin.qq.com/s/-2bEvdsvRHIFNRI-DCR-DQ">每个程序员都应该知道的基础数论</a></p><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p><a href="https://mp.weixin.qq.com/s/VJH-I3wBiY7921__b7S-dg">看完这篇文章才对GIT有了大彻大悟的认识</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227464&idx=2&sn=18c04a0e67a601a9d6c0ae666bbba189&chksm=bd495ccc8a3ed5da46ae5d5ea8dfb07430e5fa6f2519366288d84e8548e2a7e6fd453bc77fbe&mpshare=1&scene=23&srcid=1218UZGMPp6IOwYBcFsOTzlb#rd">Git提交历史的修改删除合并等实践</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227335&idx=1&sn=54bbf426f7b8358fddcb4a3901255eb3&chksm=bd495d438a3ed45517ce21f33cdd457fb9201ba34d6723a1104df8a9bc0a934737f0df92f9a7&mpshare=1&scene=23&srcid=1124KglxcraJndljOWntf5Kk#rd">Git的4个阶段的撤销更改</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227381&idx=1&sn=e16d9525319d8c36d06a4e395d205ef1&chksm=bd495d718a3ed467e95773fa4e2f2dbfd6b15f2b66d4914a1fc3d92ec382ceec534990340973&mpshare=1&scene=23&srcid=1201PMBfVfrTsOIauBWZz7lL#rd">重新组织git本地提交</a></p><h3 id="chrome、google、浏览器"><a href="#chrome、google、浏览器" class="headerlink" title="chrome、google、浏览器"></a>chrome、google、浏览器</h3><p><a href="https://mp.weixin.qq.com/s/1XDgtEFb_6YHxcdJQ92rbg">前端开发者应知必会：浏览器是如何渲染网页的</a></p><p><a href="https://mp.weixin.qq.com/s/c36PTGsmu1h80mQjwMEm9w">Chrome开发者工具的小技巧</a></p><p><a href="https://mp.weixin.qq.com/s/W7nhi_M7xIaUf3V1YNdJBA">从Chrome源码看JS Array的实现</a></p><p><a href="https://mp.weixin.qq.com/s/ux2QduYgN_LMjLhmMg8ToA">浏览器的工作原理：新式网络浏览器幕后揭秘（上）</a>）</p><p><a href="https://mp.weixin.qq.com/s/dcMND1KtNbJC3zD5X7WaMw">浏览器渲染原理及流程</a></p><p><a href="https://mp.weixin.qq.com/s/wdUeYzTzzaprvBZ1iNEHAA">基础 | 深入核心，详解事件循环机制</a></p><p><a href="https://mp.weixin.qq.com/s/e5CwofqIqxbPNLL9AVFa8w">认识 V8 引擎</a></p><p><a href="https://mp.weixin.qq.com/s/RmaldU_UuOE6xJA5_gjlYg">V8 内存分配与垃圾回收</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585412&amp;idx=1&amp;sn=7ec58c14a414b967e77dc84f79cdb8a5&source=41#wechat_redirect">加快构建 DOM: 使用预解析, async, defer 以及 preload</a></p><p><a href="https://mp.weixin.qq.com/s/4qKqPHabAY-a3_qNOXphZA">程序员的基础生存技能：高效用Google</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650840741&idx=1&sn=f8c38b96c1bf7a4333eabd31d9265696&chksm=80d3b5ccb7a43cda25580b5e7c092d2ed38a4f35f417271fcbc94f0199956eb4d0398c29679b&mpshare=1&scene=23&srcid=1208MHMWHjXPEDjacI0OZ1by#rd">Chrome 浏览器 必知必会的小技巧</a></p><p><a href="https://mp.weixin.qq.com/s/n6AF2WhwJBe1DYisoeUAHQ">探究 CSS 解析原理</a></p><p><a href="https://mp.weixin.qq.com/s/iwfSWADiDmKHKlfXNcU-Xg">浅析前端页面渲染机制</a></p><p><a href="https://mp.weixin.qq.com/s/Hl5raazWzb1LfLH1J3OzHg">原来 Google 还可以这么用，每个程序员都应该学会这些技巧</a></p><h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><p><a href="https://mp.weixin.qq.com/s/CQKFfecqy3_EgW0jLfEMIQ">深入理解JSON</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585571&amp;idx=1&amp;sn=4184b5b25f36c370930774f73b88bff1&source=41#wechat_redirect">奇舞周刊第 206 期：如何让博客速度快到哭</a></p><p><a href="https://mp.weixin.qq.com/s/Z-vKtayFWPZ-E-mXAgVNsQ">从输入url到页面展示到底发生了什么</a></p><p><a href="https://mp.weixin.qq.com/s/oQ4NsZc3xZSu9W45vXEvSw">GitHub 项目徽章的添加和设置</a></p><p><a href="https://mp.weixin.qq.com/s/WTTIM3Se_P1lM88RnywqAw">如何写出好的 JavaScript —— 浅谈 API 设计</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227410&idx=1&sn=403bfcc2cbfaa9a11e3f9b753059e75e&chksm=bd495c968a3ed580a843128a609fcebe9718099f9c5c89b67128202b27d44c6eee9311ed1be1&mpshare=1&scene=23&srcid=1208earneBe6U6BhByyKmBh0#rd">如何用人类的方式进行 Code Review</a></p><p><a href="https://mp.weixin.qq.com/s/T1nlZz-zRoepFp305hCBuQ">GraphQL 技术栈揭秘</a></p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585330&amp;idx=1&amp;sn=585392a4893c71005eaff871465cf277&source=41#wechat_redirect">前端本地文件操作与上传</a><br><a href="https://mp.weixin.qq.com/s/IEQ0ZP7Zw60nTBi8QnoKWQ">一篇真正教会你开发移动端页面的文章(一)</a></p><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2><p><a href="https://mp.weixin.qq.com/s/LJrJ-XgV4b2NZOJ4rRgtOg">手把手教你玩转 CSS3 3D 技术</a></p><p><a href="https://mp.weixin.qq.com/s/L6PqIAo_qS5hhdpyer7pzQ">偏门却又实用的 CSS 样式</a></p><p><a href="https://mp.weixin.qq.com/s/pGIn4EC6rTFZC3_GVoQhVg">实战 | 一张图让你快速掌握CSS3倒影</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585505&amp;idx=1&amp;sn=e40d973aae82a3fbaaf807ef21304da2&source=41#wechat_redirect">栅格布局卷土重来，用Grid还是Flexbox？</a></p><p><a href="https://mp.weixin.qq.com/s/rH0xcHPPjp42KUj3NooI6A">纯CSS3画出小黄人并实现动画效果</a></p><p><a href="https://mp.weixin.qq.com/s/7iP5joH8QxdX-u8gTKp1DQ">CSS进阶：试试酷炫的 3D 视角</a></p><p><a href="https://mp.weixin.qq.com/s/18JVhb34ZOJF-f8YFjYCmw">纯 CSS 实现波浪效果！</a></p><p><a href="https://mp.weixin.qq.com/s/EsLAcv_BtT7qnEd65MCtGA">字号与行高</a></p><p><a href="https://mp.weixin.qq.com/s/YUxSKRW98Q2uvqpF6zZ3Vg">理解伪元素 :before 和 :after</a></p><p><a href="https://mp.weixin.qq.com/s/iQ8mSr4oEAC8Ve6IdiN9jQ">CSS 布局说——可能是最全的</a></p><p><a href="https://mp.weixin.qq.com/s/GLJAYh2A45OvImG-AfIpGg">18个你可能不相信是用CSS制作出来的东西</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585331&amp;idx=1&amp;sn=c2d55ab4c5458d3dcda25188fd608079&source=41#wechat_redirect">也许你不知道，JS animation比CSS更快！</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDA2MTI1MA==&mid=2649086571&idx=2&sn=c20cf9a94c3dba8d52d4bdfbe9a0f118&chksm=be5bfdc6892c74d0099f092daee47cab8fb7325064ffe651877eed1cd175ffdf56f473f74de4&mpshare=1&scene=23&srcid=1215LapIBp3BJWB2CXDyzFJh#rd">灵活的 overflow</a></p><p><a href="https://mp.weixin.qq.com/s/ggQrcyn97RpkOZ636yVG4Q">你所不知道的 CSS 滤镜技巧与细节</a></p><p><a href="https://mp.weixin.qq.com/s/Esnv72Y1q7J5k2X7RBZ1OA">5个你可能不知道的CSS属性</a></p><p><a href="https://mp.weixin.qq.com/s/CMw6jOaUp8AFUZEhfvL24A">CSS3 中的层叠上下文初探</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651553261&idx=1&sn=5ca1a2a942d9943576fceacde8fc99ec&chksm=8025aa2cb752233a24002fc7b6755e4c1b1e336d6a3e0757b606718528a31931167f174a1d0b&mpshare=1&scene=23&srcid=1211udLg0917N2Ra8InzBace#rd">CSS: 潜藏着的BFC</a></p><p><a href="https://mp.weixin.qq.com/s/LxWuuF1jGH6BeKpYaH59ww">编写现代 CSS 代码的 20 个建议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585332&amp;idx=1&amp;sn=366dde06697a73410cc8df863cd0d506&source=41#wechat_redirect">不炫技，SVG+CSS3 旋转动画属性就能实现的梦幻效果</a></p><p><a href="https://mp.weixin.qq.com/s/N4WpjCI3TZre936HCXC0-g">前端动画大乱炖</a></p><h2 id="js"><a href="#js" class="headerlink" title="js"></a>js</h2><p><a href="https://mp.weixin.qq.com/s/GkFDZcSDbJlGQ6d2iE6Epw">你不知道的 DOMContentLoaded</a></p><p><a href="https://mp.weixin.qq.com/s/qoHAYft7gdr8h058E-zBJw">重新认识JS的this、作用域、闭包、对象</a></p><p><a href="https://mp.weixin.qq.com/s/lohBbUsVQyIhKcMMUFRZGg">import、require、export、module.exports 混合详解</a></p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><a href="https://mp.weixin.qq.com/s/YmabbClwgklZ05gy1MUOXA">OWASP Top 10：注入、XSS、CSRF、安全配置、攻击检测与防范不足等详解</a></p><p><a href="https://mp.weixin.qq.com/s/eQO4Z8Kp0PDFuoUA9pYovg">对于网络爬虫技术的攻与防</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NTUzNjk1OA==&mid=2651561279&idx=1&sn=69683cc9b95685df952970dc0ceb6124&chksm=8490326eb3e7bb78f22f7014b5af78e5b20908abe58177792137bed0eaca852b0bafe5339606&mpshare=1&scene=23&srcid=1210K63hcfbS8BVe9M5c9RIQ#rd">最好用的开源Web漏洞扫描工具梳理</a></p><h2 id="前端其他"><a href="#前端其他" class="headerlink" title="前端其他"></a>前端其他</h2><p><a href="https://mp.weixin.qq.com/s/kuF9Nk5x4NrLLZMB0ew--A">web开发中的长度单位（px,em,ex,rem），如何运用，看完这篇就够了！</a></p><p><a href="https://mp.weixin.qq.com/s/DyUSg_J6t1C43PDJZi8GuQ">探索Redux的最佳实践</a></p><p><a href="https://mp.weixin.qq.com/s/UYT42aiZ4oVbVmcoR2LrhQ">Callback Promise Generator Async-Await 和异常处理的演进</a></p><p><a href="https://mp.weixin.qq.com/s/-YSgPHrRI7dy8AcRB9mtAg">JavaScript内存泄漏教程</a></p><p><a href="https://mp.weixin.qq.com/s/IC3oMQLnz7hvKaN01JS_Zw">比较与理解React的Components，Elements和Instances</a></p><p><a href="https://mp.weixin.qq.com/s/d1wKQEw8xq1kV7NfixaWFw">理论 | React 源码剖析系列 － 不可思议的 react diff</a></p><p><a href="https://mp.weixin.qq.com/s/y4E2qwDIfqTEDpHjspEl0g">图解 React Virtual DOM</a></p><p><a href="https://mp.weixin.qq.com/s/vLuc3CIX_bx0HPLo9wZReA">浅谈Web自适应</a></p><p><a href="https://tech.meituan.com/redux-design-code.html">Redux从设计到源码</a></p><p><a href="https://mp.weixin.qq.com/s/8wMEbb6teFa_w2pmsvX5Jw">只有20行Javascript代码！手把手教你写一个页面模板引擎</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5NzkwNDk3MQ==&mid=2650585486&amp;idx=1&amp;sn=eaec2c3da7997d51d66c86d9b8cf7bdb&source=41#wechat_redirect">虚拟 DOM 内部是如何工作的？</a></p><p><a href="https://mp.weixin.qq.com/s/ViEAj3jkjfPIWeG1I-UIKg">关于加载设计，你要知道的8种策略和4种样式</a></p><p><a href="https://mp.weixin.qq.com/s/fDlyrRTv6zp-PQ1iRkTpBQ">前端常见跨域解决方案（全</a>）</p><p><a href="https://mp.weixin.qq.com/s/9IUpotmbjVrkoZ6pdIldgQ">前端跨域请求原理及实践</a></p><p><a href="https://mp.weixin.qq.com/s/-1FUAU29nBGzvOWquEzunQ">详解 CORS 跨域资源共享</a></p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p><a href="https://mp.weixin.qq.com/s/kPkgLiQqYpezm830QDWoag">鹅厂原创 | 前端中的函数式编程</a></p><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650999741&idx=2&sn=4982d1d2bef8991617007a5b53d04a97&chksm=bdbef3ee8ac97af812fc20eb280ce4fd141bb8ea97cd03e80c9a585cb39515112302a98d6bf5&mpshare=1&scene=23&srcid=1210cd7XMwyrDYDFNcu6DVYv#rd">学习人工智能需要哪些必备的数学基础？</a></p><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><p><a href="https://mp.weixin.qq.com/s/rEWDOzwCFMAYUgfCfZZPlA">鹅厂原创丨前端工作中遇到的数据结构和算法</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI2NjA3NTc4Ng==&mid=2652079827&idx=1&sn=46a806cb40d8060421f6bcaec6ef9f7f&chksm=f1748d36c6030420b1a523764c765672ceb8e1d60fda506da535b89087d1e2359609ffa7e6e7&mpshare=1&scene=23&srcid=1213FlMp9LxRUQC1cbqbJq1h#rd">可以管理时间的二叉堆</a></p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwNDcyNjI3OA==&mid=2650840782&idx=1&sn=9d079eee642dab07c388b1810f59397a&chksm=80d3b5a7b7a43cb1a84c62c0868bb11d91fd4f9167cfbe8cae1524add3d147d0ef7c03ef25a2&mpshare=1&scene=23&srcid=1226XQjcvvVbBCDjmNO7p883%23rd">Web开发应该知道的计算机网络知识</a></p><p><a href="https://mp.weixin.qq.com/s/Jo2G-1OE8s8BEEdsnjAhtQ">谈谈HTTP协议中的短轮询、长轮询、长连接和短连接</a></p><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><p><a href="https://mp.weixin.qq.com/s/MqHHWhkmDpyjuhZOprVPwA">有哪些命令行的软件堪称神器？</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ4MjYwMQ==&mid=2664610003&idx=1&sn=3b354a2b8329253207e1e380ff6c514a&chksm=bdce83958ab90a83e8611d7df60affb4c5620238bdebfb4713c5507ef25a20a9956d29d45e9d&mpshare=1&scene=23&srcid=1211omI87vF3YytmFfCB0SMZ#rd">通过示例学习使用 netstat</a></p><h2 id="人工智能-1"><a href="#人工智能-1" class="headerlink" title="人工智能"></a>人工智能</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650999741&idx=2&sn=4982d1d2bef8991617007a5b53d04a97&chksm=bdbef3ee8ac97af812fc20eb280ce4fd141bb8ea97cd03e80c9a585cb39515112302a98d6bf5&mpshare=1&scene=23&srcid=1210cd7XMwyrDYDFNcu6DVYv#rd">学习人工智能需要哪些必备的数学基础？</a></p><h2 id="工具、编辑器"><a href="#工具、编辑器" class="headerlink" title="工具、编辑器"></a>工具、编辑器</h2><p><a href="https://mp.weixin.qq.com/s/xT0SyOJz6Gm79bP-Tw5Tig">Mac电脑超实用的81个快捷键</a></p><p><a href="https://mp.weixin.qq.com/s/sxSgRH3KdP9BJD6aTXUEXw">开源许可证教程</a></p><p><a href="https://mp.weixin.qq.com/s/RTRR2inNJR_Z-zGKlMgO4Q">如何让 Vim 成为我们的神器</a></p><p><a href="https://mp.weixin.qq.com/s/oPDpfqNA1gaqgly47XNY9A">给 Web 开发人员推荐的文档生成工具</a></p><p><a href="https://mp.weixin.qq.com/s/1VitJ8AL4g9w51klmCO_Uw">利用 javascript 实现富文本编辑器</a></p><h2 id="想玩的"><a href="#想玩的" class="headerlink" title="想玩的"></a>想玩的</h2><p><a href="https://mp.weixin.qq.com/s/kbflEwR7nEWsfbkqcsXH6Q">Electron开发，如何入坑？</a></p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><p><a href="https://mp.weixin.qq.com/s/5vo6Q4KbdEWW-V6kF0qfwA">实战 | webpack原理与实战</a></p><p><a href="https://mp.weixin.qq.com/s/jUwg7_-r8emwZZqvjvoYyQ">如何写好.babelrc？Babel的presets和plugins配置解析</a></p><h2 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h2><p><a href="https://mp.weixin.qq.com/s/65_HFiWEWgx5iy_dd9F-Ww">10个妨碍进步的前端学习方式</a></p>]]></content>
    
    
    <categories>
      
      <category>桃园周刊</category>
      
    </categories>
    
    
    <tags>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clip-path 实战</title>
    <link href="/index.php/archives/15/"/>
    <url>/index.php/archives/15/</url>
    
    <content type="html"><![CDATA[<h3 id="demo演示"><a href="#demo演示" class="headerlink" title="demo演示"></a>demo演示</h3><h4 id="多边形图"><a href="#多边形图" class="headerlink" title="多边形图"></a>多边形图</h4><p><img src="http://upload-images.jianshu.io/upload_images/2974893-23031feaabbb7c38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><span id="more"></span><p><a href="https://crazylxr.github.io/blog-demos/css/clip-path/demo1.html">demo1</a></p><h4 id="利用css-Transition制作动画"><a href="#利用css-Transition制作动画" class="headerlink" title="利用css Transition制作动画"></a>利用css Transition制作动画</h4><p><a href="https://crazylxr.github.io/blog-demos/css/clip-path/demo2.html">demo2</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>CSS 的 <strong>clip-path</strong> 属性是改变传统单调的盒子布局，走向响应式设计的通行证。可以摆脱条条框框，自由地在网页上使用六边形、星形等等等进行设计。</p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><ul><li><p>使用 CSS （ Chrome 24+, Safari 7+, Opera 15+, iOS 7.1+, Android 4.4+, Opera Mobile 24+（注意：所有目前支持的浏览器都需要一个-webkit前缀））</p></li><li><p>使用SVG（上面列出的所有浏览器以及Firefox3.5+）</p><ul><li>内敛SVG引用</li><li>外部SVG文件的引用<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><a href="http://bennettfeely.com/clippy/">http://bennettfeely.com/clippy/</a><h4 id="基础多边形"><a href="#基础多边形" class="headerlink" title="基础多边形"></a>基础多边形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123; <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">ploygon</span>(x1 y1, x2 y2, x3 y3, ...) &#125;<br></code></pre></td></tr></table></figure>x y分别是每个点的坐标，点的绘制会根据顺时针的方向，然后根据直线连接起来<h4 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123; <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">circle</span>(r at x y) &#125;;<br></code></pre></td></tr></table></figure>r是圆的大小，x y分别是圆心的坐标。可以用百分比<h4 id="椭圆"><a href="#椭圆" class="headerlink" title="椭圆"></a>椭圆</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123; <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">ellipse</span>(w h at x y) &#125;;<br></code></pre></td></tr></table></figure>w为水平宽度，h为垂直高度，x y为椭圆的圆心<h4 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123; <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">inset</span>(x y z p) &#125;;<br></code></pre></td></tr></table></figure>x为离top的距离 y为right的距离  z为bottom的距离  p为left的距离。跟多边形一样也是顺时针，跟多边形不同的是多边形是用边来使用的</li></ul></li></ul><h4 id="svg使用语法"><a href="#svg使用语法" class="headerlink" title="svg使用语法"></a>svg使用语法</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.element</span> &#123; <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;选择器&quot;</span>)&#125;<br></code></pre></td></tr></table></figure><h3 id="demo实现"><a href="#demo实现" class="headerlink" title="demo实现"></a>demo实现</h3><p><a href="https://github.com/crazylxr/blog-demos/blob/master/css/clip-path/demo1.html">demo1</a><br><a href="https://github.com/crazylxr/blog-demos/blob/master/css/clip-path/demo2.html">demo2</a></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="http://upload-images.jianshu.io/upload_images/2974893-00fd6d2352dc3f09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>变成<br><img src="http://upload-images.jianshu.io/upload_images/2974893-a580be545d0d8815.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>思路：分别是四块，那么就先切除四块菱形的，然后通过定位定到一起<br>怎么切成四块菱形呢，先整除四块方块的然后再切成菱形的，四块方块的大小为整个图片的一半，<br>但是方块怎么弄成不一样的呢，通过background-position来设置背景图片位置就可以达到想要的结果了</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>四块图片代码如下：<br>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-block&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-clip-wrap</span> &#123;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>      <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;http://karenmenezes.com/shapes-polygon/clip-demo.jpg&quot;</span>);<br>      <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>      <span class="hljs-attribute">margin-left</span>: auto;<br>      <span class="hljs-attribute">margin-right</span>: auto;<br>      <span class="hljs-attribute">display</span>: block;<br>      <span class="hljs-attribute">position</span>: relative;<br>    &#125;<br></code></pre></td></tr></table></figure><p>效果图<br><img src="http://upload-images.jianshu.io/upload_images/2974893-eecc439834e40a2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="第二步-切成菱形块，并根据backgrount-position设置成对应的位置"><a href="#第二步-切成菱形块，并根据backgrount-position设置成对应的位置" class="headerlink" title="第二步 切成菱形块，并根据backgrount-position设置成对应的位置"></a>第二步 切成菱形块，并根据backgrount-position设置成对应的位置</h4><p>效果图：<br><img src="http://upload-images.jianshu.io/upload_images/2974893-6548ee0cb7f96ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>html代码没变，<br>css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-clip-wrap</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>   <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;http://karenmenezes.com/shapes-polygon/clip-demo.jpg&quot;</span>);<br>   <span class="hljs-attribute">background-repeat</span>: no-repeat;<br>   <span class="hljs-attribute">margin-left</span>: auto;<br>   <span class="hljs-attribute">margin-right</span>: auto;<br>   <span class="hljs-attribute">display</span>: block;<br>   <span class="hljs-attribute">position</span>: relative;<br> +  -webkit-<span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">50%</span>, <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">50%</span>);<br> + <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">polygon</span>(<span class="hljs-number">50%</span> <span class="hljs-number">0%</span>, <span class="hljs-number">100%</span> <span class="hljs-number">50%</span>, <span class="hljs-number">50%</span> <span class="hljs-number">100%</span>, <span class="hljs-number">0%</span> <span class="hljs-number">50%</span>);<br> &#125;<br> <span class="hljs-selector-class">.img-clip-wrap</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">1</span>) &#123;<br>     <span class="hljs-attribute">background-position</span>: top;<br> &#125;<br> <span class="hljs-selector-class">.img-clip-wrap</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">2</span>) &#123;<br>     <span class="hljs-attribute">background-position</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.img-clip-wrap</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">3</span>) &#123;<br>     <span class="hljs-attribute">background-position</span>: right;<br> &#125;<br> <span class="hljs-selector-class">.img-clip-wrap</span><span class="hljs-selector-pseudo">:nth-of-type</span>(<span class="hljs-number">4</span>) &#123;<br>     <span class="hljs-attribute">background-position</span>: bottom;<br> &#125;<br></code></pre></td></tr></table></figure><h3 id="第三步-调整位置"><a href="#第三步-调整位置" class="headerlink" title="第三步 调整位置"></a>第三步 调整位置</h3><p>观察我们要做的图，布局可以是分成三行，其中第二行应该有两个块，然后合在一起, 让第二行左右排列的话，只需要设置菱形块display为inline-block就可以了效果就是这样<br><img src="http://upload-images.jianshu.io/upload_images/2974893-2e80e906b65e0c82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>看着这样，感觉马上就要成功了，怎么让他们合在一起呢，设置一下margin-top为负的就好了，最终效果就出来啦，最终代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-block&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-row&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-row&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-row&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-clip-wrap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>增加的css</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-clip-row</span> &#123;<br>   <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">154px</span>;<br> &#125;<br><br> <span class="hljs-selector-class">.img-clip-row</span><span class="hljs-selector-pseudo">:first</span>-of-type &#123;<br>   <span class="hljs-attribute">margin-top</span>: auto;<br> &#125;<br><br> <span class="hljs-selector-class">.img-clip-wrap</span> &#123;<br>   <span class="hljs-attribute">display</span>: inline-block;<br> &#125;<br></code></pre></td></tr></table></figure><p><a href="https://github.com/crazylxr/blog-demos/blob/master/css/clip-path/demo4.html">点我获取完整代码</a><br><a href="https://crazylxr.github.io/blog-demos/css/clip-path/demo3.html">点我获取升级demo</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>本文只是介绍了最基础的知识语法和一点小应用，但是这还是太简单的东西了。<br>大漠在微博上分享的这个网站：<a href="http://species-in-pieces.com/">http://species-in-pieces.com/</a>，30个动物30种变换，看了之后简直打开眼界。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.w3cplus.com/css3/creating-responsive-shapes-with-clip-path.html">打破盒子模式的限制，使用Clip-Path创建响应式图形</a><br><a href="https://css-tricks.com/clipping-masking-css/">clipping-masking-css</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>clip-path</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css实现图片剪裁</title>
    <link href="/index.php/archives/6/"/>
    <url>/index.php/archives/6/</url>
    
    <content type="html"><![CDATA[<p>也许，你会遇到这样的情况，UI给你一张图片，然而根据实际情况，比如需要适配XXX手机，或者需要把图片形状搞好看一点，会让前端人员进行图片剪裁工作。</p><span id="more"></span><p>现在我们就已这个例子来对图片进行剪裁</p><p>html代码如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;img-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./黑人问号.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;黑人问号&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>css代码如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.img-container</span> <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="图片下面进行剪裁"><a href="#图片下面进行剪裁" class="headerlink" title="图片下面进行剪裁"></a>图片下面进行剪裁</h3><p>现在的需求是这样的：原来尺寸是width为300px，height为300px的图片。<br><img src="http://120.78.133.198/usr/uploads/2017/12/1006437807.jpg" alt="黑人问号.jpg">  </p><p>现在要把图片下面剪裁100px</p><p><img src="http://120.78.133.198/usr/uploads/2017/12/3909861701.png" alt="黑人问号下.png"></p><p>只需要将css改为</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"> <span class="hljs-selector-class">.img-container</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br><span class="hljs-selector-class">.img-container</span> <span class="hljs-selector-tag">img</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br> &#125;<br></code></pre></td></tr></table></figure><p>具体思想就是:把img容器的高度设置成需要的高度，然后设置overflow:hidden就可以了。</p><h3 id="图片上面进行剪裁"><a href="#图片上面进行剪裁" class="headerlink" title="图片上面进行剪裁"></a>图片上面进行剪裁</h3><p>比如我们把上面剪裁100px，变成这样</p><p><img src="http://120.78.133.198/usr/uploads/2017/12/547838547.png" alt="黑人问号上.png"></p><p>css代码只需要改为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-container</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br> &#125;<br><span class="hljs-selector-class">.img-container</span> <span class="hljs-selector-tag">img</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>   <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="上下都剪裁"><a href="#上下都剪裁" class="headerlink" title="上下都剪裁"></a>上下都剪裁</h3><p>比如把上下都剪裁50px<br>效果如下：<br><img src="http://120.78.133.198/usr/uploads/2017/12/469103045.png" alt="黑人问号上下.png"></p><p>思路：首先我们知道上下剪裁50px，那么原来高300px，现在只有200px,如果直接设置200px，就跟第一个例子一样，把下面剪裁了100px，根据上一个例子的思路，我们如果设置img的margin-top为负的，既可以把图片位置向上移。所以现在css代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-container</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>   <span class="hljs-attribute">overflow</span>: hidden;<br>&#125;<br><span class="hljs-selector-class">.img-container</span> <span class="hljs-selector-tag">img</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>   <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然学会了上下剪裁，左右剪裁都是类似的思路。</p><h3 id="圆形剪裁"><a href="#圆形剪裁" class="headerlink" title="圆形剪裁"></a>圆形剪裁</h3><p>这种一般用于圆形头像<br><img src="http://120.78.133.198/usr/uploads/2017/12/2851494723.png" alt="黑人问号圆.png"></p><p>思路：首先把container的width和height设置成宽高一样，然后设置img的 border-radius为容器宽高的一半就可以了</p><p>css代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.img-container</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>   <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>&#125;<br><span class="hljs-selector-class">.img-container</span> <span class="hljs-selector-tag">img</span> &#123;<br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>   <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">150px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我不喜欢这世界，我只喜欢你</title>
    <link href="/index.php/archives/3/"/>
    <url>/index.php/archives/3/</url>
    
    <content type="html"><![CDATA[<ul><li>我这人运气一向不好，我这辈子最幸运的事大概就是遇见你，所以我特别特别珍惜，长这么大唯一坚持下来的事情就是爱你。</li><li>反正得听你啰嗦一辈子，习惯就好。</li><li>因为只有在我面前，她可以不用坚强。</li><li>但我知道，一想到能和你共度余生，我就对余生充满期待。</li></ul><span id="more"></span><ul><li>遇见你那天起，就没 想过要分开。</li><li>喜欢一个人，就像喜欢富士山，你可以看到它，但是不能搬走它–你唯一能做的，就是自己走过去，去争取自己的爱人。</li><li>我从来不想要什么更好的人，我只想要眼前的人，你究竟什么时候才会懂？</li><li>海底月是天上月，眼前人是心上人。</li><li>一辈子很长，要跟有趣的人在一起。</li><li>小时候他问爸爸自己从哪里来的，他爸爸没有像其他大人那样tang’s搪塞说“从垃圾堆里捡来的”或者“从胳肢窝里掉下来的”，而是说：“你是天上的天使，上帝觉得妈妈是这个世界上最美的女孩，所以派你来保护她。”<br>小F问：“那么你呢？”  “等你长大了就会离开她，爸爸负责陪妈妈到老 ”</li><li>老夫老妻了还送什么花，我送你工资卡，让你随便花。</li><li>爱情不是人生的全部,它是锦上添花不是救命稻草，女人除了年轻美貌被男人爱，难道不应该努力学习，不断成长，多一点智慧和温柔去建立自我的价值吗。眼界放宽些，这个世界比你想象的要广阔，你应该跟你爱的人一起去看天大地大，而不是抱在一起相互取暖。</li><li>如果说，喜欢是渴望将好的一起分享，那么，爱是愿意把坏的共同承担。                </li><li>爱让我们褪去身上青涩的棱角，穿越汹涌的人潮，用最温柔最炙热的爱拥抱彼此，我知道这个世界什么都善变，可是说真的，眼前这个人，他让我 相信永远。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
