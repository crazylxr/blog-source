<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桃园</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-12-26T14:39:58.809Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>桃翁</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git commit 规范和 如何在 commit 里使用 emoji</title>
    <link href="http://example.com/index.php/archives/20210905/"/>
    <id>http://example.com/index.php/archives/20210905/</id>
    <published>2021-09-05T07:30:00.000Z</published>
    <updated>2021-12-26T14:39:58.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家好，我是桃翁，今天给大家带来的是关于 git commit 那些事儿，希望大家喜欢。</p><p>对于规范 git commit message 我是分成了两种类型去看待。</p><ul><li><p>对于通用库、开源项目这类多人维护，而且极大可能别人会来看这份代码的，一定要规范，特别是对于开源项目，往往会要列 Change Log，规范好 commit 节省自己整理 log 的时间，也方便了用户。</p></li><li><p>对于业务代码，特别是那种一个人维护的，其实不搞问题也不大，因为极小可能会有人来看你的 commit message。但是我依然还是建议规范一下，不然一旦后面想去看就会花费很多的力气，毕竟规范一下也不麻烦。</p></li></ul><p>通过本篇文章你讲了解到三部分内容：</p><ol><li>了解 git commit 规范</li><li>学到用工具 Commitizen 来规范 commit</li><li>学到如何在 commit message 里加上好看的 emoji</li></ol><h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>现在主流的 commit message 规范就是 <a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">Angular 团队所用的准则</a>，继而衍生了 <a href="https://link.zhihu.com/?target=https://conventionalcommits.org/">Conventional Commits specification</a>. 很多工具也是基于此规范。</p><p>每次提交，Commit message 都包括三个部分：header，body 和 footer，其中 header 有一个特殊的格式，包括了 type、scope、subject。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>(<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>): <span class="hljs-tag">&lt;<span class="hljs-name">subject</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">BLANK</span> <span class="hljs-attr">LINE</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">footer</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中 header 是必选的，但是 header 里的 scope 是可选的，另外提交的 message 长度不要超过 100 个字符，太长了不易阅读。</p><p><strong>对于我个人来说，我觉得只要把 header 部分规范其实基本能满足绝大部分需要了，强制去规范 body 和 footer 对于团队的同学来说简直是折磨，所以我这里仅介绍 header 的几部分</strong></p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>type 指明 git commit 的类别，应该使用以下类型</p><ul><li>『feat』: 新增功能</li><li>『fix』: 修复 bug</li><li>『docs』: 仅仅修改了文档，比如 README, CHANGELOG等等</li><li>『test』: 增加/修改测试用例，包括单元测试、集成测试等</li><li>『style』: 修改了空行、缩进格式、引用包排序等等（不改变代码逻辑）</li><li>『perf』: 优化相关内容，比如提升性能、体验、算法等</li><li>『refactor』: 代码重构，「没有新功能或者bug修复」</li><li>『chore』: 改变构建流程、或者增加依赖库、工具等</li><li>『revert』: 回滚到上一个版本</li><li>『merge』: 代码合并</li></ul><blockquote><p>这里面有些 angular 团队没有，自己可以自行增减</p></blockquote><h3 id="scope（可选）"><a href="#scope（可选）" class="headerlink" title="scope（可选）"></a><strong>scope（可选）</strong></h3><p>scope用于说明 commit 影响的范围，根据不同项目有不同层次描述。若没有特殊规定，也可以描述影响的哪些功能等。</p><h3 id="subject"><a href="#subject" class="headerlink" title="subject"></a><strong>subject</strong></h3><p>subject 是 commit 目的的简短描述，不超过50/80个字符，一般 git 提交的时候会有颜色提示。</p><ul><li>若英文用不惯，那么推荐使用中文</li><li>若是开源代码，一律推荐统一英文，英文不行可以翻译软件用起来</li><li>若是开源代码，可以再附加对应的issue地址</li><li>结尾不加标点符号</li></ul><h2 id="工具：Commitizen"><a href="#工具：Commitizen" class="headerlink" title="工具：Commitizen"></a>工具：Commitizen</h2><p>Commitizen是一个撰写合格 Commit message 的工具,（详细说明<a href="https://github.com/commitizen/cz-cli">见 github 地址</a>），用于代替 git commit 指令，而 cz-conventional-changelog 适配器提供 conventional-changelog 标准（约定式提交标准）。基于不同需求，也可以使用不同适配器。</p><p><strong>1. 全局安装 commitizen cz-conventional-changelog</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g commitizen cz-conventional-changelog<br></code></pre></td></tr></table></figure><p><strong>2. git cz 取代 git commit</strong></p><p>安装完毕后，可直接使用 git cz 来取代 git commit。</p><p><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308510363184.jpg"></p><p>可以看到当你 cz 之后，下面有很多的 type 让你选择，这就省掉了每次你去想应该用哪种 type，非常方便。</p><blockquote><p>全局模式下，需要 <code>~/.czrc</code> 配置文件, 为commitizen 指定 Adapter, 如果你不需要生成 Change Log 可以不用去处理。</p></blockquote><p>只要用了 Commitizen ，就很方便的就规范的大家的 message 。</p><h2 id="在-commit-message-里用-emoji"><a href="#在-commit-message-里用-emoji" class="headerlink" title="在 commit message 里用 emoji"></a>在 commit message 里用 emoji</h2><p>在 git commit 上使用 emoji 提供了一种简单的方法，仅通过查看所使用的表情符号来确定提交的目的或意图, 得提交记录非常好理解，阅读体验非常棒。</p><p><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308316508371.jpg"></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>git commit 时直接在注释中写入表情符号的代码部分即可完成表情 emoji 的提交。</p><p><strong>举个栗子：</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;:tada: init commit&#x27;</span><br><span class="hljs-variable">$ </span>git commit -m <span class="hljs-string">&#x27;added image to repo :art:&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果你用 Commitizen，可能不太好把 emoji 放在最前面，因为咱们操作的空间，就在 git cz 后第三次交互提示，也就是在输入 header 的 subject 的时候填入，如果是这样，可以选择把表情放到最后。 </p></blockquote><p>效果展示：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308323105662.jpg"></p><p>如果你们团队是一个喜欢用 emoji 的团队，其实可以不用遵循上面的一节的规范，因为 emoji 已经可以表达出 header 的 type 的作用了，直接在 emoji 后面加描述即可。</p><h3 id="emoji-表情库"><a href="#emoji-表情库" class="headerlink" title="emoji 表情库"></a>emoji 表情库</h3><table><thead><tr><th align="left">emoji</th><th align="left">emoji 代码</th><th align="left">commit 说明</th></tr></thead><tbody><tr><td align="left">:tada: (庆祝)</td><td align="left"><code>:tada:</code></td><td align="left">初次提交</td></tr><tr><td align="left">:new: (全新)</td><td align="left"><code>:new:</code></td><td align="left">引入新功能</td></tr><tr><td align="left">:bookmark: (书签)</td><td align="left"><code>:bookmark:</code></td><td align="left">发行/版本标签</td></tr><tr><td align="left">:bug: (bug)</td><td align="left"><code>:bug:</code></td><td align="left">修复 bug</td></tr><tr><td align="left">:ambulance: (急救车)</td><td align="left"><code>:ambulance:</code></td><td align="left">重要补丁</td></tr><tr><td align="left">:globe_with_meridians: (地球)</td><td align="left"><code>:globe_with_meridians:</code></td><td align="left">国际化与本地化</td></tr><tr><td align="left">:lipstick: (口红)</td><td align="left"><code>:lipstick:</code></td><td align="left">更新 UI 和样式文件</td></tr><tr><td align="left">:clapper: (场记板)</td><td align="left"><code>:clapper:</code></td><td align="left">更新演示/示例</td></tr><tr><td align="left">:rotating_light: (警车灯)</td><td align="left"><code>:rotating_light:</code></td><td align="left">移除 linter 警告</td></tr><tr><td align="left">:wrench: (扳手)</td><td align="left"><code>:wrench:</code></td><td align="left">修改配置文件</td></tr><tr><td align="left">:heavy_plus_sign: (加号)</td><td align="left"><code>:heavy_plus_sign:</code></td><td align="left">增加一个依赖</td></tr><tr><td align="left">:heavy_minus_sign: (减号)</td><td align="left"><code>:heavy_minus_sign:</code></td><td align="left">减少一个依赖</td></tr><tr><td align="left">:arrow_up: (上升箭头)</td><td align="left"><code>:arrow_up:</code></td><td align="left">升级依赖</td></tr><tr><td align="left">:arrow_down: (下降箭头)</td><td align="left"><code>:arrow_down:</code></td><td align="left">降级依赖</td></tr><tr><td align="left">:zap: (闪电)<br>:racehorse: (赛马)</td><td align="left"><code>:zap:</code><br><code>:racehorse:</code></td><td align="left">提升性能</td></tr><tr><td align="left">:chart_with_upwards_trend: (上升趋势图)</td><td align="left"><code>:chart_with_upwards_trend:</code></td><td align="left">添加分析或跟踪代码</td></tr><tr><td align="left">:rocket: (火箭)</td><td align="left"><code>:rocket:</code></td><td align="left">部署功能</td></tr><tr><td align="left">:white_check_mark: (白色复选框)</td><td align="left"><code>:white_check_mark:</code></td><td align="left">增加测试</td></tr><tr><td align="left">:memo: (备忘录)<br>:book: (书)</td><td align="left"><code>:memo:</code><br><code>:book:</code></td><td align="left">撰写文档</td></tr><tr><td align="left">:hammer: (锤子)</td><td align="left"><code>:hammer:</code></td><td align="left">重大重构</td></tr><tr><td align="left">:art: (调色板)</td><td align="left"><code>:art:</code></td><td align="left">改进代码结构/代码格式</td></tr><tr><td align="left">:fire: (火焰)</td><td align="left"><code>:fire:</code></td><td align="left">移除代码或文件</td></tr><tr><td align="left">:pencil2: (铅笔)</td><td align="left"><code>:pencil2:</code></td><td align="left">修复 typo</td></tr><tr><td align="left">:construction: (施工)</td><td align="left"><code>:construction:</code></td><td align="left">工作进行中</td></tr><tr><td align="left">:wastebasket: (垃圾桶)</td><td align="left"><code>:wastebasket:</code></td><td align="left">废弃或删除</td></tr><tr><td align="left">:wheelchair: (轮椅)</td><td align="left"><code>:wheelchair:</code></td><td align="left">可访问性</td></tr><tr><td align="left">:construction_worker: (工人)</td><td align="left"><code>:construction_worker:</code></td><td align="left">添加 CI 构建系统</td></tr><tr><td align="left">:green_heart: (绿心)</td><td align="left"><code>:green_heart:</code></td><td align="left">修复 CI 构建问题</td></tr><tr><td align="left">:lock: (锁)</td><td align="left"><code>:lock:</code></td><td align="left">修复安全问题</td></tr><tr><td align="left">:whale: (鲸鱼)</td><td align="left"><code>:whale:</code></td><td align="left">Docker 相关工作</td></tr><tr><td align="left">:apple: (苹果)</td><td align="left"><code>:apple:</code></td><td align="left">修复 macOS 下的问题</td></tr><tr><td align="left">:penguin: (企鹅)</td><td align="left"><code>:penguin:</code></td><td align="left">修复 Linux 下的问题</td></tr><tr><td align="left">:checkered_flag: (旗帜)</td><td align="left"><code>:checkered_flag:</code></td><td align="left">修复 Windows 下的问题</td></tr><tr><td align="left">:twisted_rightwards_arrows: (交叉箭头)</td><td align="left"><code>:twisted_rightwards_arrows:</code></td><td align="left">分支合并</td></tr></tbody></table><h3 id="如何在命令行中显示-emoji"><a href="#如何在命令行中显示-emoji" class="headerlink" title="如何在命令行中显示 emoji"></a>如何在命令行中显示 emoji</h3><p>默认情况下，在命令行中并不会显示出 emoji, 仅显示 emoji 代码。不过可以使用 emojify 使得在命令行也可显示 emoji, 它是一个 shell 脚本，安装与使用都很简单，在<a href="https://github.com/mrowa44/emojify">这里</a> 查看更详细的如何安装与使用。</p><h4 id="安装-emojify"><a href="#安装-emojify" class="headerlink" title="安装 emojify"></a>安装 emojify</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo sh -c <span class="hljs-string">&quot;curl https://raw.githubusercontent.com/mrowa44/emojify/master/emojify -o /usr/local/bin/emojify &amp;&amp; chmod +x /usr/local/bin/emojify&quot;</span><br></code></pre></td></tr></table></figure><h4 id="使用-emojify"><a href="#使用-emojify" class="headerlink" title="使用 emojify"></a>使用 emojify</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ emojify <span class="hljs-string">&quot;Hey, I just :raising_hand: you, and this is :scream: , but here&#x27;s my :calling: , so :telephone_receiver: me, maybe?&quot;</span><br></code></pre></td></tr></table></figure><p>显示效果：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308498280794.jpg"></p><p>在使用 git bash 的时候，设置替换日志中的表情符号代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --oneline --color | emojify | less -r<br></code></pre></td></tr></table></figure><p>或者设置git log命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">alias</span> gitlog=<span class="hljs-string">&#x27;git log --oneline --color | emojify | less -r&#x27;</span><br><br>$ gitlog <br></code></pre></td></tr></table></figure><p>效果如下：<br><img src="http://imgs.taoweng.site/mweb/2021-09-05-16308499434082.jpg"></p><p><strong>是不是很好玩，快去试试吧！</strong></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://hooj0.github.io/git-emoji-guide/">git-emoji-guide</a></li><li><a href="https://zhuanlan.zhihu.com/p/29764863">git commit 时使用 Emoji ?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大家好，我是桃翁，今天给大家带来的是关于 git commit 那些事儿，希望大家喜欢。&lt;/p&gt;
&lt;p&gt;对于规范 git commit me</summary>
      
    
    
    
    <category term="计算机相关" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>img 和 picture 的区别和使用场景</title>
    <link href="http://example.com/index.php/archives/341/"/>
    <id>http://example.com/index.php/archives/341/</id>
    <published>2021-07-01T07:12:00.000Z</published>
    <updated>2021-07-01T15:15:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="img"><a href="#img" class="headerlink" title="img"></a>img</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img">img</a> 是 HTML4 时就有的标签， 至今仍然是在网页中嵌入图片的最常用的方式。 与 <code>&lt;span&gt;</code>, <code>&lt;em&gt;</code> 等标签一样属于行内标签 （准确地说属于 <a href="https://html.spec.whatwg.org/#phrasing-content">Phrasing Content</a>）。下面是一个示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;favicon72.png&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;MDN logo&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;favicon144.png 2x&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>img 其实也可以控制在高清屏幕采用哪个图片，适合用在移动端</p><h2 id="picture"><a href="#picture" class="headerlink" title="picture"></a>picture</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;/media/cc0-images/surfer-240-200.jpg&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 800px)&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/media/cc0-images/painted-hand-298-332.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要决定加载哪个URL，<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/User_agent">user agent</a> 检查每个 <code>&lt;source&gt;</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-srcset"><code>srcset</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-media"><code>media</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/source#attr-type"><code>type</code></a> 属性，来选择最匹配页面当前布局、显示设备特征等的兼容图像。</p><p>picture 就可以方便的控制在某种媒体类型，加载哪个图片。感觉比较适合做响应式用。</p><p>相比 <code>img</code> 标签，<code>picture</code> 提供了更丰富的响应式资源选择方式；</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/picture">picture</a> 是 HTML5 中定义新标签， 其中可以定义若干个 <code>&lt;source&gt;</code>，浏览器会匹配 <code>&lt;source&gt;</code> 的 <code>type</code>, <code>media</code>, <code>srcset</code> 等属性， 来找到最适合当前布局、<a href="https://harttle.land/2016/04/21/viewport.html">视口宽度</a>、<em>设备像素密度</em> 的一个去下载。 为了向下兼容不识别 <code>&lt;picture&gt;</code> 和 <code>&lt;source&gt;</code> 的浏览器，<code>&lt;picture&gt;</code> 中还可以写一个 <code>&lt;img&gt;</code> 作为 fallback。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;harttle-land-avatar.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 750px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;harttle-land-banner.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;a banner for harttle.land&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="图片如何做响应式"><a href="#图片如何做响应式" class="headerlink" title="图片如何做响应式"></a>图片如何做响应式</h2><h3 id="响应式：基于视口宽度"><a href="#响应式：基于视口宽度" class="headerlink" title="响应式：基于视口宽度"></a>响应式：基于视口宽度</h3><p><a href="https://en.wikipedia.org/wiki/Responsive_web_design">响应式设计</a> 是一种 Web 页面设计方式， 使得不同 <a href="https://harttle.land/2016/04/21/viewport.html">视口宽度</a> 和 <em>设备像素密度</em> 下内容都可以很好地展示，都可以保证可用性和用户满足。</p><p>提到响应式多数开发者都会想到 CSS 媒体查询，但 HTML5 中还定义了元素属性的媒体查询。 这使得可以通过媒体查询来根据元素渲染宽度 <em>选择资源</em> 和 <em>图片占位</em>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> </span><br><span class="hljs-tag">     <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-200.png 200w, avatar-400.png 400w&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">sizes</span>=<span class="hljs-string">&quot;(max-width: 600px) 200px, 50vw&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器会根据 <code>sizes</code> 的媒体查询来决定渲染大小；此后根据实际的渲染大小来决定选择哪个资源。 比如屏幕宽度为 <code>500px</code>，那么就会调整图片大小为 <code>200px</code>， 然后选择 <code>srcset</code> 中最匹配这个大小的 <code>avatar-200.png</code> 去下载。</p><h3 id="响应式：基于设备像素比"><a href="#响应式：基于设备像素比" class="headerlink" title="响应式：基于设备像素比"></a>响应式：基于设备像素比</h3><p>支持 HTML5 的浏览器中还可以基于 <em>设备像素比</em> 来选择资源。 在刚出现 Retina 屏幕时有些网页图片展现模糊， 就是因为在高像素密度（比如 2 倍设备像素比）的屏幕上仍然显示 1 倍大小的图片。 <code>&lt;img&gt;</code> 元素的 src 和 srcset 属性都支持 x 描述符来提供不同大小的图片。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar-1.0.png&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-1.5.png 1.5x, avatar-2.0.png 2x&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用户代理可以根据用户屏幕像素密度、缩放级别，甚至用户的网络条件选择任何一个给出的资源。 这里同时给出 <code>src</code> 也是为了向后兼容。</p><h3 id="响应式：基于媒体查询"><a href="#响应式：基于媒体查询" class="headerlink" title="响应式：基于媒体查询"></a>响应式：基于媒体查询</h3><p>上文提到在 <code>&lt;img&gt;</code> 元素的 <code>sizes</code> 中可以写媒体查询来计算宽高。 <code>&lt;picture&gt;</code> 中也可以通过媒体查询来选择 <code>&lt;source&gt;</code> 可以给不同的设备大小下载不同的图片。 区别在于 <strong>基于视口宽度</strong> 的资源选择侧重于对不同大小的屏幕选择宽度适合的，同样内容的图片。 <strong>基于媒体查询</strong> 的资源选择侧重于对不同的屏幕选择不同内容的图片。</p><p>比如在移动设备上只显示头像，在大屏幕显示器上则显示完整的大图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 640px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar-with-background.png&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 640px)&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;smiling harttle&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>基于媒体查询的选择在 HTML5 标准中称为 <a href="https://html.spec.whatwg.org/multipage/images.html#art-direction">Art Direction</a>。</p><h3 id="响应式：基于图片格式"><a href="#响应式：基于图片格式" class="headerlink" title="响应式：基于图片格式"></a>响应式：基于图片格式</h3><p><code>&lt;source&gt;</code> 元素的 <code>type</code> 属性可以指定图片格式，浏览器可以选择自己支持的去下载。 基于图片格式的选择可以用于性能优化，有些格式我们知道压缩比非常好但并非所有浏览器都支持。 这时就可以提供多种格式的图片让浏览器来选择。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.webp&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/webp&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;avatar.jxr&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/vnd.ms-photo&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;avatar.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;150&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，如果用户代理支持 WebP 就会选择第一个 <code>&lt;source&gt;</code> 元素。 如果不支持 WebP，但支持 JPEG XR 就会选择第二个 source 元素。 如果这两种都不支持，就会选择 img 元素。（这个例子来自 <a href="https://html.spec.whatwg.org/multipage/images.html#image-format-based-selection">HTML Standard</a>）</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://harttle.land/2018/05/30/responsive-img-picture.html">正确使用 HTML5 标签：img, picture, figure 的响应式设计</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;img&quot;&gt;&lt;a href=&quot;#img&quot; class=&quot;headerlink&quot; title=&quot;img&quot;&gt;&lt;/a&gt;img&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="笔记本" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="笔记本" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    <category term="css" scheme="http://example.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>4个你从未听说过的强大的 JavaScript 运算符</title>
    <link href="http://example.com/index.php/archives/339/"/>
    <id>http://example.com/index.php/archives/339/</id>
    <published>2021-06-06T13:43:41.000Z</published>
    <updated>2021-06-06T13:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>你有没有花一个下午的时间浏览过 Mozilla 文档？如果你有，你会很清楚网上有很多关于 JavaScript 的信息。这使得人们很容易忽略一些不同寻常的 JavaScript 操作符。</p><p>然而，仅仅因为这些操作符不常见并不意味着它们不强大！它们在语法上看起来都很相似，但是当它们以不同的方式工作时，请务必阅读它们。</p><p>让我们开始吧！</p><blockquote><p>译者注：nullish 代表 null 或者 undefined</p></blockquote><h2 id="1-操作符"><a href="#1-操作符" class="headerlink" title="1. ?? 操作符"></a>1. ?? 操作符</h2><p>在 JavaScript 中，<code>??</code> 操作符被称为<code>nullish</code> 合并操作符。如果第一个参数不是 <code>null/undefined</code>，这个运算符将返回第一个参数，否则，它将返回第二个参数。让我们看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">null</span> ?? <span class="hljs-number">5</span> <span class="hljs-comment">// =&gt; 5</span><br><span class="hljs-number">3</span> ?? <span class="hljs-number">5</span> <span class="hljs-comment">// =&gt; 3</span><br></code></pre></td></tr></table></figure><p>当为一个变量分配默认值时，JavaScript 开发人员传统上依赖于逻辑 <code>OR</code> 操作符，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> prevMoney = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> currMoney = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> noAccount = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> futureMoney = -<span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moneyAmount</span>(<span class="hljs-params">money</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> money || <span class="hljs-string">`You currently do not own an account in the bank`</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(moneyAmount(prevMoney)) <span class="hljs-comment">// =&gt; 1</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(currMoney)) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(noAccount)) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br><span class="hljs-built_in">console</span>.log(moneyAmount(futureMoney))<span class="hljs-comment">//  =&gt; -1</span><br></code></pre></td></tr></table></figure><p>上面我们创建了一个函数 <code>moneyAmount</code>，负责返回用户的当前余额。我们使用了 <code>||</code> 操作符来识别没有帐户的用户。 当 money 为 0 或者 null 的时候都会返回在当前银行没有这个账户，但是实际上账户是可能为 0 的 。在上面的示例中， <code>||</code> 操作符将 0 视为假值，因此识别不出来我们的用户拥有一个 0 美元的帐户。让我们通过使用 nullish 合并操作符来解决这个问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> currMoney = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> noAccount = <span class="hljs-literal">null</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">moneyAmount</span>(<span class="hljs-params">money</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> money ?? <span class="hljs-string">`You currently do not own an account in the bank`</span><br>&#125;<br> moneyAmount(currMoney) <span class="hljs-comment">// =&gt; 0</span><br> moneyAmount(noAccount) <span class="hljs-comment">// =&gt; `You currently do not own an account in the bank`</span><br></code></pre></td></tr></table></figure><p><strong>总结一下，<code>??</code> 操作符允许我们分配默认值，同时忽略像 0 和空字符串这样的假值。</strong></p><h2 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2. ??= 操作符"></a>2. <code>??=</code> 操作符</h2><p><code>??=</code> 又称为逻辑 nullish 赋值操作符，与我们之前学到的内容密切相关。让我们看看它们是如何联系在一起的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-literal">null</span><br><span class="hljs-keyword">var</span> y = <span class="hljs-number">5</span><br><br><span class="hljs-built_in">console</span>.log(x ??= y) <span class="hljs-comment">// =&gt; 5</span><br><span class="hljs-built_in">console</span>.log(x = (x ?? y)) <span class="hljs-comment">// =&gt; 5</span><br></code></pre></td></tr></table></figure><p>只有当前值为 null 或 undefined 时，此赋值运算符才会分配新值。上面的例子强调了这个操作符如何实质上是 nullish 赋值的语法糖。接下来，让我们看看这个操作符与默认参数的区别。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameSettingsWithNullish</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  options.gameSpeed ??= <span class="hljs-number">1</span><br>  options.gameDiff ??= <span class="hljs-string">&#x27;easy&#x27;</span><br>  <span class="hljs-keyword">return</span> options<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameSettingsWithDefaultParams</span>(<span class="hljs-params">gameSpeed=<span class="hljs-number">1</span>, gameDiff=<span class="hljs-string">&#x27;easy&#x27;</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;gameSpeed, gameDiff&#125;<br>&#125;<br><br>gameSettingsWithNullish(&#123;<span class="hljs-attr">gameSpeed</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">gameDiff</span>: <span class="hljs-literal">null</span>&#125;) <span class="hljs-comment">// =&gt; &#123; gameSpeed: 1, gameDiff: &#x27;easy&#x27; &#125;</span><br>gameSettingsWithDefaultParams(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// =&gt; &#123; gameSpeed: null, gameDiff: null &#125;</span><br></code></pre></td></tr></table></figure><p>上面的函数处理空值的方式有一个显著的不同。默认参数将使用 null 参数覆盖默认值，nullish 赋值操作符不会。默认参数和 nullish 赋值都不会覆盖未定义的值。</p><h2 id="3-操作符"><a href="#3-操作符" class="headerlink" title="3. ?. 操作符"></a>3. <code>?.</code> 操作符</h2><p>可选的链接操作符 <code>?.</code> 允许开发人员读取深度嵌套在一个对象链中的属性值，而不必沿途显式验证每个引用。当引用为 null 时，表达式停止计算并返回 <code>undefined</code>，让我们来看一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> travelPlans  = &#123;<br>  <span class="hljs-attr">destination</span>: <span class="hljs-string">&#x27;DC&#x27;</span>,<br>  <span class="hljs-attr">monday</span>: &#123;<br>    <span class="hljs-attr">location</span>: <span class="hljs-string">&#x27;National Mall&#x27;</span>,<br>    <span class="hljs-attr">budget</span>: <span class="hljs-number">200</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> tuesdayPlans = travelPlans.tuesday?.location;<br><span class="hljs-built_in">console</span>.log(tuesdayPlans) <span class="hljs-comment">// =&gt; undefined</span><br></code></pre></td></tr></table></figure><p>现在，让我们把迄今为止所学到的一切结合起来，把星期二添加到我们的新旅行计划中去吧！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPlansWhenUndefined</span>(<span class="hljs-params">plans, location, budget</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (plans.tuesday?.location === <span class="hljs-literal">undefined</span>) &#123;<br>    <span class="hljs-keyword">var</span> newPlans = &#123;<br>      plans,<br>      <span class="hljs-attr">tuesday</span>: &#123; <span class="hljs-attr">location</span>: location ?? <span class="hljs-string">&quot;Park&quot;</span>, <span class="hljs-attr">budget</span>: budget ?? <span class="hljs-number">200</span> &#125;,<br>    &#125;;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    newPlans ??= plans; <span class="hljs-comment">//will only override if newPlans is undefined</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Plans have already been added!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> newPlans;<br>&#125;<br><br><span class="hljs-keyword">var</span> newPlans = addPlansWhenUndefined(travelPlans, <span class="hljs-string">&quot;Ford Theatre&quot;</span>, <span class="hljs-literal">null</span>);<br><span class="hljs-built_in">console</span>.log(newPlans) <span class="hljs-comment">// =&gt; &#123; plans:</span><br>                  <span class="hljs-comment">//&#123; destination: &#x27;DC&#x27;,</span><br>                  <span class="hljs-comment">// monday: &#123; location: &#x27;National Mall&#x27;, budget: 200 &#125; &#125;,</span><br>                  <span class="hljs-comment">// tuesday: &#123; location: &#x27;Ford Theatre&#x27;, budget: 200 &#125; &#125;</span><br><br>newPlans = addPlansWhenUndefined(newPlans, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// logs =&gt; Plans have already been added!</span><br>                                                      <span class="hljs-comment">// returns =&gt; newPlans object</span><br></code></pre></td></tr></table></figure><p>我们现在已经创建了一个函数，该函数将计划添加到当前没有嵌套属性 <code>tuesday.location</code> 的对象中。我们还使用 nullish 操作符提供默认值。这个函数将接受错误的值，如“0”作为有效的参数。这意味着我们的预算可以设置为零，没有任何错误。</p><h2 id="4-操作符"><a href="#4-操作符" class="headerlink" title="4. ? 操作符"></a>4. <code>?</code> 操作符</h2><p>三元运算符 <code>?</code> 有三个操作数: 一个条件，一个条件为真时执行的表达式，以及一个条件为假时执行的表达式。让我们看看它是如何运作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkCharge</span>(<span class="hljs-params">charge</span>) </span>&#123;<br><span class="hljs-keyword">return</span> (charge &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&#x27;Ready for use&#x27;</span> : <span class="hljs-string">&#x27;Needs to charge&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(checkCharge(<span class="hljs-number">20</span>)) <span class="hljs-comment">// =&gt; &#x27;Ready for use&#x27;</span><br><span class="hljs-built_in">console</span>.log(checkCharge(<span class="hljs-number">0</span>)) <span class="hljs-comment">// =&gt; &#x27;Needs to charge&#x27;</span><br></code></pre></td></tr></table></figure><p>如果你花了一些时间研究 JavaScript，你可能以前见过三元运算符。然而，你知道三元运算符可以用于变量赋值吗？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> budget = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> transportion = (budget &gt; <span class="hljs-number">0</span>) ? <span class="hljs-string">&#x27;Train&#x27;</span> : <span class="hljs-string">&#x27;Walking&#x27;</span><br><span class="hljs-built_in">console</span>.log(transportion) <span class="hljs-comment">// =&gt; &#x27;Walking&#x27;</span><br></code></pre></td></tr></table></figure><p>我们甚至可以用它来复制 nullish 赋值的行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">6</span><br><span class="hljs-keyword">var</span> x = (x !== <span class="hljs-literal">null</span> || x !== <span class="hljs-literal">undefined</span>) ? x : <span class="hljs-number">3</span><br><span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// =&gt; 6</span><br></code></pre></td></tr></table></figure><p>现在让我们通过创建一个函数来泛化这种行为！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nullishAssignment</span>(<span class="hljs-params">x,y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (x == <span class="hljs-literal">null</span> || x == <span class="hljs-literal">undefined</span>) ? y : x<br>&#125;<br><br><span class="hljs-keyword">var</span> x = nullishAssignment(<span class="hljs-literal">null</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// =&gt; 8</span><br><span class="hljs-keyword">var</span> y = nullishAssignment(<span class="hljs-number">4</span>,<span class="hljs-number">8</span>) <span class="hljs-comment">// =&gt; 4</span><br></code></pre></td></tr></table></figure><p>在结束之前，让我们使用三元运算符来重构前面示例中的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addPlansWhenUndefined</span>(<span class="hljs-params">plans, location, budget</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> newPlans =<br>    plans.tuesday?.location === <span class="hljs-literal">undefined</span><br>      ? &#123;<br>          ...plans,<br>          <span class="hljs-attr">tuesday</span>: &#123; <span class="hljs-attr">location</span>: location ?? <span class="hljs-string">&quot;Park&quot;</span>, <span class="hljs-attr">budget</span>: budget ?? <span class="hljs-number">200</span> &#125;,<br>        &#125;<br>      : <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Plans have already been added!&quot;</span>);<br>  newPlans ??= plans;<br>  <span class="hljs-keyword">return</span> newPlans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们现在已经了解了这些操作符的基本原理。如果您对构建这些示例感到鼓舞，请在这里了解更多关于这些操作符的信息。Cheers ！</p><blockquote><p>原文地址：<a href="https://javascript.plainenglish.io/4-powerful-javascript-operators-youve-never-heard-of-487df37114ad">https://javascript.plainenglish.io/4-powerful-javascript-operators-youve-never-heard-of-487df37114ad</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你有没有花一个下午的时间浏览过 Mozilla 文档？如果你有，你会很清楚网上有很多关于 JavaScript 的信息。这使得人们很容易忽略一些不同寻常的 JavaScript 操作符。&lt;/p&gt;
&lt;p&gt;然而，仅仅因为这些操作符不常见并不意味着它们不强大！它们在语法上看起来都</summary>
      
    
    
    
    <category term="译文" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/"/>
    
    <category term="前端" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="http://example.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>聊聊关于如何选择offer</title>
    <link href="http://example.com/index.php/archives/337/"/>
    <id>http://example.com/index.php/archives/337/</id>
    <published>2021-05-27T00:57:00.000Z</published>
    <updated>2021-06-06T13:51:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>前阵子我们组大量招人，看到一些候选人拿了好几个 offer 摇摆不定，一直在纠结；也有不少读者私下跟我询问怎么选择；另外就是知乎上，我回答了一个 蚂蚁和字节怎么选的问题，阅读量比较高，所以也经常有人问我这个问题。</p><p>所以想写篇文章来聊一聊这个问题。</p><blockquote><p>最多的就是字节和阿里怎么选 ♀️</p></blockquote><p>我去年换工作的时候也拿了好几个 offer (蚂蚁、字节、滴滴、拼多多、酷家乐)，当时也有过一阵子的纠结，觉得这个公司这里好，那个公司那里好，现在回想起来有点幼稚。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我之前呆的公司是蘑菇街，一家比较年轻的公司，压力不大，每天基本认认真真敲个四个小时左右代码就可以完成工作，每天晚上大概 7 8 点下班。</p><p>在蘑菇街主要是做平台服务，主要是负责一些运营的后台系统，所以不存在着倒排需求，基本上都是正排，在完成自己的工作以后，就有大量的时间去学习一些新知识。</p><p>但是由于业务比较简单，所以很多新知识无法真正用到项目里，感觉自己的上限有所限制，所以一直有一个想去大公司，可以有更多可能的公司。</p><p>具体原因见： <a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p><h2 id="我是怎么选的"><a href="#我是怎么选的" class="headerlink" title="我是怎么选的"></a>我是怎么选的</h2><blockquote><p>以下内容来自于我在知乎的回答：蚂蚁金服 VS 字节跳动的 Offer 怎么选择? - 桃翁的回答 - 知乎<br><a href="https://www.zhihu.com/question/394340089/answer/1251264179" title="https://www.zhihu.com/question/394340089/answer/1251264179">https://www.zhihu.com/question/394340089/answer/1251264179</a></p></blockquote><p>我之前也有过这样的迷惑，也是最近吧，由于公司裁人，逼得我不得不去面试，面过了五家不差的公司(蚂蚁、字节、拼多多、滴滴、酷家乐) ，除了拼多多都是杭州的，因为我目前是在杭州的，所以杭州岗位比较多。</p><p>当时在选 offer 的时候令我比较纠结的也是字节和蚂蚁，最后选择了蚂蚁，说一下我的选择逻辑吧，希望能给你一些参考。</p><p>1 . 薪资方面。阿里在 P7 以前的薪资是没办法和字节比的，理论上字节待遇会比蚂蚁好，我也是，但是很多人在字节入职即巅峰，涨薪比较少，我了解过，字节绩效好或者晋升才有涨薪，如果绩效仅仅是达到期望基本不会涨薪，但是阿里会有普调，所以如果干几年薪资应该会差不多。另外薪资方面就是年终奖的问题，据我了解阿里的激励会比字节激励的比较多，对于 3.75 加 高潜的同学年终奖将异常的高，而且还会有股票和期权。</p><p>base 上字节是好于蚂蚁，年终奖蚂蚁好于字节，总体薪资我觉得字节还是会优于蚂蚁的，毕竟字节还有加班费和房补。</p><ol start="2"><li><p>背书方面。蚂蚁背靠阿里这座大山，我征询过我身边值得相信的一些大佬，大部分人还是觉得蚂蚁的背书是要大于字节的，就是觉得蚂蚁比字节难进，以后从蚂蚁出来和字节出来，蚂蚁更有优势一点。</p></li><li><p>团队方面。蚂蚁杭州总部，字节是分部。当时我在的团队 leader 是在北京的，我是觉得老板毕竟在北京，虽然每个月会来分部带两天，但是总归还是没有老板在身边这么了解自己，所以在绩效方面我觉得蚂蚁是有优势的。另外我在蚂蚁的老板是我上一家公司的老板，比较熟悉，也给蚂蚁加了不少分。</p></li><li><p>加班程度。蚂蚁很累，累的程度不必字节的大小周差。</p></li></ol><p>我的回答可能倾向于蚂蚁一点，因为我的最终选择是选择了蚂蚁，所以会觉得蚂蚁更好，因为我工作年限也不到 2 年，所以更看重<strong>成长和背书</strong>，我觉得在蚂蚁带来的成长会比字节多。如果仅仅看重薪资的话可能直接选 拼多多 了。</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>我们往往活在对未知的恐惧，害怕对未来预测的偏差，所以才不知道如何选择。我们往往什么都想要，或者说什么都不舍得放弃，所以才不知道如何选择。其实，<strong>只要我们清楚自己最想要的是什么，做减法就可以了</strong>。必须做减法，才能做选择。</p><p>可以这么去做：</p><ol><li>行业、公司、团队、文化、城市、老板、工作内容、工作强度…把你想得到的维度都列下来</li><li>然后就开始划除，一个个划掉。</li><li>最后剩下的那一到三个就是你真心不能放弃的，看看哪个机会最符合或接近符合，就是哪个。</li></ol><p><strong>每个人的境况不同，能做出的选择自然不同。所以，不要轻易地去为别人做决定，随意地去评价别人的决定。毕竟，你不傻，别人也不傻。</strong></p><p><strong>无论今年几岁，我们都要尽量做出属于自己的选择，即使这个选择不完全是自己的真心，但真心一定要有。</strong></p><h2 id="一些忠告"><a href="#一些忠告" class="headerlink" title="一些忠告"></a>一些忠告</h2><ul><li><strong>自己想要什么最重要。</strong></li><li><strong>刚开始工作 base 差个两三 k 不重要。</strong></li><li><strong>工作不久的成长很重要。</strong></li><li><strong>不要完全听别人的，包括你心中的大佬，别人的意见只能当做参考，不能作为答案。</strong></li><li><strong>选了就不要后悔，因为说不定其他选择也跟你想象的不一样。</strong></li><li>如果能有多个选择，证明你在这个行业还是比较优秀的，但是也<strong>不要骄傲，当你到了跟你一样的公司去的时候，你会发现周边比你优秀的人不要太多。</strong></li></ul><p>最后希望每个人都能拿到满意的 offer，选择自己最想去的公司。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/27342350" title="Offer 怎么选？这绝对是个问题。">Offer 怎么选？这绝对是个问题。</a></li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前阵子我们组大量招人，看到一些候选人拿了好几个 offer 摇摆不定，一直在纠结；也有不少读者私下跟我询问怎么选择；另外就是知乎上，我回答了一个 蚂蚁和字节怎么选的问题，阅读量比较高，所以也经常有人问我这个问题。&lt;/p&gt;
&lt;p&gt;所以想写篇文章来聊一聊这个问题。&lt;/p&gt;
&lt;b</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="职场" scheme="http://example.com/tags/%E8%81%8C%E5%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>如何应用 SOLID 原则在 React 中整理代码之开闭原则</title>
    <link href="http://example.com/index.php/archives/336/"/>
    <id>http://example.com/index.php/archives/336/</id>
    <published>2021-05-24T00:27:43.000Z</published>
    <updated>2021-05-24T00:27:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID 是一套原则。它们主要是关心代码质量和可维护性的软件专业人员的指导方针。</p><p>React 不是面向对象，但这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。</p><p>在前一篇文章中，我们讨论了单一责任原则。今天，我们将讨论 SOLID 的第二个原则: 开闭原则。</p><h2 id="本系列其他文章"><a href="#本系列其他文章" class="headerlink" title="本系列其他文章"></a>本系列其他文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/oOcoy5rJwqH939MIOrgaiA">如何应用 SOLID 原则在 React 中整理代码之单一原则</a></li></ul><h2 id="什么是开闭原则？"><a href="#什么是开闭原则？" class="headerlink" title="什么是开闭原则？"></a>什么是开闭原则？</h2><blockquote><p>Robert c. Martin 认为这个原则是面向对象设计最重要的原则。但他不是第一个定义这个概念的人。Bertrand Meyer 于1988年在他的《面向对象软件构造》一书中写到了这一点。他解释了开放/封闭原则:</p><p>软件实体(类、模块、功能等)应该对扩展开放，但对修改关闭。</p></blockquote><p>这个原则告诉您以这样一种方式来编写代码，即您<strong>能够在不更改现有代码的情况下添加其他功能。</strong></p><p>让我们看看我们在哪里可以应用这个原则。</p><h2 id="让我们从一个例子开始"><a href="#让我们从一个例子开始" class="headerlink" title="让我们从一个例子开始"></a>让我们从一个例子开始</h2><p>假设我们有一个 <code>User</code> 组件，其中我们传递用户的详细信息，这个类的主要目的是显示该特定用户的详细信息。</p><p>这是一个很简单的开始。但是我们的生活并不是那么简单。几天后，我们的经理告诉我们系统中有三种类型的用户: <code>SuperAdmin</code>、 <code>Admin</code> 等等。</p><p>它们每个都有不同的信息和功能。</p><h2 id="一个糟糕的解决方案"><a href="#一个糟糕的解决方案" class="headerlink" title="一个糟糕的解决方案"></a>一个糟糕的解决方案</h2><p>第一个也是显而易见的解决方案：在组件中包含一个条件，并根据不同的用户类型呈现不同的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> User = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Name: &#123;user.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Email: &#123;user.email&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#123;</span><br><span class="xml">            user.type === &#x27;SUPER_ADMIN&#x27; &amp;&amp;</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Details about super admin<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#125;</span><br><span class="xml">        &#123;</span><br><span class="xml">            user.type === &#x27;ADMIN&#x27; &amp;&amp;</span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> Details about admin<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">        &#125;</span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>你知道这里出了什么问题吗？</p><p>首先，我们的代码现在是凌乱的。</p><p>其次，如果我们需要其他类型的用户怎么办？</p><p>然后，我们需要进入 User.js，为特定类型的用户添加另一个条件。</p><p>这明显违反了开闭原则，因为我们不允许更改 User 组件内部的代码。</p><h2 id="解决方案是什么？"><a href="#解决方案是什么？" class="headerlink" title="解决方案是什么？"></a>解决方案是什么？</h2><p>在这个场景中我们可以应用两种主要的技术:</p><ol><li>高阶组件(HOC)</li><li>组件组合(Component composition)</li></ol><p>在可能的情况下，最好采用第二种方法，但是在某些情况下，有必要使用 HOC。</p><p>现在，我们将使用 Facebook 推荐的一种技术，称为<strong>组件组合</strong>。</p><h2 id="让我们创建单独的用户组件"><a href="#让我们创建单独的用户组件" class="headerlink" title="让我们创建单独的用户组件"></a>让我们创建单独的用户组件</h2><p>现在，我们需要以这样一种方式设计代码，即不需要在 <code>User.js</code> 组件中添加条件。让我们为 <code>SuperAdmin</code> 创建一个单独的组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;User&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SuperAdmin = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> This is super admin user details<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，另一个是针对 <code>Admin</code> 用户的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;User&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./User&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> Admin = <span class="hljs-function">(<span class="hljs-params">&#123;user&#125;</span>) =&gt;</span> &#123;<br><br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">User</span> <span class="hljs-attr">user</span>=<span class="hljs-string">&#123;user&#125;</span> /&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> This is admin user details<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们的 App.js 文件变成了:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> Admin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Admin&#x27;</span><br><span class="hljs-keyword">import</span> SuperAdmin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./SuperAdmin&#x27;</span><br><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span> = (<span class="hljs-params"></span>) =&gt;</span>&#123;<br>  <br>  <span class="hljs-keyword">const</span> user = &#123;&#125;<br>  <br>  <span class="hljs-keyword">const</span> userByTypes = &#123;<br>    <span class="hljs-string">&#x27;admin&#x27;</span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Admin</span> /&gt;</span></span> ,<br>    <span class="hljs-string">&#x27;superadmin&#x27;</span> : <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SuperAdmin</span> /&gt;</span></span><br>  &#125;<br>  <br>  <span class="hljs-keyword">return</span> &lt;div&gt;<br>    &#123;userByTypes[<span class="hljs-string">`<span class="hljs-subst">$&#123;user.type&#125;</span>`</span>]&#125;<br>  &lt;div/&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以根据需要创建尽可能多的用户类型。我们针对特定用户的逻辑是封装的，因此我们不需要为了任何额外的修改而重新检查代码。</p><p>有些人可能会说，我们正在不必要地增加文件数量。当然，您可以暂时保持原样，但是随着应用程序的复杂性增加，您肯定会感到痛苦。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>SOLID 是一套原则。它们并不是强制性的，您必须应用于每个场景。作为一个经验丰富的开发人员，您应该在代码长度和可读性之间找到一个很好的平衡。</p><p>要过分执着于这些原则。事实上，有一句名言可以解释这些情况:</p><blockquote><p>Too Much SOLID</p></blockquote><p>所以知道这些原则是好的，但是你必须保持平衡。对于一个或两个额外的字段，您可能不需要这些组合，但是将它们分开肯定会有长远的帮助。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解这些原则会让你走很长的路，因为在一天结束的时候，一段好的代码才是最重要的，而且没有单一的方法来做事情。</p><blockquote><p>本文为译文，原文链接：<a href="https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40">https://betterprogramming.pub/applying-the-open-closed-principle-to-write-clean-react-components-4e4514963e40</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SOLID 是一套原则。它们主要是关心代码质量和可维护性的软件专业人员的指导方针。&lt;/p&gt;
&lt;p&gt;React 不是面向对象，但这些原则背后的主要思想可能是有帮助的。在本文中，我将尝试演示如何应用这些原则来编写更好的代码。&lt;/p&gt;
&lt;p&gt;在前一篇文章中，我们讨论了单一责任原则</summary>
      
    
    
    
    <category term="译文" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/"/>
    
    <category term="前端" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>理清业务团队开发和业务的关系</title>
    <link href="http://example.com/index.php/archives/335/"/>
    <id>http://example.com/index.php/archives/335/</id>
    <published>2021-05-16T02:16:31.000Z</published>
    <updated>2021-05-16T10:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于开发是否应该深入了解业务，听到两种我觉得不正确的类型：</p><ol><li>「我是开发，我就做好开发就行了，业务交给产品和运营同学」。<strong>不懂业务，完全不想了解型。</strong></li><li>「懂业务之后就可以跟产品 PK 了，方便砍需求」。<strong>懂业务，目的不正确型。</strong></li></ol><p>我的观点是要想当一个优秀的开发者，<strong>必须懂业务，不是为了跟产品 PK，而是为了预判未来的发展方向，好指导自己写的代码可以适应未来更久的时间。</strong></p><h2 id="懂业务，目的不正确型。"><a href="#懂业务，目的不正确型。" class="headerlink" title="懂业务，目的不正确型。"></a><strong>懂业务，目的不正确型。</strong></h2><p>作为一个开发，不知道多少人经常会在耳边听到这么一句话：<strong>多了解业务，多了解业务</strong>。</p><p>但是大部分情况下并没有告诉你为啥要了解业务。</p><p>可能有些人心里会有这么一个答案：懂了业务可以在需求评审的时候可以<strong>跟产品 PK</strong>，指出他的需求不合理，然后给出一个合理的方案，这就是你对于业务的价值，然后就可以体现你的业务思考了；另外对于你觉得不合理的需求，还可以砍掉。</p><p>这是我听到最多的关于为什么开发要懂业务的观点了，我以前也是这么认为的，但是当我真正的作为一个业务 owner 之后，逼得我不得不去了解业务，我才觉得这个观点不完全对，方向都是错的。</p><p>上面观点的<strong>核心目标就是跟产品 PK</strong>，把产品作为开发的敌人去看待。现在网上很多这样的调侃，产品和程序员是对立的。</p><p><strong>在产品的眼里，程序员天生就是爱砍需求。</strong></p><p><img src="http://imgs.taoweng.site/2021-05-16-101200.jpg" alt="砍需求"></p><p><strong>而在程序员的眼里，会因为不会砍需求被老板教育，不要啥需求都接，要学会砍需求。</strong></p><p><img src="http://imgs.taoweng.site/2021-05-16-101218.jpg" alt="打架"></p><p>实际上，懂业务不是为了去指导产品设计，<strong>而是为了预判未来的发展方向好指导自己写的代码可以适应未来更久的时间。</strong></p><p>懂了业务之后是去发现<strong>前端的“价值点”</strong>，不是为了跟产品 PK。。。。</p><p>你如果去指导产品做产品，反过来想想如果让产品指导你做开发，那能靠谱吗?</p><p>我很赞同玉伯说的专业度的问题，作为开发就是要在开发的专业度上表现出来，效率让产品业务都觉得不可思议。而不是让你的产品、业务能力表现出来让他们觉得不可思议(不是不行，但是这样很难，先把自己专业的搞好再说)。</p><h2 id="不懂业务，完全不想了解型。"><a href="#不懂业务，完全不想了解型。" class="headerlink" title="不懂业务，完全不想了解型。"></a><strong>不懂业务，完全不想了解型。</strong></h2><p>另外还有一些是基本不怎么了解业务，就喜欢专研技术，这种想法基本是工作年限不超过三年的同学。刚毕业，对业务没有什么感知，觉得做技术的技术才是王道，整天喜欢研究各种新技术，处于一种被动接需求的状态。</p><p>这种情况就很容易在晋升的时候无法说清楚业务价值，到底自己做的东西有什么用，给公司带来了什么价值，因为在做需求的时候本来没有去思考过业务价值，所以没办法形成闭环，仅仅只是零散的需求。</p><p>实际上，我们应该这样做，在业务的背景之下，我们可以主动的<strong>发现问题、定义问题、解决问题、优化效果，拿到结果。</strong>这才是创作个人业绩的正确路线。</p><p>如果不懂业务，怎么将技术放到业务里去？不放到业务里去怎么体现技术的价值？</p><p>你不能光讲我做了一个什么东西，这个东西多么多么好，这个业务价值如果没有体现出来，那就是没用的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面分析了两种思维模式的差别，以及我觉得正确的思考方向。</p><p>作为一个在业务团队的开发者，我们做一件事的时候，需要时刻提醒自己，要想清楚三个问题：</p><ol><li><strong>弄清楚，为什么做这件事？做这件事的价值是什么？</strong></li><li><strong>去思考，如何做这件事？</strong></li><li><strong>完成后的产出是什么？明确衡量标准。</strong></li></ol><p>你们觉得作为一个业务团队的开发，业务和技术的关系应该是什么样的呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于开发是否应该深入了解业务，听到两种我觉得不正确的类型：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;「我是开发，我就做好开发就行了，业务交给产品和运营同学」。&lt;strong&gt;不懂业务，完全不想了解型。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;「懂业务之后就可以跟产品 PK 了，方便砍需求」。</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
    <category term="观点与感想" scheme="http://example.com/tags/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>在蚂蚁工作是一种什么样的体验(一)</title>
    <link href="http://example.com/index.php/archives/333/"/>
    <id>http://example.com/index.php/archives/333/</id>
    <published>2021-03-13T06:49:27.000Z</published>
    <updated>2021-03-13T14:53:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>大家好，我是桃翁！</strong><br>之前有小伙伴留言让我聊聊「希望聊一些在大厂工作是什么体验，想听如何融入，如何适应，如何成长的规划，遇到过的哪些比较棘手的问题和怎么处理的，期待」。</p><p>他这里这么多问题，我准备每个问题都写一篇文章来聊，首先咱们要聊的就是「大厂的工作体验」。</p><h2 id="身边牛人多"><a href="#身边牛人多" class="headerlink" title="身边牛人多"></a>身边牛人多</h2><p>可能很多想去大厂的同学，第一驱动力觉得大厂肯定很多大佬，然后进去了可以带带自己。</p><p>其实这句话不全对，也别抱太大希望，进来了可能跟你的想法是不一样的。<br>我的体感是：前半句是对的，大厂里确实很多牛人，但是不会带你的，或者说不是你想象中那么带。</p><p>在阿里这边一个新同学刚进来的时候，会在组内分配一个师兄，来协助你顺利度过试用期。但是不是那种事无巨细的关注你的那种，大部分时间师兄每天也很忙，一个新人来了还要帮你解决问题，所以师兄就会更忙了，所以师兄主要是帮你解答一些问题。</p><p>再说说身边其他的牛人，牛可以很多方面的：</p><p>比如 <strong>学校牛</strong>，在杭州这边浙大的比较多，我们组才 12 个人就有三个浙大的，还有在国外上大学的。</p><p><strong>网红</strong>，可以接触到很多之前只能在知乎、或者一些大会里才能看到或者听说的一些大牛，来了之后就可以见到，甚至面对面交流，每次交流都会受益匪浅，比如我在蚂蚁体验技术部就可以接触到玉伯、偏右这种超级前端网红。</p><p><strong>技术牛，</strong> 不管是 P5、P6、P7 哪个层级的，你都会发现每个人在一个甚至多个方面技术很厉害，说两个我们组的 P5，工作才一年多，早已经是 React 或者微前端方面的专家了，更高层级的那就更不用说了。</p><p>总之，大厂里有非常多的优秀的人，意味着你有很多可以学习的榜样，如果有一些技术上的问题，以前可能只能在开源项目的 issue 上提问，现在你可以通过钉钉甚至直接面对面的进行交流。</p><p>但是我还是秉承着一个观点，<strong>身边的人优秀，并不意味这自己优秀，也没人会主动带着你变成优秀的人，需要自己主动去跟他们学习，让自己成为别人眼中优秀的人。</strong></p><h2 id="做项目成就感强"><a href="#做项目成就感强" class="headerlink" title="做项目成就感强"></a>做项目成就感强</h2><p>既然是大厂，不管是员工和用户相对都比较的多，做的东西反馈也会很多，不管是好的还是差的，都能感觉到有很多用户在使用，能感觉自己再为这么多人服务，能获得价值感。</p><p>像我现在做的项目虽然是给内部小二(小二就是内部员工)用的，但是每天 UV 也有好几千，PV 也是上百万的，这跟我之前在上家公司做的内部系统就不太一样，之前做的东西不管好还是不好，没有什么人反馈，所以总是在找需求做，做出来也不知道有价值，存在感就比较低。</p><p>如果能做 C 端用户的项目，比如像五福、双十一、双十二这种运营活动，虽然过程很艰苦，但是我相信做完了之后一定是满满的自豪感。</p><p>做项目的成就感就来自于给自己、给别人带来了价值，能服务别人，如果你感受不到这份价值，这个项目估计不久就凉了。。。</p><h2 id="压力大"><a href="#压力大" class="headerlink" title="压力大"></a>压力大</h2><p>我以前在蘑菇街的时候每天正常作息上下班，基本没在工作上感受到过压力。</p><p>但是在蚂蚁无处不在的压力，有时会把自己压得喘不过气，不过大部分时候会把压力当做动力，努力向前。</p><p><strong>一方面来自于项目压力</strong>，据我了解，在蚂蚁的业务团队相对于技术团队来说会忙一些。我们组现在主要是做业务，我们这边发布频率基本上一周一个迭代，一个迭代里可能还包含好几个需求，布频率极其高，项目周期又都很紧。</p><p>偶尔还有项目紧急到需要倒排工期，就是不管你怎么搞，就是要在某一天上线。</p><p><strong>另外一方面来自于周围同事压力</strong>，前面也说了，周围的牛人很多，每个人身上你都能发现比自己优秀的地方，比自己级别低的、一个级别的要想着不要被别人超越，比自己级别高的，需要考虑怎么才能跟他们一样优秀。<br>对于项目压力大的正反馈就是逼着自己去做一些可以提效的技术方案，对于周围同事压力正反馈就是逼着自己去像他们学习，让自己变得越来越优秀。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次主要聊的是环境和项目上的感受，下一篇会介绍一些关于技术上的一些体验。如果你之前没呆过大厂，你可以聊聊你想象的大厂是什么样子。如果你之前在待过，或者现在正在大厂里，可以聊聊你的感受是什么。</p><p>同一个环境可能由于自己的心态不同，感受也会有差别，我只是分享我的感受，希望给你带来帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;大家好，我是桃翁！&lt;/strong&gt;&lt;br&gt;之前有小伙伴留言让我聊聊「希望聊一些在大厂工作是什么体验，想听如何融入，如何适应，如何成长的规划，遇到过的哪些比较棘手的问题和怎么处理的，期待」。&lt;/p&gt;
&lt;p&gt;他这里这么多问题，我准备每个问题都写一篇文章来聊，首</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="蚂蚁" scheme="http://example.com/tags/%E8%9A%82%E8%9A%81/"/>
    
  </entry>
  
  <entry>
    <title>MWeb 使用体验总结</title>
    <link href="http://example.com/index.php/archives/331/"/>
    <id>http://example.com/index.php/archives/331/</id>
    <published>2021-02-21T03:41:00.000Z</published>
    <updated>2021-02-21T11:43:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>工欲善其事，必先利其器。</p></blockquote><p>一个称心如意的工具会令人提升我们的效率，节省时间。今天我介绍的这款写作、记笔记软件就是：<a href="http://zh.mweb.im/"><strong>MWeb</strong></a>。</p><blockquote><p>温馨提示两点,如果这两点不太能接受的，可能下面的内容不太适合你:</p><ol><li>该软件支持苹果生态</li><li>该软件是付费软件，是买断型的，不是订阅型的。</li></ol></blockquote><p>笔者曾经写过一篇基于 typora 写作的环境配置文章：<a href="https://mp.weixin.qq.com/s/Tz3JKu_-MvZ2xXAvouoxPw">一套可以提升写作效率的写作环境配置</a></p><p>相比于 typora，我觉得 MWeb 有这三个优势：</p><ol><li><p><strong>免费的图片上传到图床的功能</strong>。 如果用 typora 图片如果要上传到图床，需要结合 iPic，iPic 是付费的，一年是 60 元，具体操作步骤可见上面的文章。MWeb 本地上传图片服务是内置到软件里的，所以这笔每年 60 元的费用可以省掉。</p></li><li><p><strong>发布服务</strong>。 支持发布到 Wordpress、支持 Metaweblog API 协议的服务、Wordpress.com、印象笔记、Blogger、Medium、Tumblr。支持 Metaweblog API 协议的服务 这个功能特别强大，后面会详细介绍。</p></li><li><p><strong>苹果整个生态都支持。</strong> 就像官网介绍的</p><blockquote><p>MWeb for Mac, iPad and iPhone<br>专业的 Markdown 写作、记笔记、静态博客生成软件</p></blockquote><p>意味着电脑，手机，平板数据是可以同步的，这点 typora 是完全不支持的。</p></li></ol><p>不过 MWeb 相对于 typora 的一个劣势就是<strong>不支持实时预览</strong>，如果实时预览是强需求的，MWeb 就不适合你了。</p><p>以上三个优势是我从 typora 转到 MWeb 的主要原因，下面我会详细介绍一下我认为 MWeb 的五大特性，希望能给你帮助。</p><h2 id="特性一：图床功能"><a href="#特性一：图床功能" class="headerlink" title="特性一：图床功能"></a>特性一：图床功能</h2><p>图片上传服务（图床）支持 Imgur、七牛云、又拍云、阿里云、腾讯云和自定义的图床服务，基本上主流的图床服务都是支持的。</p><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139024358516.jpg" alt="-w613"></p><p>我用的是七牛云的，可以免费领 10 个 G 的空间，这个我之前在<a href="https://mp.weixin.qq.com/s/Tz3JKu_-MvZ2xXAvouoxPw">「一套可以提升写作效率的写作环境配置」</a>也说过。</p><p>这功能真的是太好了，之前我用 iPic 还每年 60 元，有了这个真可以省挺多钱的。</p><p>顺便再说下这个功能对我为啥这么重要，对于我来说写一篇文章可能会发布到多个平台去，公众号、知乎、掘金等等，每个平台自己的图床是不能在其他平台访问的，所以图片这种东西最好还是放在自己的空间里。</p><h2 id="特性二：发布服务"><a href="#特性二：发布服务" class="headerlink" title="特性二：发布服务"></a>特性二：发布服务</h2><p>使用 MWeb 可以把文档发布到 Wordrpess、支持 Metaweblog API 协议的服务、印象笔记、Blogger、Medium、语雀、为知笔记等网站。</p><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139024553338.jpg" alt="-w588"></p><p>其中<strong>支持 Metaweblog API 协议的服务</strong> 是非常有用的，很多技术博客网站也都是支持 Metaweblog API 的。</p><p>下边列出国内网站中常用的 Metaweblog API 地址。</p><ul><li>CSDN： <a href="http://write.blog.csdn.net/xmlrpc/index">http://write.blog.csdn.net/xmlrpc/index</a></li><li>博客园（cnblogs)：<a href="http://www.cnblogs.com/Blog%E5%90%8D(%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D)/services/metaweblog.aspx%E3%80%82%E5%85%B6%E4%B8%AD">http://www.cnblogs.com/Blog名(你的用户名)/services/metaweblog.aspx。其中</a> Blog 名 请换为您的博客名。cnblogs 的博客后台设置，拉到最下面，也可以找到这个网址。比如说我的是 <a href="http://rpc.cnblogs.com/metaweblog/Seachal">http://rpc.cnblogs.com/metaweblog/Seachal</a> 两者网址不同，但是效果一样。</li><li>开源中国（oschina)：<a href="https://my.oschina.net/action/xmlrpc">https://my.oschina.net/action/xmlrpc</a></li><li>51cto：<a href="http://imguowei.blog.51cto.com/xmlrpc.php">http://imguowei.blog.51cto.com/xmlrpc.php</a></li><li>网易（163）：<a href="http://os.blog.163.com/word/">http://os.blog.163.com/word/</a></li><li>typecho 博客：<a href="http://xx.com/action/xmlrpc%EF%BC%8C%E5%85%B6%E4%B8%AD">http://xx.com/action/xmlrpc，其中</a> xx.com 为你的博客网址。如果 typecho 还没有进行 url rewrite，则为 <a href="http://xx.com/index.php/action/xmlrpc">http://xx.com/index.php/action/xmlrpc</a></li></ul><p>意味着你只需要按照这样设置好。<br><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139042733794.jpg" alt="-w583"></p><p>后面就可以不用把文章拷贝到其他的网站上去发布，只需要在 MWeb 里点击发布就行了。</p><h2 id="特性三：自定义预览"><a href="#特性三：自定义预览" class="headerlink" title="特性三：自定义预览"></a>特性三：自定义预览</h2><p>这个功能可以简单的理解为就是可以自己写 CSS 样式来定制主题，这个功能在 typora 里也是有的，但是这不妨碍着依然是一个非常好的功能，每个人对美的定义不一样，默认样式总有人不喜欢。</p><p>比如语雀我听好多人吐槽过就是由于颜值太低了，所以没用，其实功能还是挺强大，所以这种个性化的功能还是很重要的。</p><p>顺便说下我没用语雀作为我的主要的写作软件的主要原因就是客户端体验太差了，另外对于移动端几乎没有支持。</p><h2 id="特性四：多端支持"><a href="#特性四：多端支持" class="headerlink" title="特性四：多端支持"></a>特性四：多端支持</h2><p><img src="http://imgs.taoweng.site/mweb/2021-02-21-16139052138079.jpg" alt="-w701"></p><p>MWeb 是支持平台三件套的(电脑、手机、平台)，数据可以通过 iCloud 去存储。</p><p>这也是我入手的一个原因吧，因为我有写日记的习惯，我是那种随时想到啥就马上要记录下来的，所有有很强的移动端记笔记的需求，而且要和 PC 端同步，之前我一直用的滴答清单，因为平常做 GTD 都是用的滴答清单，刚好滴答清单之前也支持了 markdown 语法。</p><p>但是滴答清单写文档的体验还是略差了一点，基本不支持图文编排，markdown 支持得也比较弱，MWeb 很好的解决了这个痛点。</p><h2 id="特性五：静态网站"><a href="#特性五：静态网站" class="headerlink" title="特性五：静态网站"></a>特性五：静态网站</h2><p>MWeb 不仅可以记笔记，写作，还有一个卖点就是静态博客生成，这对于没有博客的同学来说确实是一个福音。</p><p><img src="https://cdn.mwebapp.cn/mwebsite/2019/12/15761345831970.jpg" alt="-w600"></p><p>这种方式其实对于静态博客来说是最好的方式了，源文件云端存储，生成的静态文件在 MWeb 里可以定制脚本发布到静态资源服务器上(比如 github page)。</p><p>写完文章之后只需要一键就可以发布。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这么多年来用过挺多笔记软件，写作软件的，给我的感受就是没有最好，只有最适合。</p><p>比如 notion 吧，功能强大，但是访问速度慢，PC 客户端和移动端基本废了；语雀吧，功能也还够用，客户端和移动端支持得也不行；typora 吧，又支持 PC 客户端；还用过有道云笔记、bear、印象笔记等等，都不能满足我的需求。</p><p>没有一个软件满足所有人的需求，还是需要根据自己的需求去挑选最合适的软件，不过可能到最后还是没有一个软件满足你的所有需求，还需要几个软件组合，我觉得这都没关系，最重要的还是写的内容，<strong>软件毕竟只是个工具，里面记的内容，你整理的过程才是最关键的</strong>。</p><p>经过这次对 MWeb 的深度体验，算满足了我大部分的需求了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个称心如意的工具会令人提升我们的效率，节省时</summary>
      
    
    
    
    
    <category term="写作" scheme="http://example.com/tags/%E5%86%99%E4%BD%9C/"/>
    
    <category term="笔记本" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    <category term="MWeb" scheme="http://example.com/tags/MWeb/"/>
    
  </entry>
  
  <entry>
    <title>桃翁2020年度总结</title>
    <link href="http://example.com/index.php/archives/326/"/>
    <id>http://example.com/index.php/archives/326/</id>
    <published>2021-01-24T11:19:06.000Z</published>
    <updated>2021-01-24T11:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2020 年真的是不平凡的一年， 疫情夺走了很多人的生命，还夺走了我的工作(公司因为疫情被迫裁员)，所以今年换了工作来到了蚂蚁，在蚂蚁的工作经历跟之前在蘑菇街完全不一样。。。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>来蚂蚁这半年我觉得在工作上的成长比我之前在蘑菇街一年半的成长都还多，经历比较丰富。</p><p>阿里一直都有拥抱变化的文化，我来大概五个月的时候就换了三个主管，经历了好几次的组织架构变动，我刚进来的时候同组的同事（之前组内大概 12 人）到现在还跟我一组的仅剩一名。</p><p>不过随着每一次的变动，我的分工也越来越清晰，从最开始哪里缺人就去哪里，再到负责一块模糊的业务线，再到一个人带着 3 个合作伙伴负责一整个业务线，再到现在有了 3 个正式加 6 个合作伙伴的阵型。</p><p>作为整个业务线的 owner 不仅要接需求还要去预测业务未来的走向，这样才能在技术上做好提前的准备，当业务真的来了，才能快速的支持。这个是我在试用期答辩的时候面试官给到我的期望，这个我在之前试用期结束后有写过。</p><p><a href="https://mp.weixin.qq.com/s/AJjyGV2NG-CyvCPWUtTLFQ">原来我是个业务性选手？？？？</a></p><p>只不过那个时候我只是觉得这个话说得很对，并没有体感，但是当我在负责整块业务的，以及带着一群人在做的期间，作为业务 owner 必须得去思考这些了，因为我们这里业务发展得很快，虽然我们业务团队成员变多了，但是需求也越来越多，所以如果不提前去做一些业务上的预测，技术上的沉淀，当业务发展再快点，需求再多一些我们目前的这些人就消化得很吃力，甚至吃不下，这是我今年非常大的一个收获。</p><p>对于这个收获其实我之前想过我为什么可以得到，我刚开始把原因归结到了运气，因为我能有机会负责一条业务线的东西是由于我的师兄以及其他大部分同事都走了，现有的业务只能由留下来的人去承担，所以我当时想到了那些得到晋升或者 375 的同学是不是运气好，可以做到好的业务或者技术。但是又细想如果机会给你了，如果没有把它当机会，而且他这块重重的东西当做负担，或者平常心看待，可能也做不出什么优秀的成果。</p><p>但是一件平凡的事情如果交给一个优秀的人去做，大概率还是会做出优秀的东西。</p><p>所以最后我得出的结论是<strong>运气可以让一个准备好了，有实力的人加速成功，但不会让一个平凡的人获得成功。</strong></p><h2 id="学习与写作"><a href="#学习与写作" class="headerlink" title="学习与写作"></a>学习与写作</h2><p>当我在准备写总结的时候，我本以为今年读的书(去年 20 本)会比去年要少，没想到今年还略多一点，读完的都有 29 本了，但是我明显能感觉到今年花在读书上的时间变少了，特别是在入职蚂蚁之后，属于自己的时间更少了。</p><p>我想可能是渐渐的找到了读书的方法，越读越快了吧。</p><p>下面是我今年读书列表：<a href="https://book.douban.com/people/crazylxr/" title="豆瓣主页">豆瓣主页</a></p><p><img src="http://imgs.taoweng.site/2021-01-24-105121.jpg"></p><p><img src="http://imgs.taoweng.site/2021-01-24-105115.jpg"></p><p>在写作方面今年公开文章产量就很低了，只有 13 篇，基本都是上半年写的，下半年入职蚂蚁之后就基本没怎么写了，一方面是因为确实工作太忙了，另一方面需要在公司内部写不少的文档。</p><p>文章列表见博客：<a href="http://www.taoweng.site/index.php/archives.html" title="前端桃园">前端桃园</a></p><p><img src="http://imgs.taoweng.site/2021-01-24-105119.jpg"></p><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><p>很遗憾今年对技术没有做什么深的研究，主要是业务太忙，把我对技术的追求抹平了，整天就想着如何能把业务支持下去。</p><p>来蚂蚁半年没写过 React，大部分时间写钉钉小程序和支付宝小程序，另外还写了将近两个月的云凤蝶。</p><p>在我没怎么接触过小程序前，对小程序有刻板的印象，总觉得小程序限制太多，很简单，没有什么意思，当然也不知道其原理，所以对小程序比较抵触。</p><p>但是当我写了两三个月之后，对小程序了解得越来越多，但是另一方面发现自己对小程序了解得越来越少，为什么这么说呢？</p><p>当我还没怎么接触小程序的时候可能想到的就只有 小程序的语法是什么样的，小程序是怎么运行的，但是写得越来越久，发现自己以前的视野太小了，整个小程序生态还有很多东西可以去研究，越写越发现自己不会的越来越多，这些不知道反而让我对小程序产生了兴趣，感觉可以有新的东西值得去研究。</p><p>比如小程序他是怎么运行的，跟原生、H5 之前的区别在哪里，关联是什么，view 层是怎么渲染的，逻辑部分的 js 是怎么执行的，与客户端，容器是怎么通信，怎么打包的，怎么编译的，编译出来的东西又是什么，怎么发布上架的，以及什么情况下使用小程序技术栈、什么情况下使用 h5 技术栈，等等等，这些没有搞明白的问题深深的让我对小程序产生了兴趣。</p><p>所以明年在技术上的一个目标就是深入小程序。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><h3 id="家人"><a href="#家人" class="headerlink" title="家人"></a>家人</h3><p>生活方面最令我开心的就是女朋友在 11 月份从上海辞职，来到了杭州，结束了 3 年的异地恋，每天下班后有个人在家里等的感觉真好！</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p><strong>西安旅游</strong></p><p>国庆去西安旅游了，在去西安之前我们还先去南京溧水参加了【咪豆音乐节】。这次是准备得最充分的一次，还做了一些<a href="https://www.notion.so/2020-087ea699aca34c3d8e87230f3ff7f065" title="攻略">攻略</a>。</p><p><img src="http://imgs.taoweng.site/2021-01-24-105120.jpg"></p><p><img src="http://imgs.taoweng.site/2021-01-24-110623.png"></p><p><strong>重庆 Outing</strong></p><p>重庆三峡博物馆</p><p><img src="http://imgs.taoweng.site/2021-01-24-110536.png"></p><p><strong>江景：重庆洪崖洞夜景</strong></p><p><img src="http://imgs.taoweng.site/2021-01-24-110601.png"></p><h3 id="健身"><a href="#健身" class="headerlink" title="健身"></a><strong>健身</strong></h3><p>今年开始有了到健身房健身的习惯，非常感谢 yixi 带我去健身房教我健身，我以前以为健身器材是非常简单的东西，一进去就知道怎么用，接触了过后才知道健身其实还是挺有学问的，不同的健身器材有多种不同的用法，每种用法锻炼的部位还不一样，所以可以根据自己想健身的部位去筛选器材和器材的使用方式。</p><p>我大概从 9 月份初的时候第一次去的吧，一直到现在也是断断续续的，有时间就天天去，没时间就偷懒了，由于我们是中午去，所以时间还挺苛刻的，如果中午有会议啥的，很可能时间上赶不上了。</p><p>不过从开始第一天到现在我还是能明显得感觉到自己力量的提升，粗略的估计手 腿 肩的力量提升有 30%左右，胸部就 15-20%的样子，总感觉胸部的力量比较弱，明年多练练胸。</p><h3 id="投资理财"><a href="#投资理财" class="headerlink" title="投资理财"></a>投资理财</h3><p>2020 年在投资上最大的成长是学到了<strong>「打新」</strong>，我主要打的是港股，因为港股相对于 A 股来说中签率高，打新的赚的几率会比美股的大，我大概是在 11 月份才办好香港卡，入金到了富途，才开始打新，打了十几次才中了 3 次，每次收益都超过 15% ，但是在富途现金打新每次会收 50 的手续费，新手打新还是建议找一些现金打新免手续费的，比如艾德、华泰等。</p><p>其他股票、基金就没什么也没什么好总结的。</p><h2 id="2021-目标"><a href="#2021-目标" class="headerlink" title="2021 目标"></a>2021 目标</h2><ul><li>在社区里输出至少 10 篇文章。</li><li>平均每周至少去健身房 2 次。</li><li>旅游两次。</li><li>列太多也完不成，不列了。。。。。。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2020 年真的是不平凡的一年， 疫情夺走了很多人的生命，还夺走了我的工作(公司因为疫情被迫裁员)，所以今年换了工作来到了蚂蚁，在蚂蚁的工作</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    <category term="笔记本" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="总结" scheme="http://example.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>原来我是个业务性选手</title>
    <link href="http://example.com/index.php/archives/324/"/>
    <id>http://example.com/index.php/archives/324/</id>
    <published>2020-09-12T13:22:24.000Z</published>
    <updated>2020-09-12T13:22:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>前几天我试用期转正答辩了，老板也给过了，给到我的评价大概是：<strong>业务型选手，接下来一两年很关键，如果能够在业务中深入挖掘，会是个好苗子，否则就比较平了。</strong></p><p>这个评价其实我还是没想到的，或者说我之前根本没想过结果。</p><p>其实我从大学毕业以来，都觉得自己是个<strong>技术型选手，</strong>之前在蘑菇街的时候我也是按照技术路线走的。在蘑菇街的时候工作不是很忙，所以也有时间去研究技术，也乐于分享然后才经常写文章，才做了公众号。</p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>不过在我年初的时候，我对技术的追求稍微弱了一点，这是在蘑菇街的时候准备晋升答辩过程中的一些变化。我的前辈呀、主管呀、HR 呀，在我准备 PPT 的期间都不断的给我灌输，<strong>你做的东西到底有什么业务价值？</strong></p><p>在这期间，我的 PPT 找了好几位前辈包括自己的主管都 review 过，也给他们进行试讲，每次的给到我的建议都会有，要注重业务价值。</p><p>之后我的脑海里就深深的有了这么一个意识，<strong>技术是为业务服务的，技术的价值源之于业务的价值，而不是技术本身的价值。</strong></p><p>所以我在后面的工作中，会更注重业务价值，在做需求的时候不再去追求高大上的新技术，热技术，而是花更多的心思去<strong>问这个需求的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益。</strong><br>**</p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>没想到我把这个意识也带进了蚂蚁，在蚂蚁的工作是非常忙碌的，我后面会写文章记录一下在蚂蚁有多忙，但是现在我只想说一点，反正忙到没时间去折腾新技术，注意是折腾不是学习，因为我在蚂蚁做的东西对于我来说，一直都是新的技术，但是没有时间去专研，学习新技术是为了完成需求。</p><p>在答辩的前三天我还在跟我的老板说，业务太忙了，没时间写总结了，目前只写了一个总结的目录(可能就 50 个字左右)；老板跟我说，在 9 月 2 号前一定要提交总结，不然系统会自动试用期不通过，在那时我快要崩溃了，项目这么急，哪有时间写总结呀，还要答辩。</p><blockquote><p>真的是抽不出时间来写总结，每天加班到凌晨两三点，回家就想睡觉，根本没精力写。</p></blockquote><p>在答辩的前一天晚上，大概 8 点多的时候，其他伙伴在工作的时候，我就抽了大概一个半小时的样子按照我之前的目录写完了，感觉写出来毫无亮点，看起来就是自己的血泪史。反正就当完成任务了，明天毕竟要答辩了，不可能啥都没有吧，然后写完继续改 bug。</p><p>那天我也回去得比较早，大概 12 点回去了。在这个点其实还是有点精力的，我就寻思着，我感觉自己写的总结很 low，没有亮点，给面试官留不下太多的印象。</p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>回来之后我就思考怎么才能让面试官觉得我做的东西有价值呢？想了半天没想出来，但是突然想到一个点，我当时不知道这个点该不该讲，但是我很想讲，那就是我现在所做业务的大图。我们整个组都在做一个叫 xx 的项目(应该说是一个很大，很复杂的业务，是很多的项目)，每个人都负责其中的一块，我刚开始来的时候就对这个项目很好奇，因为我完全不能理解 xx 这个项目是一个什么样的项目，是用来干啥的。</p><p>甚至在我已经做了两个月的项目之后，我也仅仅只对我自己做的这块了解，对其他的人做的东西不知道有什么关联，但是我还是知道跟我肯定是有关联的，所以其实一直处于一种比较难受的地步，因为我不知道这个项目到底有多大的价值。</p><p>直到我在第三个月做了另外一部分的需求之后，我才慢慢的了解了这个 xx 项目到底是个什么样子的，我们的目标是什么，我们要做成什么样子，我们现在已经有了哪些能力。</p><p>那几天每天上下班的路上我就在思考这些东西，真的是每天想，后面终于想清楚了每个人做的东西之间的关联，感觉很舒服。</p><p>我觉得这个东西对于我来说价值很大，虽然他是纯业务的，或者说根本都不是我一个人做的，但是这真的是我的收获，所以我觉得站在更高的视角去介绍我们组现在做的 xx 业务，我就<strong>画了整个业务架构图，包含了我们组每个人所做的业务以及他们之间的关联。</strong></p><p>然后就去介绍**整个 xx 业务的背景，能解决什么问题，能为用户带来什么价值，能给公司带来什么利益(是不是觉得似曾相识)**，最后再去介绍我做的东西在整个大图的意义的时候就很容易了。</p><p>在答辩的时候我差不多一半的时间都在讲这个，最后也给面试官留下了深刻的影响，说我提供的视角让他学到了新东西，他之前从来没有这么想过。</p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>最后面试官给到我当面的评价也说到了我是一个善于思考的同学，喜欢去专研业务，还有其他的好的坏的评价，已经记不得了。</p><p>但是最后老板给我的试用期总评里直接说道我是一个<strong>业务型选手，</strong>这是我没想到的。但是我从他的评语中还得出，我在技术上的研究不够，如果后面我不深入业务的话，技术也没研究，那就真的很平了。</p><p>我后面多次思考了一下，我到底应该去做一个业务型选手还是技术型选手呢？我目前的答案是我应该去做业务型选手，因为我的理想是去创业的，感觉业务型选手更适合创业，如果以后想去做 CTO 啥的，还是选技术型选手比较好。</p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>想一想你们自己是想做业务型选手还是技术型选手呢？欢迎在评论区说出你们的答案，最好能带上理由。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;01&quot;&gt;&lt;a href=&quot;#01&quot; class=&quot;headerlink&quot; title=&quot;01&quot;&gt;&lt;/a&gt;01&lt;/h2&gt;&lt;p&gt;前几天我试用期转正答辩了，老板也给过了，给到我的评价大概是：&lt;strong&gt;业务型选手，接下来一两年很关键，如果能够在业务中深入挖掘，会是个</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="桃翁在蚂蚁" scheme="http://example.com/tags/%E6%A1%83%E7%BF%81%E5%9C%A8%E8%9A%82%E8%9A%81/"/>
    
  </entry>
  
  <entry>
    <title>5 点可以让你提高面试通过率建议(干货)</title>
    <link href="http://example.com/index.php/archives/323/"/>
    <id>http://example.com/index.php/archives/323/</id>
    <published>2020-06-22T15:20:37.000Z</published>
    <updated>2020-06-22T15:20:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>自从我发过几篇关于面试经历的文章，由于我面试结果还不错，所有很多人来询问我一些面试相关的问题， 我这里给到 5 点建议，希望对大家有帮助。</p><h2 id="1-简历里应该惜字如金"><a href="#1-简历里应该惜字如金" class="headerlink" title="1. 简历里应该惜字如金"></a>1. 简历里应该惜字如金</h2><p>简历简历，可以分为<strong>简</strong>和<strong>历。</strong>简，简单简洁之意，历，经历，总体就是<strong>简单</strong>的表达自己的经历。</p><p>我看到一些人的简历写了四、五页，甚至十来页的都有，每个项目把细节都写出来了，甚至还把项目截图给贴在了简历里面，生怕面试官不能理解需求，我建议最多不超过 2 页，亮点能写两页就已经很牛逼了。</p><p>我相信有很多人工作了很多年，经历的项目很多，其实不需要把所有的项目都列出来，**简历里是要展示自己的亮点，牛逼的点，这个亮点、牛逼的点事相对的，相对于自己所做的东西里面的，不是客观的牛逼(如果有当然更好，那必然也是你相对的里面的亮点，不冲突)**。</p><p>这句话意味着两层意思：</p><ul><li>很多人觉得自己的项目没有亮点的问题，因为你是那这别人更高的标准来衡量自己，所以你相对于别人没有亮点，这样你就写不出一份简历。</li><li>多个亮点类似的项目合并，或者只写一个，因为都是为了给面试官展示这一个亮点，写多了就是浪费空间，简历上面的字很珍贵。</li></ul><p><strong>第一层让你的简历有东西可写(增加)，第二层是让你把简历写得更优质(减少)。</strong></p><h2 id="2-简历应该是你设计过的"><a href="#2-简历应该是你设计过的" class="headerlink" title="2. 简历应该是你设计过的"></a>2. 简历应该是你设计过的</h2><p>「设计简历」可能对这个词有点迷惑，可能你第一感觉是设计得好看一点，其实我想表达的设计是一种「圈套」，给面试设计的「圈套」，下面我会举例子让你明白这个「圈套」是什么。</p><p>我举两个点：技术要点和项目经历。</p><p>技术要点(就是自己会哪些技术)和项目经历相信是简历里面必不可少的内容，但是也许你可能忽略了哪些应该写。</p><p>之前我给别人看简历的时候，我就会问他们写的技术点三个问题</p><ol><li>你对这个技术点的掌握程度是什么样的？</li><li>你对这个技术点准备了哪些问题？</li><li>当问到了相关技术点的时候，你能回答到哪个层次？仅仅了解、用过一两次、熟练使用、还是掌握原理。。。</li></ol><p>当你能清楚的回答完这三个问题之后，你对你自己的水平就有了一定的认识，同时你对自己是否符合这个岗位有了一定的判断。我的目的就是让你了解自己的水平，然后才能<strong>针对性</strong>的去复习，查漏补缺，自己心里要有一杆秤，自己把这个知识点掌握到这个程度，能不能胜任这个岗位。</p><p>当你了解了之后，然后根据你自己是否有充足的复习时间，你就可以去设计你的技术要点部分了，只写你准备好了的技术点，这个准备好了不是说掌握得很深才叫准备好了，就算是只能回答几个简单的问题也算是准备好了，就是你想准备，然后自己也去复习了的，这就叫准备好了，这样你在面试的时候才会胸有成竹。</p><p><strong>这就是在套路面试官问你准备好的问题</strong>，因为技术官基本只会问你简历里面提到的技术点，所以自己要对自己简历里面的技术点有充足的准备(把一些常见的面试题刷一些也是非常有帮助的)。</p><p>第二点设计就是对于项目经历部分。项目经历这部分没有人比你更熟悉，所以如果问到项目经历应该是你的地盘，是你给面试官展示你的项目有多牛逼，你在里面发挥了多大的价值，带来了多大的成果，你要非常自信的去给他讲解。</p><p>你的自信来源于什么？你非常了解这个<strong>项目的需求(为什么要做这个项目)<strong>、</strong>项目价值(做了之后怎么样了)<strong>，以及整个项目的</strong>技术方案，架构体系(怎么做的)，最重要的是你负责的或者参与的</strong>。</p><p>同时，你再把你在项目中遇到的一些<strong>难点，和解决方案总结下来，</strong>那么项目这块就是你的主战场了。</p><p><strong>划重点：上面我所说的，最好最好是要准备，也就是说最好你要写下来，然后可以没事儿自己问自己上面的这些问题，然后自己去回答。</strong></p><p>你可能会说，哇，那要准备好多东西哦，所以说啊，项目不用写太多，就把觉得自己最牛逼的、最熟悉的两、三个项目总结下来就够了，在项目这块<strong>比的不是数量，而是质量。</strong><br>**</p><blockquote><p>项目经历这块在面试的时候面试官会问你一些问题，比如一些其他的解决方案，如果当时想到了，或者面完了想到了，记得补充进去。</p></blockquote><h2 id="3-选常用的东西去准备"><a href="#3-选常用的东西去准备" class="headerlink" title="3. 选常用的东西去准备"></a>3. 选常用的东西去准备</h2><p>前端的技能要求很多，就算解决同一个问题的解决方案也会有很多个，比如解决视图的，就有 React、Vue，构建的就有 Webpack、Rollup、Parcel ，React 状态管理也有 Redux、Mbox、unstate 等。</p><p>如果你的脑袋里面都装着这些东西，那么你肯定是复习不完的了，我的建议是把你项目用常用的东西好好准备，尽量不要让面试官把你常用的东西还问倒了，如果你平时用的东西你都没有掌握得好，你觉得面试官会觉得你平时不用的东西掌握好了吗？</p><h2 id="4-准备一份自我介绍"><a href="#4-准备一份自我介绍" class="headerlink" title="4. 准备一份自我介绍"></a>4. 准备一份自我介绍</h2><p>准备一份自我介绍，不是简简单单的准备，而是自己要写下来，然后对着稿子练习一下。可能你会觉得很麻烦，有必要吗？我说两点：</p><ul><li>自我介绍是每个面试官，每场面试都会问的，没有哪个面试题有如此高的频率，100% 中的面试题不值得去好好准备吗？</li><li>上面我说了简历是去套路面试官问哪些东西？而自我介绍就是去套路面试官怎么去问的一个很好的方式，因为往往面试官会在你自我介绍之后，会问几个你自我介绍里面所包含的东西，自我介绍的结尾，也许就是面试题的开始。</li></ul><p>这个一个很好的引导面试官怎么问的方式。</p><h2 id="5-职业规划"><a href="#5-职业规划" class="headerlink" title="5. 职业规划"></a>5. 职业规划</h2><p>职业规划这个，其实也是一个高频面试题，不管是面试官还是 HR，都喜欢问的一个问题，这个题没有标准答案，我说一下我的一些看法。</p><p>职业规划我觉得可以从三个方面去谈：</p><ol><li>我想做什么？(兴趣、价值观等方面)</li><li>我能做什么？(你的知识、技术、经历等方面来支持)</li><li>环境支持我做什么(意味着未来)？(外部环境，公司、团队)</li></ol><p>大致你可以像这样去回答，我的兴趣是 XXX，优势是 XXX，因此我选择了前端，这是一个可以将我的兴趣和工作结合起来的行业，是我非常喜欢的，所以我会很用心对待这个工作。我之前做过 XX，有了 XX 的经验，然后觉得很有意思，想继续深挖(当然你也可以说，我之前一直在做 XXX，以后想换一种 XXX 技术)。近期我打算研究 XXX，后续可以在 XXX 上独当一面，独立负责 XXXX 事务,解决 XXXX 问题。谈到远期规划，我会根据环境的变化，工作内容的变化，以及我自身能力的变化，不断进行调整的。</p><p>讲道理面试官问这个问题无非是想考察这四个点：</p><ol><li>求职者对自我的认知</li><li>求职者对岗位的了解程度，对职业的理解程度</li><li>求职者工作的稳定性</li><li>求职者的上进心、目标感和自我驱动力</li></ol><p>知己知彼，方能百战不殆嘛，看看面试官的考察点，然后针对的去准备。职业规划这个东西不仅仅是为了面试，对自己长远来说都是非常有用的，每个人都希望好好准备下。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>文章里没有写任何关于技术上的东西，而是重点介绍了如果去准备面试以及要准备哪些东西的策略，这些策略是通用的，无论是前端、后端都应该去准备的东西，看了这篇文章的同学，希望你能找到如意的工作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从我发过几篇关于面试经历的文章，由于我面试结果还不错，所有很多人来询问我一些面试相关的问题， 我这里给到 5 点建议，希望对大家有帮助。&lt;/p&gt;
&lt;h2 id=&quot;1-简历里应该惜字如金&quot;&gt;&lt;a href=&quot;#1-简历里应该惜字如金&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁、字节、滴滴面试经历总结</title>
    <link href="http://example.com/index.php/archives/321/"/>
    <id>http://example.com/index.php/archives/321/</id>
    <published>2020-05-18T04:49:46.000Z</published>
    <updated>2020-05-18T04:49:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近两篇面试以及离职相关的文章不容错过哦。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EG5HCgz_M1S2Xbky0lgDxg">拼多多和酷家乐面试总结</a></p></li></ul><p>今年面试还是比较顺的，面了五家公司(酷家乐、拼多多、字节、滴滴、蚂蚁)，都过了。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>说一下浏览器缓存</p></blockquote><p>浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</p><p>控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。</p><p>控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><blockquote><p>cookie 与 session 的区别</p></blockquote><p>Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</p><p>详见：<a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a></p><blockquote><p>浏览器如何做到 session 的功能的。</p></blockquote><p>其实就是考察 http 怎么处理无状态是怎么处理的，具体可见 <a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a>里面的答案。</p><blockquote><p>解释一下：csrf 和 xss</p></blockquote><p>XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>怎么防止 csrf 和 xss</p></blockquote><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>跨域的处理方案有哪些</p></blockquote><p>常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></p><blockquote><p>CORS 是如何做的？</p></blockquote><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><blockquote><p>对于 CORS ，Get 和 POST 有区别吗？</p></blockquote><p>其实想考察的就是什么时候会有**预检请求(option 请求)**。</p><blockquote><p>了解 HTTPS 的过程吗？</p></blockquote><p>推荐浪浪的 <a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">深入理解HTTPS工作原理</a></p><blockquote><p>webpack 如何做性能优化</p></blockquote><p>webpack 做性能优化主要是考虑打包体积和打包速度。</p><p>体积分析用 <code>webpack-bundle-analyzer</code> 插件，速度分析用：<code>speed-measure-webpack-plugin</code> 插件。</p><p>打包速度优化瓶子君的：<a href="https://juejin.im/post/5e53dbbc518825494905c45f">玩转 webpack，使你的打包速度提升 90%</a>。</p><blockquote><p>es module 和 commonjs 的区别</p></blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><blockquote><p>react 里如何做动态加载</p></blockquote><p><code>React.lazy</code> ，另外通过 webpack 的动态加载：<code>import()</code> 和 <code>ensure.require</code></p><blockquote><p>动态加载的原理是啥，就是 webpack 编译出来的代码</p></blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p><blockquote><p>笔试题：页面结构包括页头（永远在顶部）、主体内容、页脚，页脚永远在页面底部（不是窗口底部），即内容高度不够时，页脚也要保证在页面底部</p></blockquote><p>常规题，考察基本的布局</p><blockquote><p>笔试题：写 new 的执行过程</p></blockquote><p>new 的执行过程大致如下：</p><ol><li><p>创建一个对象</p></li><li><p>将对象的 _ <em>proto_</em> 指向 构造函数的 prototype</p></li><li><p>将这个对象作为构造函数的 this</p></li><li><p>返回该对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Con, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(Con.prototype)<br>  <span class="hljs-keyword">let</span> result = Con.apply(obj, args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>笔试题：写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3</p></blockquote><p>思路：对于浮点数在底层处理是有问题的，所以目的就是想办法将所以的浮点数转化为整数进行处理，同时乘以一个倍数(A)，然后加起来后再除以这个倍数(A)，这个倍数应该是两个数中最小的那个数的倍数，比如 0.1 + 0.02 ,那么应该同时乘以 100，变为 10 + 2，然后再将值除以 100。</p><blockquote><p>1000000000 + 1000000000 允许返回字符串 处理大数</p></blockquote><p>大数问题就是通过字符串来处理，从后往前加，然后处理进位的问题。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目</p></blockquote><p>项目基本是问：</p><ol><li>项目难点以及怎么解决的</li><li>项目有哪些亮点？</li></ol><blockquote><p>写一个 es6 的继承过程</p></blockquote><p>这个题我觉得出得很好，很考察基本功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个是要实现的方法</span><br>createClass = <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params">sons, <span class="hljs-built_in">super</span></span>)</span> &#123;<br><span class="hljs-comment">// TODO</span><br><span class="hljs-keyword">return</span> fn;<br>&#125;<br><br><span class="hljs-comment">// 这是个 es6 的一个例子，要实现 extends 的功能。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>cons (args) &#123;<br><span class="hljs-built_in">super</span>(args)<br>  <span class="hljs-comment">// xxxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题跟一面的时候思路差不多，只是进位的时候不一定是 1。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><blockquote><p>聊项目</p></blockquote><blockquote><p>写一个防抖函数</p></blockquote><blockquote><p>算法题:<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p></blockquote><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>字节果然是出了名的考算法题比较多的，基本每面都会算法题和编程题，对编程能力比较看重吧。</p><p> 讲道理一面还是比较常规的，二三面因为都是团队 leader 和更高级别的，问的技术细节也比较少了，重点考察一些技术方案和项目的问题。</p><h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><blockquote><p>webpack 原理</p></blockquote><p>大致就是：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><blockquote><p>babel 原理</p></blockquote><p>babel的转译过程分为三个阶段：<strong>parsing、transforming、generating</strong>，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><ol><li>ES6代码输入 </li><li>babylon 进行解析得到 AST</li><li>plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</li><li>用 babel-generator 通过 AST 树生成 ES5 代码</li></ol><blockquote><p>虚拟 DOM 的理解</p></blockquote><p><a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a></p><blockquote><p>项目里如何做的性能优化</p></blockquote><p>这个跟我的项目相关。</p><blockquote><p>写过webpack loader 或者插件吗</p></blockquote><blockquote><p>讲讲你写的 babel 插件</p></blockquote><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><blockquote><p>redux 的原理</p></blockquote><blockquote><p>redux 做状态管理和发布订阅模式有什么区别</p></blockquote><p>redux 其实也是一个发布订阅，但是 redux 可以做到数据的可预测和可回溯。</p><blockquote><p>react-redux 的原理，是怎么跟 react 关联起来的</p></blockquote><p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p><blockquote><p>了解多端的原理吗？</p></blockquote><p>不清楚，没了解过。</p><blockquote><p>http 与 tcp 的关系</p></blockquote><blockquote><p>tcp 可以建立多个连接吗？</p></blockquote><p>我估计是想问 http 的管线化，当时忘了这个叫啥了</p><blockquote><p>介绍一下为什么要有 三次握手，四次挥手</p></blockquote><blockquote><p>写过 babel 插件吗？用来干啥的？怎么写的 babel 插件</p></blockquote><p>写过一些简单的 babel 插件，说了我们公司用来通过代码生成文档的 babel 插件是怎么做的。</p><blockquote><p>知道怎么转化成 AST 的吗？</p></blockquote><p>我估计就是问词法分析和语法分析相关的</p><blockquote><p>研究过 React 的运行时吗？</p></blockquote><blockquote><p>职业规划。</p></blockquote><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><blockquote><p>项目介绍</p></blockquote><blockquote><p>说一下你的项目有哪些复杂的点，以及怎么解决的</p></blockquote><p>这个聊了挺久的，还聊了一些数据量比较大的怎么处理。</p><blockquote><p>你们的业务组件库有多少个，是什么样的组件</p></blockquote><blockquote><p>权限组件是怎么设计的</p></blockquote><blockquote><p>会node 吗？</p></blockquote><p>我说我只会增删改查，会点 express，然后就开始一顿狂轰乱炸的知识。</p><blockquote><p>介绍一下你对中间件的理解</p></blockquote><blockquote><p>怎么保证后端服务稳定性，怎么做容灾</p></blockquote><p>感觉已经超纲了，基本没做过，还好之前跟后端同学聊过他们怎么做容灾的，还记得两点说了下。</p><ol><li>多个服务器部署</li><li>降级处理，服务挂了，从缓存里面取。</li></ol><blockquote><p>怎么让数据库查询更快</p></blockquote><ol><li>索引 </li><li>如果数据量太多了可以拆表，分多个数据库</li></ol><blockquote><p>数据库是用的什么？</p></blockquote><p>mysql</p><blockquote><p>为什么用 mysql</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><p>这个题其实还挺常考的，可以好好准备下，背一下答案。</p><p>最后面试官问我有什么想问他的么，我说没有，因为我之前问得挺多了。不过他还是给我介绍了他们业务还是很厉害的，集团第三，还拿了 A 级绩效，公司有很多技术上的沉淀，跨端呀，web IDE 呀，等等</p><p>这个时候我就感觉自己能过了，感觉是在吸引我去，偷笑。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><blockquote><p>介绍一下项目的难点以及怎么解决的</p></blockquote><p>一起讨论那些难点</p><blockquote><p>自己有什么技术上的优势</p></blockquote><blockquote><p>最近在研究什么技术？</p></blockquote><blockquote><p>职业规划</p></blockquote><blockquote><p>移动端的业务有做过吗？</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><blockquote><p>当业务重的时候怎么安排时间？</p></blockquote><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>滴滴我面的这个岗位是可能回去做一些多端应用，所以会涉及到很多 webpack 和 ast 相关的东西，所以这些问得比较多，感觉这个组还是很不错的，能做到很多技术上的东西。</p><h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><blockquote><p>讲讲来蘑菇街都干了哪些事情</p></blockquote><blockquote><p>聊聊有什么技术上的沉淀</p></blockquote><blockquote><p>除了 redux mbox dva 还用过其他的 状态管理没</p></blockquote><blockquote><p>hooks 原理</p></blockquote><blockquote><p>看过 hooks 相关的草案吗</p></blockquote><blockquote><p>你对蚂蚁有什么期望，或者说技术的规划，想做的东西</p></blockquote><blockquote><p>vue3 的 类似 hooks 的原理是怎么样的</p></blockquote><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目，项目的难点，以及自己做了哪些事情</p></blockquote><blockquote><p>为什么项目里会引入 TS</p></blockquote><blockquote><p>dva 和 redux 的区别</p></blockquote><blockquote><p>职业发展，今年的打算</p></blockquote><blockquote><p>组件升级怎么让使用这个组件的人都知道。</p></blockquote><blockquote><p>如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计</p></blockquote><h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>全程聊项目，因为他不是前端的，所以没问前端任何知识，主要聊业务相关的，看看我对业务的理解，以及一些想法。</p><ul><li><p>项目难点</p></li><li><p>怎么解决</p></li><li><p>项目有什么改进的地方</p></li><li><p>业务方怎么拿到反馈的，就是做的这个东西具体有什么用</p></li></ul><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>一面面试官问了很多我完全不知道的东西，我知道的东西可能答的比较随意吧，记不起来了。反正能深深的感受到面试对知识的广度和深度远超我很多很多，基本不在一个 level 的。</p><p>二三面已经是 P9 的大佬来面了，所以也没问太多的技术细节，都是考察一些技术的解决方案和项目的东西。</p><p>蚂蚁的面试其实还是比较难的，问题都不是那种有确定的答案，基本都是考察你平时的积累和经验。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上一篇拼多多和酷家乐的面经之后有很多人问我工作几年，怎么学习的之类的，或者你面了这么多都过了是不是有什么技巧呀？</p><p>首先我目前工作了快两年了，18 年 7 月份毕业的。</p><p>关于如何准备面试的问题，我的策略是把自己<strong>会的东西以及常用的东西</strong>，尽量让面试官问不倒你，不会的东西可以跟面试官说不会，不怎么了解，那一般面试官也不会问相关的问题了，如果连自己常用的东西都了解得不深，那么就不太有可能把平时不常用的了解得很深了。</p><p>比如我可能写 react 比较多，参与过组件库的开发，webpack 写得也比较多。所以我在准备的时候，就尽量准备的这些知识，了解我的人都知道，我对 react 研究得比较多，原理、性能优化都写过文章，所以如果考 react 的东西，我基本不担心。 对于 vue、移动端、小程序、node 啥的，我基本没准备，问倒的时候我就说仅仅了解，没有什么实战经验。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>最后我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近两篇面试以及离职相关的文章不容错过哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.co</summary>
      
    
    
    
    <category term="笔记本" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>蚂蚁、字节、滴滴面试经历总结</title>
    <link href="http://example.com/index.php/archives/320/"/>
    <id>http://example.com/index.php/archives/320/</id>
    <published>2020-05-18T04:49:39.000Z</published>
    <updated>2020-05-18T04:49:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近两篇面试以及离职相关的文章不容错过哦。</p><ul><li><p><a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/EG5HCgz_M1S2Xbky0lgDxg">拼多多和酷家乐面试总结</a></p></li></ul><p>今年面试还是比较顺的，面了五家公司(酷家乐、拼多多、字节、滴滴、蚂蚁)，都过了。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><blockquote><p>说一下浏览器缓存</p></blockquote><p>浏览器缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，强缓存会直接从浏览器里面拿数据，协商缓存会先访问服务器看缓存是否过期，再决定是否从浏览器里面拿数据。</p><p>控制强缓存的字段有：Expires和Cache-Control，Expires 和 Cache-Control。</p><p>控制协商缓存的字段是：Last-Modified / If-Modified-Since 和 Etag / If-None-Match，其中 Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高。</p><blockquote><p>cookie 与 session 的区别</p></blockquote><p>Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；<br>Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。</p><p>详见：<a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a></p><blockquote><p>浏览器如何做到 session 的功能的。</p></blockquote><p>其实就是考察 http 怎么处理无状态是怎么处理的，具体可见 <a href="https://www.zhihu.com/question/19786827">COOKIE和SESSION有什么区别？</a>里面的答案。</p><blockquote><p>解释一下：csrf 和 xss</p></blockquote><p>XSS：恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF：CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>怎么防止 csrf 和 xss</p></blockquote><p>详见：*<a href="https://www.cxymsg.com/guide/security.html#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%E7%9A%84%E7%9A%84%E9%97%AE%E9%A2%98">前端安全面试题</a>*</p><blockquote><p>跨域的处理方案有哪些</p></blockquote><p>常用的：jsonp、CORS、nginx 代理，完整的大概是九种，可见：<a href="https://juejin.im/post/5c23993de51d457b8c1f4ee1">九种跨域方式实现原理（完整版）</a></p><blockquote><p>CORS 是如何做的？</p></blockquote><p>服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。</p><blockquote><p>对于 CORS ，Get 和 POST 有区别吗？</p></blockquote><p>其实想考察的就是什么时候会有**预检请求(option 请求)**。</p><blockquote><p>了解 HTTPS 的过程吗？</p></blockquote><p>推荐浪浪的 <a href="https://juejin.im/post/5ca6a109e51d4544e27e3048">深入理解HTTPS工作原理</a></p><blockquote><p>webpack 如何做性能优化</p></blockquote><p>webpack 做性能优化主要是考虑打包体积和打包速度。</p><p>体积分析用 <code>webpack-bundle-analyzer</code> 插件，速度分析用：<code>speed-measure-webpack-plugin</code> 插件。</p><p>打包速度优化瓶子君的：<a href="https://juejin.im/post/5e53dbbc518825494905c45f">玩转 webpack，使你的打包速度提升 90%</a>。</p><blockquote><p>es module 和 commonjs 的区别</p></blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p><blockquote><p>react 里如何做动态加载</p></blockquote><p><code>React.lazy</code> ，另外通过 webpack 的动态加载：<code>import()</code> 和 <code>ensure.require</code></p><blockquote><p>动态加载的原理是啥，就是 webpack 编译出来的代码</p></blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p><blockquote><p>笔试题：页面结构包括页头（永远在顶部）、主体内容、页脚，页脚永远在页面底部（不是窗口底部），即内容高度不够时，页脚也要保证在页面底部</p></blockquote><p>常规题，考察基本的布局</p><blockquote><p>笔试题：写 new 的执行过程</p></blockquote><p>new 的执行过程大致如下：</p><ol><li><p>创建一个对象</p></li><li><p>将对象的 _ <em>proto_</em> 指向 构造函数的 prototype</p></li><li><p>将这个对象作为构造函数的 this</p></li><li><p>返回该对象。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNew</span>(<span class="hljs-params">Con, ...args</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(Con.prototype)<br>  <span class="hljs-keyword">let</span> result = Con.apply(obj, args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> ? result : obj<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>笔试题：写一个处理加法可能产生精度的函数，比如 0.1 + 0.2 = 0.3</p></blockquote><p>思路：对于浮点数在底层处理是有问题的，所以目的就是想办法将所以的浮点数转化为整数进行处理，同时乘以一个倍数(A)，然后加起来后再除以这个倍数(A)，这个倍数应该是两个数中最小的那个数的倍数，比如 0.1 + 0.02 ,那么应该同时乘以 100，变为 10 + 2，然后再将值除以 100。</p><blockquote><p>1000000000 + 1000000000 允许返回字符串 处理大数</p></blockquote><p>大数问题就是通过字符串来处理，从后往前加，然后处理进位的问题。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目</p></blockquote><p>项目基本是问：</p><ol><li>项目难点以及怎么解决的</li><li>项目有哪些亮点？</li></ol><blockquote><p>写一个 es6 的继承过程</p></blockquote><p>这个题我觉得出得很好，很考察基本功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这个是要实现的方法</span><br>createClass = <span class="hljs-function"><span class="hljs-title">fun</span>(<span class="hljs-params">sons, <span class="hljs-built_in">super</span></span>)</span> &#123;<br><span class="hljs-comment">// TODO</span><br><span class="hljs-keyword">return</span> fn;<br>&#125;<br><br><span class="hljs-comment">// 这是个 es6 的一个例子，要实现 extends 的功能。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Man</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Human</span> </span>&#123;<br>cons (args) &#123;<br><span class="hljs-built_in">super</span>(args)<br>  <span class="hljs-comment">// xxxxx</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">speak</span>(<span class="hljs-params"></span>)</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写一个大数相乘的解决方案。传两个字符串进来，返回一个字符串</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这道题跟一面的时候思路差不多，只是进位的时候不一定是 1。</p><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><blockquote><p>聊项目</p></blockquote><blockquote><p>写一个防抖函数</p></blockquote><blockquote><p>算法题:<a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/">https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/</a></p></blockquote><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>字节果然是出了名的考算法题比较多的，基本每面都会算法题和编程题，对编程能力比较看重吧。</p><p> 讲道理一面还是比较常规的，二三面因为都是团队 leader 和更高级别的，问的技术细节也比较少了，重点考察一些技术方案和项目的问题。</p><h2 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><blockquote><p>webpack 原理</p></blockquote><p>大致就是：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。</p><blockquote><p>babel 原理</p></blockquote><p>babel的转译过程分为三个阶段：<strong>parsing、transforming、generating</strong>，以ES6代码转译为ES5代码为例，babel转译的具体过程如下：</p><ol><li>ES6代码输入 </li><li>babylon 进行解析得到 AST</li><li>plugin 用 babel-traverse 对 AST 树进行遍历转译,得到新的AST树</li><li>用 babel-generator 通过 AST 树生成 ES5 代码</li></ol><blockquote><p>虚拟 DOM 的理解</p></blockquote><p><a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a></p><blockquote><p>项目里如何做的性能优化</p></blockquote><p>这个跟我的项目相关。</p><blockquote><p>写过webpack loader 或者插件吗</p></blockquote><blockquote><p>讲讲你写的 babel 插件</p></blockquote><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><blockquote><p>redux 的原理</p></blockquote><blockquote><p>redux 做状态管理和发布订阅模式有什么区别</p></blockquote><p>redux 其实也是一个发布订阅，但是 redux 可以做到数据的可预测和可回溯。</p><blockquote><p>react-redux 的原理，是怎么跟 react 关联起来的</p></blockquote><p>react-redux 的核心组件只有两个，Provider 和 connect，Provider 存放 Redux 里 store 的数据到 context 里，通过 connect 从 context 拿数据，通过 props 传递给 connect 所包裹的组件。</p><blockquote><p>了解多端的原理吗？</p></blockquote><p>不清楚，没了解过。</p><blockquote><p>http 与 tcp 的关系</p></blockquote><blockquote><p>tcp 可以建立多个连接吗？</p></blockquote><p>我估计是想问 http 的管线化，当时忘了这个叫啥了</p><blockquote><p>介绍一下为什么要有 三次握手，四次挥手</p></blockquote><blockquote><p>写过 babel 插件吗？用来干啥的？怎么写的 babel 插件</p></blockquote><p>写过一些简单的 babel 插件，说了我们公司用来通过代码生成文档的 babel 插件是怎么做的。</p><blockquote><p>知道怎么转化成 AST 的吗？</p></blockquote><p>我估计就是问词法分析和语法分析相关的</p><blockquote><p>研究过 React 的运行时吗？</p></blockquote><blockquote><p>职业规划。</p></blockquote><h3 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h3><blockquote><p>项目介绍</p></blockquote><blockquote><p>说一下你的项目有哪些复杂的点，以及怎么解决的</p></blockquote><p>这个聊了挺久的，还聊了一些数据量比较大的怎么处理。</p><blockquote><p>你们的业务组件库有多少个，是什么样的组件</p></blockquote><blockquote><p>权限组件是怎么设计的</p></blockquote><blockquote><p>会node 吗？</p></blockquote><p>我说我只会增删改查，会点 express，然后就开始一顿狂轰乱炸的知识。</p><blockquote><p>介绍一下你对中间件的理解</p></blockquote><blockquote><p>怎么保证后端服务稳定性，怎么做容灾</p></blockquote><p>感觉已经超纲了，基本没做过，还好之前跟后端同学聊过他们怎么做容灾的，还记得两点说了下。</p><ol><li>多个服务器部署</li><li>降级处理，服务挂了，从缓存里面取。</li></ol><blockquote><p>怎么让数据库查询更快</p></blockquote><ol><li>索引 </li><li>如果数据量太多了可以拆表，分多个数据库</li></ol><blockquote><p>数据库是用的什么？</p></blockquote><p>mysql</p><blockquote><p>为什么用 mysql</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><p>这个题其实还挺常考的，可以好好准备下，背一下答案。</p><p>最后面试官问我有什么想问他的么，我说没有，因为我之前问得挺多了。不过他还是给我介绍了他们业务还是很厉害的，集团第三，还拿了 A 级绩效，公司有很多技术上的沉淀，跨端呀，web IDE 呀，等等</p><p>这个时候我就感觉自己能过了，感觉是在吸引我去，偷笑。</p><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><blockquote><p>介绍一下项目的难点以及怎么解决的</p></blockquote><p>一起讨论那些难点</p><blockquote><p>自己有什么技术上的优势</p></blockquote><blockquote><p>最近在研究什么技术？</p></blockquote><blockquote><p>职业规划</p></blockquote><blockquote><p>移动端的业务有做过吗？</p></blockquote><blockquote><p>希望滴滴能提供给你什么？</p></blockquote><blockquote><p>当业务重的时候怎么安排时间？</p></blockquote><h3 id="小节-1"><a href="#小节-1" class="headerlink" title="小节"></a>小节</h3><p>滴滴我面的这个岗位是可能回去做一些多端应用，所以会涉及到很多 webpack 和 ast 相关的东西，所以这些问得比较多，感觉这个组还是很不错的，能做到很多技术上的东西。</p><h2 id="蚂蚁"><a href="#蚂蚁" class="headerlink" title="蚂蚁"></a>蚂蚁</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><blockquote><p>讲讲来蘑菇街都干了哪些事情</p></blockquote><blockquote><p>聊聊有什么技术上的沉淀</p></blockquote><blockquote><p>除了 redux mbox dva 还用过其他的 状态管理没</p></blockquote><blockquote><p>hooks 原理</p></blockquote><blockquote><p>看过 hooks 相关的草案吗</p></blockquote><blockquote><p>你对蚂蚁有什么期望，或者说技术的规划，想做的东西</p></blockquote><blockquote><p>vue3 的 类似 hooks 的原理是怎么样的</p></blockquote><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><blockquote><p>聊项目，项目的难点，以及自己做了哪些事情</p></blockquote><blockquote><p>为什么项目里会引入 TS</p></blockquote><blockquote><p>dva 和 redux 的区别</p></blockquote><blockquote><p>职业发展，今年的打算</p></blockquote><blockquote><p>组件升级怎么让使用这个组件的人都知道。</p></blockquote><blockquote><p>如果让你设计项目自动设计组件升级，并且安全，你会怎么去设计</p></blockquote><h3 id="三面-2"><a href="#三面-2" class="headerlink" title="三面"></a>三面</h3><p>全程聊项目，因为他不是前端的，所以没问前端任何知识，主要聊业务相关的，看看我对业务的理解，以及一些想法。</p><ul><li><p>项目难点</p></li><li><p>怎么解决</p></li><li><p>项目有什么改进的地方</p></li><li><p>业务方怎么拿到反馈的，就是做的这个东西具体有什么用</p></li></ul><h3 id="小节-2"><a href="#小节-2" class="headerlink" title="小节"></a>小节</h3><p>一面面试官问了很多我完全不知道的东西，我知道的东西可能答的比较随意吧，记不起来了。反正能深深的感受到面试对知识的广度和深度远超我很多很多，基本不在一个 level 的。</p><p>二三面已经是 P9 的大佬来面了，所以也没问太多的技术细节，都是考察一些技术的解决方案和项目的东西。</p><p>蚂蚁的面试其实还是比较难的，问题都不是那种有确定的答案，基本都是考察你平时的积累和经验。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>上一篇拼多多和酷家乐的面经之后有很多人问我工作几年，怎么学习的之类的，或者你面了这么多都过了是不是有什么技巧呀？</p><p>首先我目前工作了快两年了，18 年 7 月份毕业的。</p><p>关于如何准备面试的问题，我的策略是把自己<strong>会的东西以及常用的东西</strong>，尽量让面试官问不倒你，不会的东西可以跟面试官说不会，不怎么了解，那一般面试官也不会问相关的问题了，如果连自己常用的东西都了解得不深，那么就不太有可能把平时不常用的了解得很深了。</p><p>比如我可能写 react 比较多，参与过组件库的开发，webpack 写得也比较多。所以我在准备的时候，就尽量准备的这些知识，了解我的人都知道，我对 react 研究得比较多，原理、性能优化都写过文章，所以如果考 react 的东西，我基本不担心。 对于 vue、移动端、小程序、node 啥的，我基本没准备，问倒的时候我就说仅仅了解，没有什么实战经验。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote><p>最后我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近两篇面试以及离职相关的文章不容错过哦。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac写作环境搭建</title>
    <link href="http://example.com/index.php/archives/319/"/>
    <id>http://example.com/index.php/archives/319/</id>
    <published>2020-05-10T13:35:00.000Z</published>
    <updated>2020-05-10T13:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写作是我一直都提倡每个人去做的一件事情，也许你是通过写作来进行总结，也许你是通过写作生计，也许像我一样写文章提升自己的影响力，不管怎么样，工欲善其事必先利其器，今天我将两年以来最好用的一套写作软件配置介绍给大家。</p><p>在这篇文章中你可以了解到三个工具：</p><ol><li>最好用的 markdown 写作编辑器</li><li>mac 平台专属的图床工具</li><li>选取合适的工具美化排版</li></ol><h2 id="写作软件-Typora"><a href="#写作软件-Typora" class="headerlink" title="写作软件(Typora)"></a>写作软件(Typora)</h2><p>我使用过很多的 markdown 编辑器，<strong>bear</strong>、<strong>MWeb</strong>、<strong>UIysses</strong>、<strong>印象笔记</strong>等等，每个都号称最专业的 markdown 软件，但是这些软件对于图片的处理都不是特别满足我的需求。</p><p>只有 <strong>typora</strong>，让文字和图片完美的结合在一起，并且支持将文章复制到其他平台。</p><p>接下来，我将介绍一下 Typora 吸引我的几个地方：</p><h3 id="1-所见即所得的特性"><a href="#1-所见即所得的特性" class="headerlink" title="1. 所见即所得的特性"></a>1. 所见即所得的特性</h3><p>实时预览，不需要分两栏。</p><p><img src="http://imgs.taoweng.site/2020-05-10-132912.gif" alt="实时预览"></p><h3 id="2-自定义主题。"><a href="#2-自定义主题。" class="headerlink" title="2. 自定义主题。"></a>2. 自定义主题。</h3><p>你可以从<a href="http://theme.typora.io/">官网下载主题</a>，或者自己写主题。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133121.jpg" alt="自定义主题"></p><h3 id="3-大纲与文章目录。"><a href="#3-大纲与文章目录。" class="headerlink" title="3. 大纲与文章目录。"></a>3. 大纲与文章目录。</h3><p>自动识别标题，展示出目录。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133207.png"></p><h3 id="4-可以方便的将图片自动上传到自己的图床上"><a href="#4-可以方便的将图片自动上传到自己的图床上" class="headerlink" title="4. 可以方便的将图片自动上传到自己的图床上"></a>4. 可以方便的将图片自动上传到自己的图床上</h3><p>大部分的写作编辑器都需要手动的去将图片上传到图床上，然后再把链接写到编辑器来，这样来回切换很麻烦。typora 可以自动识别图片然后直接上传上自己的图床上。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133238.png"></p><p>当你把图片直接拖到编辑器，或者说截屏之后复制到编辑器的时候，就会让你选择是否上传图片，点击上传图片就可以直接上传到图床上，然后将链接替换成图床的链接。</p><p>你只需要在偏好设置图像的上传服务设置为 iPic 即可，下面我会介绍 iPic。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133258.png"></p><p>上传服务这里还可以选择自定义命令，也就是说你可以自己写一个上传图片的 <code>shell</code> 然后上传到自己的图床上，图片处理非常的强大。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133310.png"></p><h3 id="5-可以直接复制富文本格式-包括主题样式-到公众号或者其他支持富文本的地方。"><a href="#5-可以直接复制富文本格式-包括主题样式-到公众号或者其他支持富文本的地方。" class="headerlink" title="5. 可以直接复制富文本格式(包括主题样式)到公众号或者其他支持富文本的地方。"></a>5. 可以直接复制富文本格式(包括主题样式)到公众号或者其他支持富文本的地方。</h3><p>公众号后台排版其实不是特别好用，另外我们程序员往往喜欢写 <strong>markdown</strong> 而不是富文本，所以就需要一个将 <strong>markdown</strong> 转富文本的一个工具，typora 在这方面也很擅长。</p><h2 id="图片处理-iPic-和-iPic-Move"><a href="#图片处理-iPic-和-iPic-Move" class="headerlink" title="图片处理(iPic 和 iPic Move)"></a>图片处理(iPic 和 iPic Move)</h2><h3 id="怎么获得免费图床"><a href="#怎么获得免费图床" class="headerlink" title="怎么获得免费图床"></a>怎么获得免费图床</h3><p>对于图床这个东西，我觉得还是用自己的比较好，或者说付费的图床，而不是选用网上一些免费的，比如微博图床，其他网站的图床(比如掘金)，使用别人的图床虽然免费，但是一旦加了防盗链，你想迁移图片就非常的麻烦(我就踩过这个坑)，那么这个时候免费的其实就更贵了。</p><p>所以很早我就开始研究怎么能用上专业的，自己的图床，我就发现了<strong>七牛云</strong>这个良心云服务商。七牛云对于新用户免费送 10 个 G 的空间，你可以将图片通过<strong>对象存储</strong>的方式存在七牛云里。而且这些图片还是都可以增加 <strong>CDN</strong> 的。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133320.png"></p><p>具体如何去创建自己的对象存储空间，你可以参考<a href="https://developer.qiniu.com/kodo/manual/1233/console-quickstart">官网教程</a>。</p><p>有了图床，如何将图片上传到图床上面去呢？在 Mac 下 iPic 就是一个很好的工具。</p><h3 id="iPic"><a href="#iPic" class="headerlink" title="iPic"></a>iPic</h3><p>iPic 是一个 Markdown 图床上传工具，将你的图片上传到你的图床上后，你可以得到一个 markdown 格式的图片文本，然后你可以直接复制到你的编辑器中。</p><p>你只需要在<strong>偏好设置</strong>里面设置好你自己图床相关的参数就可以很方便的上传图片到图床了。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133329.png"></p><h3 id="iPic-Mover"><a href="#iPic-Mover" class="headerlink" title="iPic Mover"></a>iPic Mover</h3><p><a href="https://itunes.apple.com/cn/app/id1183822957?ls=1&mt=12">iPic Mover</a> 可以一键将已有 Markdown 文件中所有图片迁移至新图床。批量上传图片、图床搬家，从未如此简单。</p><p><img src="https://ps-hz.toolinbox.net/006y8lVagw1fajaszqardg30ia0bc4cp.gif"></p><p>有了 iPic Mover，你就可以将你以前的图片统统放到自己的图床了，再也不怕别人给你加防盗链了。</p><h2 id="美化排版"><a href="#美化排版" class="headerlink" title="美化排版"></a>美化排版</h2><p>美化排版我的目的是要将文章复制到<strong>公众号</strong>里，公众号是需要讲颜值的，这样别人读起来才会舒服，读完率才会高。</p><h3 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h3><p>基于以上目的，如果你觉得默认的主题不太好看，Typora 默认还提供了好几种主题，你可以切换你自己喜欢的。</p><p><img src="http://imgs.taoweng.site/2020-05-10-133351.png"></p><p>typora 默认提供了大概五个主题，你可以进行切换选择，如果你觉得这几个还不够好看，那么你可以去<a href="http://theme.typora.io/">主题市场</a>下载更多好看的主题。</p><p>如果你对主题市场的主题还不满意，可以手写一份 CSS，打造自己的主题。</p><h3 id="Mdnice"><a href="#Mdnice" class="headerlink" title="Mdnice"></a>Mdnice</h3><p>另外一个 markdown 美化排版的工具就是大名鼎鼎的 <a href="https://mdnice.com/">mdnice</a>，提供了将近 20 种主题：</p><p><img src="http://imgs.taoweng.site/2020-05-10-133403.png"></p><p>另外这个工具还支持<strong>格式化文档</strong>和<strong>微信外链转脚注</strong>的功能，这对于做公众号的同学来说非常的友好。也强烈推荐大家去尝试一下。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是我完成一篇公众号文章所需要用到的一些工具以及使用方法，我相信这些工具可以令你在写文章的时候不会为了工具不好用而烦恼，也不会为了写出来的文章排版不好看被读者吐槽。</p><p>如果你有更好的写作工具或者使用方法，欢迎留言给我，咱们一起讨论。</p><blockquote><p>我是桃翁，一个爱思考的前端er，期待你的关注。如果这篇文章能给你带来收获，希望你能点赞转发。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;写作是我一直都提倡每个人去做的一件事情，也许你是通过写作来进行总结，也许你是通过写作生计，也许像我一样写文章提升自己的影响力，不管怎么样，工</summary>
      
    
    
    
    <category term="笔记本" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="写作" scheme="http://example.com/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>拼多多和酷家乐面试经历总结</title>
    <link href="http://example.com/index.php/archives/318/"/>
    <id>http://example.com/index.php/archives/318/</id>
    <published>2020-05-07T05:17:00.000Z</published>
    <updated>2020-05-07T05:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离职原因看我这篇文章吧：<a href="https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw">离开蘑菇街后，我最近的一些想法</a>，然后不得不去找工作恰饭呀。</p><p>我目前面了五家公司：滴滴、蚂蚁、拼多多、酷家乐、字节跳动，拼多多和酷家乐基本已拿到 offer，蚂蚁二面完了，滴滴和字节即将三面，我先把我已经面过的面经先总结出来，其他的不管过没过，这周内我都会总结出来，希望能给到正在找工作同学的帮助。</p><p>在文章里我不仅会列出面试题，还会给到一些答题建议，个人能力有限，也不能保证我回答都正确，<strong>如果有错误，希望能纠正我。</strong></p><h2 id="酷家乐"><a href="#酷家乐" class="headerlink" title="酷家乐"></a>酷家乐</h2><p>酷家乐是我最早面的一家公司，还没被裁的那周二刚好面完，结果周五就被裁了，可能这就是冥冥之中吧。</p><p>面试的部门是工具组，是酷家乐最核心的部门，四面面试官跟我说我面的组是工具团队中的最核心组，会涉及到一些图像相关的技术，比如 Tree.js、WebGL等，所以这个组其实也挺好的，感觉能学到不少技术。</p><h3 id="一面-电话面"><a href="#一面-电话面" class="headerlink" title="一面(电话面)"></a>一面(电话面)</h3><ul><li><p>你在项目如何优化的</p><blockquote><p>我在简历里面写到了性能优化相关的，所以这个问题。</p></blockquote></li></ul><ul><li><p>你做的项目有什么值得说的</p><blockquote><p>基本上就是考察项目的亮点，可以说一些项目难点是如何解决的，或者介绍一些项目中用到的牛逼的技术。</p></blockquote></li><li><p>Ts 有什么优势</p><blockquote><p>讲道理所有现在在网上能查到的优势都是得益于<strong>静态语言</strong>的优势。</p></blockquote></li><li><p>type 和 interface 的区别</p><blockquote><p>这是一个高频题，如果考察 TS，这应该是最容易考察的，网上也都能查到相关的资料，但是很可能忽略一个点：<strong>type 只是一个类型别名，并不会产生类型</strong>。所以其实 type 和 interface 其实不是同一个概念，其实他们俩不应该用来比较的，只是有时候用起来看着类似。</p></blockquote></li><li><p>React 事件机制</p><blockquote><p>我觉得需要答的点：</p><ol><li>React 为什么要用合成事件</li><li>事件机制：注册和分发的过程。这里面至少要说出事件注册都是在元素的最顶层 <code>document</code> 节点上。</li></ol><p>参考资料：<a href="https://toutiao.io/posts/28of14w/preview">一文吃透 React 事件机制原理</a></p></blockquote></li><li><p>聊聊 React 的 diff </p><blockquote><p>聊 diff 建议先看看我之前写过的一篇关于虚拟 DOM 的文章：<a href="https://mp.weixin.qq.com/s/zCGQEpEGJYQWMMvZfyUYHg">从 React 历史的长河里聊虚拟DOM及其价值</a>，有助于理解 diff 的意义。</p><p>diff 的细节可以看我之前写的：<a href="https://mp.weixin.qq.com/s/_jAW4Z3VR-uW0AEnjHgAEw">详解 React 16 的 Diff 策略</a></p></blockquote></li><li><p>React 优化</p><blockquote><p>可以看之前我写的 <a href="https://mp.weixin.qq.com/s/mpL1MxLjBqSO49TRijeyeg">React 函数式组件性能优化指南</a>，对于类组件也有对应的 API。</p></blockquote></li><li><p>怎么理解闭包</p><blockquote><p>基础中的基础，虽然社招考得不多，但是如果连闭包都理解不了，应该会减分不少。闭包由于在规范里没有定义，所以很多人下的定义不一样，理解的角度也不同，但是自己要有一套正确的理解方式，如果按照我的理解 JavaScript 里面所有的函数都是闭包，因为有全局环境，所有的函数都可以访问全局变量。</p></blockquote></li><li><p>节流怎么实现的</p><blockquote><p>防抖和节流的代码还是需要会手写的，这也是一个闭包的例子，</p></blockquote></li><li><p>原型，class B 继承 class A 翻译成 es5 应该是什么样子</p><blockquote><p>说实话，我觉得这道题其实蛮有水平的，即考察了如何写出一个好的继承方式，也对 new 过程进行了考察，还对考察了对 Class 的理解。</p><p>注意的点：<code>class</code> 是有重载功能的，怎么在子类的构造函数里面调用 <code>super</code></p></blockquote></li></ul><h3 id="二面-现场面"><a href="#二面-现场面" class="headerlink" title="二面(现场面)"></a>二面(现场面)</h3><ul><li><p>react 的基本原理</p><blockquote><p>UI = f(state) ，虚拟 DOM、diff 策略、setState</p></blockquote></li><li><p>react 如何做性能优化</p><blockquote><p>这个题也是高频，见一面回答</p></blockquote></li><li><p>redux 的重点概念</p><blockquote><p>store、reduce、action、actionCreater、dispatch</p></blockquote></li><li><p>聊一聊 React 的生命周期</p><blockquote><p>尽量把 React 15 和 16 的进行对比，然后 16 为什么要准备废除那几个生命周期，以及新增的生命周期可以进行替代。</p><p>这个图好好的理解一下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gejro09e6qj31j70u0ah0.jpg" alt="react 生命周期"></p></blockquote></li><li><p>聊一聊 hooks 怎么处理生命周期</p><blockquote><p>讲道理函数式组件是没有生命周期的，但是如何去模拟类组件的生命周期的作用，都是在 <code>useEffect</code> 里面进行操作的，因为生命周期里面所做的基本都是副作用，放到 <code>useEffect</code> 里是最合适的，专门用来处理副作用。</p></blockquote></li><li><p>笔试题一</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = &#123; b ： <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  obj.b = <span class="hljs-number">5</span><br><br>  <span class="hljs-keyword">return</span> obj<br>&#125;<br><br><span class="hljs-keyword">const</span> aa = foo(a)<br><br><span class="hljs-built_in">console</span>.log(a.b)<br><br><span class="hljs-built_in">console</span>.log(aa.b)<br></code></pre></td></tr></table></figure><ul><li>笔试题二：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ofo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bick</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;mybick&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">var</span> myBick = <span class="hljs-keyword">new</span> Ofo()<br><br>Ofo.prototype = <span class="hljs-keyword">new</span> Bick()<br><br><span class="hljs-keyword">var</span> youbick = <span class="hljs-keyword">new</span> Bick()<br><br><span class="hljs-built_in">console</span>.log(myBick.name)<br><br><span class="hljs-built_in">console</span>.log(youbick.name)<br></code></pre></td></tr></table></figure><ul><li><p>笔试题三：考察盒子模型和 <code>box-sizing</code> 属性，判断元素的尺寸和颜色。</p></li><li><p>实现一个 fill 函数，不能用循环。</p><blockquote><p>考察递归</p></blockquote></li><li><p>用 ES5 实现私有变量</p><blockquote><p>考察闭包的使用</p></blockquote></li></ul><h3 id="三面-现场面"><a href="#三面-现场面" class="headerlink" title="三面(现场面)"></a>三面(现场面)</h3><ul><li><p>简历里面的性能优化是如何做的</p><blockquote><p>减少请求频率、图片压缩、<code>React.memo</code>、<code>React.useMemo</code></p></blockquote></li><li><p>class 组件里面如何做性能优化(因为前面我说了用 React.memo 做了性能优化)</p><blockquote><p>shouldComponentUpdate(简称 SCU)。SCU 跟 immutable 强相关，一定要好好理解 react 的 immutable，否则很可能理解不了为什么不能直接去修改 state，然后再去 setState，以及 redux 的 reducer 要返回一个新的对象。</p></blockquote></li><li><p>实现一个 Typescript 里的 Pick</p><blockquote><p><code>type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P] &#125;</code></p></blockquote></li><li><p>手写 Promise.all</p></li><li><p>手写并发只能 10 个</p></li><li><p>算法题，怎么判断单链表相交。</p><blockquote><p>很多种方法，我当时说的是最后一个节点如果相同，那么就代表相交。</p></blockquote></li><li><p>算法题，怎么找到第一个相交的节点。</p><blockquote><p>同时遍历两个链表到尾部，同时记录两个链表的长度。若两个链表最后的一个节点相同，则两个链表相交。有两个链表的长度后，我们就可以知道哪个链表长，设较长的链表长度为len1,短的链表长度为len2。则先让较长的链表向后移动(len1-len2)个长度。然后开始从当前位置同时遍历两个链表，当遍历到的链表的节点相同时，则这个节点就是第一个相交的节点。</p><p>这是我刚想到的一种方式，不过当时面试的时候我记得好像更简单，但是想不起来了。</p></blockquote></li></ul><h3 id="四面-现场面"><a href="#四面-现场面" class="headerlink" title="四面(现场面)"></a>四面(现场面)</h3><ul><li><p>你觉得你在公司人缘怎么样</p></li><li><p>你觉得你为你们小组做了什么贡献</p></li><li><p>为什么要离职</p></li><li><p>除了我们公司还投了其他公司吗</p></li><li><p>薪资和层级有什么要求</p></li><li><p>如何垂直水平居中</p></li><li><p>你看过开源库的源码吗？</p></li><li><p>那你聊聊 React 的源码，把你记得起的讲一讲</p><blockquote><p>我看过 React 的一部分源码的，所以关于 React 源码更新部分的东西，应该基本都能说个大概。</p></blockquote></li><li><p>FiberNode 有哪些属性</p></li><li><p>stadeNode 有什么用？</p></li><li><p>还有一些技术问题想不起来了</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>酷家乐面试体验还是不错的，我是一面电话面，面完觉得 OK 之后就叫到公司去现场面试，6 点半下班了就骑车去了酷家乐，七点开始面试，一口气面完了三面，饭都没来得及吃，不过面试官很好给我倒了水。</p><p>感觉面试官对我的项目似乎不太敢兴趣，很少问项目的东西，可能由于他们是工具组，连我简历里面组件库相关的也没面，考察基础的比较多，基础考察得比较全面。</p><p>但是由于考虑到我之前做的项目复杂性不够，以及工作年限的问题，给到的评级不高，导致薪资也不是特别高，但是已经是这个评级的顶峰了，要是没有更好的 offer 酷家乐还是非常值得去的，特别是工具组。</p><h2 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ul><li><p>react 16 生命周期有什么改变</p><blockquote><p><code>componentWillMount</code>，<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code> 准备废除，新增了 <code>static getDerivedStateFromProps</code> 和 <code>getSnapshotBeforeUpdate</code></p><p>我还详细的介绍了为什么要用 <code>getDerivedStateFromProps</code> 来代替即将废除的三个生命周期，主要是16 版本 render 之前的生命周期可能会被多次执行，具体的可看我的这篇文章：<a href="https://mp.weixin.qq.com/s/dONYc-Y96baiXBXpwh1w3A">Deep In React之浅谈 React Fiber 架构(一)</a></p></blockquote></li><li><p>详细的介绍一下 <code>getDerivedStateFromProps</code></p></li><li><p>你在项目中如何做性能优化的</p></li><li><p><code>flex: 0 1 auto;</code> 是什么意思？</p><blockquote><p>flex 这个属性常考题，好好把阮老师的那篇 <a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">flex 语法篇</a>看完 flex 的面试题基本没问题。</p></blockquote></li><li><p>less 的 &amp; 代表什么？</p></li><li><p>算法题：求最大公共前缀，如 <code>[&#39;aaafsd&#39;, &#39;aawwewer&#39;, &#39;aaddfff&#39;] =&gt; &#39;aa&#39;</code></p><blockquote><p>不能调试，全靠编程素养，只能面试官才能运行。</p></blockquote></li><li><p>interface 和 type 的区别</p><blockquote><p>又考了，上面有回答</p></blockquote></li><li><p>有用状态管理吗？</p><blockquote><p>我常用的是 redux 和 dva，然后再聊了聊区别已经 redux 的理念</p></blockquote></li><li><p>有用 ssr 吗？</p><blockquote><p>没用过</p></blockquote></li><li><p>node 熟悉吗？</p><blockquote><p>写得少</p></blockquote></li></ul><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ul><li><p>class 组件与函数式组件的区别</p><blockquote><p>生命周期、设计理念，感觉这道题比较开发，可以看看 dan 的这篇：<a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？</a></p></blockquote></li><li><p>css 优先级</p><blockquote><p>important &gt; 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p></blockquote></li><li><p>避免 css 全局污染。</p><blockquote><p>我常用的 css modules</p></blockquote></li><li><p>css modules 的原理</p><blockquote><p>生成唯一的类名</p></blockquote></li><li><p>有一个a标签，如何动态的决定他的样式。</p><blockquote><p>我说了先写几个 css，然后外部传一个前缀的方式。面试官问了都要这样吗？我说可以通过 context 的方式，就不需要每个组件都传了。</p></blockquote></li><li><p>import 和 require 导入的区别</p><blockquote><p>高频题，考察 ES6 模块和 CommonJS 模块 的区别。关键点：1. 前者是值的引用，后者是值的拷贝。 2.前者编译时输出接口，后者运行时加载。</p><p>推荐文章：<a href="https://juejin.im/post/5aaa37c8f265da23945f365c">前端模块化：CommonJS,AMD,CMD,ES6</a></p></blockquote></li><li><p>require 有什么性能问题</p><blockquote><p>好好想想上一个题的区别就能想到了</p></blockquote></li><li><p>组件库如何做按需加载</p><blockquote><p>我常用的是<code>babel-plugin-import</code> </p></blockquote></li><li><p>webpack 如何实现动态加载</p><blockquote><p>讲道理 webpack 动态加载就两种方式：<code>import()</code>和 <code>require.ensure</code>，不过他们实现原理是相同的。</p><p>我觉得这道题的重点在于动态的创建 script 标签，以及通过 <code>jsonp</code> 去请求 <strong>chunk</strong>，推荐的文章是：<a href="https://juejin.im/post/5d26e7d1518825290726f67a">webpack是如何实现动态导入的</a></p></blockquote></li><li><p>react 里有动态加载的 api 吗？</p><blockquote><p>React.lazy</p></blockquote></li><li><p>React.lazy 的原理是啥？</p></li><li><p>webpack 能动态加载 require 引入的模块吗？</p><blockquote><p>应该是不能的，前面说了，webpack 支持动态导入基本上只能用<code> import()</code> 和<code>require.ensure</code>。</p></blockquote></li><li><p>require 引入的模块 webpack 能做 Tree Shaking 吗？</p><blockquote><p>不能，Tree Shaking 需要静态分析，只有 ES6 的模块才支持。</p></blockquote></li><li><p>设计一个input 组件需要哪些属性。我说了 value 、defaultValue、onChange</p></li><li><p>value 的类型是什么？</p></li><li><p>onChange 怎么规定 value 的类型</p></li><li><p>interface 和 type 的区别</p></li><li><p>写一个 promise 重试函数，可以设置时间间隔和次数。<code>function foo(fn, interval, times) &#123;&#125;</code></p><blockquote><p>常规题，网上有参考答案的。</p></blockquote></li></ul><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ul><li><p>组件平台有哪些功能？</p><blockquote><p>详细的跟我讨论组件平台的设计，因为他们也想做一个组件平台。</p></blockquote></li><li><p>实现一个 redux</p><blockquote><p>实现 <code>createStore</code> 的功能，关键点发布订阅的功能，以及取消订阅的功能。</p></blockquote></li><li><p>用 ts 实现一个 redux</p><blockquote><p>简单的加上类型，我写的类型没有 redux 源码那么复杂，当时写得比较简单。</p></blockquote></li></ul><h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>一面的时候其实我自己感觉答得不是特别好，连 less 的语法都忘记了，当时面下来感觉要凉了，平时写 样式的时间确实太少了。</p><p>很幸运的时候还是给我过了，二面面试官我觉得面得很专业，基本都是从浅入深的考察知识的深度，我感觉答得还可以，因为我是属于那种会的就尽量深一点，暂时不用的就很少花时间，所以我目前知识的广度很有欠缺，对于 node、ssr、移动端、小程序这些方面我的能力都很薄弱，但是面试的时候如果你不熟悉，直接说不熟悉就行，他就不会面了。</p><p>我准备面试之前对我自己的要求就是，我会的尽量不会很快就被问倒，所以我重点复习了我擅长的知识。</p><p>面下来感觉拼多多也没有想象中那么难，虽然拼多多薪资算行业内高的，不过拼多多在上海，我在杭州，另外就是强制上 6 天班，我比较忌惮这点。考虑到我和女朋友本来就是异地，要是单休，而且节假日也会比正常的少，见面的机会就更少了。</p><p>反正选 offer 这种事还是尽量综合考虑吧，团队、薪资、个人生活都应该考虑进去。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote><p>我是桃翁，一个爱思考的前端er，期待你的关注。</p></blockquote><p>如果你最近也在找工作，欢迎找我交流，下面是我公众号。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/19/16e81112420c2ff3?w=344&h=344&f=jpeg&s=3371"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;离职原因看我这篇文章吧：&lt;a href=&quot;https://mp.weixin.qq.com/s/v8aSfpxPfuKSXS99jV5jaw</summary>
      
    
    
    
    <category term="笔记本" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>离开蘑菇街后，我最近的一些想法</title>
    <link href="http://example.com/index.php/archives/317/"/>
    <id>http://example.com/index.php/archives/317/</id>
    <published>2020-04-30T08:19:00.000Z</published>
    <updated>2020-04-30T08:19:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>被裁之后我就一直在家复习，面试，所以就一直没有写文章，没有太多心思搭理公众号，现在也拿了两个 offer 了，所以开始回到正途。</p><h2 id="胎死腹中的-Vue-3-0-Beta-文章"><a href="#胎死腹中的-Vue-3-0-Beta-文章" class="headerlink" title="胎死腹中的 Vue 3.0 Beta 文章"></a>胎死腹中的 Vue 3.0 Beta 文章</h2><p>4  月 17 日，早上我收到了浪浪(浪里行舟)的消息，给我发了一个微博消息，尤大在微博上宣布发布 <strong>Vue 3.0 Beta</strong> 了，然后跟我说这是热点，让我写一篇文章，我就暂停了前一天晚上定时发的文章，准备写一篇详细介绍 Vue 3.0 Beta 所发布的东西。</p><p>所以当天我早早的来到了公司，希望在上班前能搞定，然后就开始翻阅 <code>vue-next</code> 的文档以及草案，想从根源去探究 <strong>vue 3.0 Beta</strong> 能给我们带来什么。</p><p>没过多久，在我们技术部的群里有人就 @ 了所有人，让我们去看下邮件，邦哥(化名)发了一封邮件，每个人都要看一下。</p><p>我由于还在写文章，收集资料，就没那么快去看邮件，不一会儿，突然安静的 9L 就开始叽叽喳喳，议论纷纷，这时我感觉应该是一件大事儿。</p><p>我就迅速打开了邮件，第一段就描述着公司在今天要优化 140+  的人，第二段描述着公司的核心方向，<strong>直播和品牌特卖</strong>，在这个时候，我已经能意识到，我可能要被优化了，也许我们组绝大部分人都会被优化，因为我们组基本是做内部系统的，跟核心业务极大的偏离。</p><p>我也加入到他们叽叽喳喳的氛围中，放下了手上所有的事情，和旁边的同事讨论着裁员的事情。</p><h2 id="被裁"><a href="#被裁" class="headerlink" title="被裁"></a>被裁</h2><p>大概在十一点左右的时候，我左手边的一个应届生小声的说，我凉了，HR 让我去 11 楼一趟，然后我将这个事情传达给了我们的一个小群，以及我对接的后端，并询问他他们组的情况。</p><p>没想到聊着聊着，他跟我留下了一句，<strong>我中了，我先上去了</strong>。</p><p>接下来就眼睁睁的看着身边的人一个一个的都被喊上去，从工作一年的到两年的(包括我)，再到四年的，以及更多的。</p><p>到中午的时候，我们组只留下一个人没沟通了，是一个工作了四年多的老员工了，就坐在我旁边，他很慌，因为大家都拿着赔偿金(n+1.5)，他也想有。</p><p>一直等到一点、两点、三点、四点，五点，他放弃了，成为了我们这层楼我们组唯一个留下的。</p><p>后面就开始办理离职手续，交接项目，晚上我们整个前端到旁边的<strong>修舍酒店</strong>进行聚餐，虽然离别时悲伤的，但是被裁的人拿到高于常规的赔偿，是幸运的。</p><p>这次裁员对于应届生来说是最惨的，他们工作年限不久，不到一年，对于社招来说，是非常的吃亏的。工作年限不够，而且整个大环境来说又不好，现在又被裁没有工作，大公司很少会招工作年限这么短的，去小公司又有可能被压价。</p><p>唉，不想写这些消极情绪的了，在这被裁的两周里，空闲下来我也思考了很多，接下来说一些我的见解，希望能给到大家帮助。</p><h2 id="定时更新简历"><a href="#定时更新简历" class="headerlink" title="定时更新简历"></a>定时更新简历</h2><p>之前我在知乎上看到一个 HR 的回答里面说到，不管你跳不跳槽，其实都可以定时更新自己的简历。</p><p>我是比较赞成他的说法的，我倾向于半年更新一次简历，因为在更新简历的过程中你会去思考，去总结你在之前的这半年里，你做了什么有价值的东西，有没有什么亮点。</p><p>一旦发现在这半年里没有做出什么成绩，那么你也许需要在后面的时间里调整自己的工作方式，思考为什么没有值得写在简历里面的东西，然后给自己定目标，做规划，尽量在半年后可以有一些亮点可以跟别人吹。</p><h2 id="多做总结"><a href="#多做总结" class="headerlink" title="多做总结"></a>多做总结</h2><p>总结这个东西，其实每个人都会觉得应该做，但是很少人真正的去执行，也许是因为太忙，也许是因为懒，也许是因为觉得他不重要。</p><p>我相信很多人会有这样的感觉，当别人问你做的项目有没有什么难度，在做的时候遇到了什么困难，以及怎么解决的。你会感觉都已经做出来了，感觉没什么难的了。</p><p>其实在我看来，这其实就是没有及时的总结导致的。</p><p>我的建议是当你遇到难题并解决之后，<strong>马上</strong>记下来，因为这个时候是你最有动力，也是最清醒的时刻，一旦你想<strong>后面有空了再记</strong>，那么基本上就是不会记了。</p><p>另外就是每个项目完结之后也需要进行总结，遇到的问题，项目的架构，项目的价值等等，这些东西是以后可以跟面试官聊项目的资本。如果不记下来，当你写简历的时候，很可能会把关键的地方忘掉。</p><h2 id="忙一点的公司挺好"><a href="#忙一点的公司挺好" class="headerlink" title="忙一点的公司挺好"></a>忙一点的公司挺好</h2><p>可能对于这一点很多人会觉得我政治不正确，觉得理想的工作不应该是朝九晚六，到点下班么。</p><p>但是我最近在观察那些发展得好的企业，加班都比较严重，比如阿里、腾讯、字节跳动、拼多多等，当然这些公司都会给你更高的薪水。</p><p>为什么我会绝对忙的公司其实挺好呢？主要是因为公司发展迅速，意味着就会扩大生产，那么就需要更多的劳动力，但是对于招聘合适的人又是一个急不得的事儿，所以留在公司的人可能会很忙，得干超出正常一个人所干的事儿。</p><p>这样其实你可以有更多需求做，也许是重复的，也许是新的东西，不管怎么样，一旦你代码写得多，你能更可能发现到别人发现不到的痛点，也会给公司做更多的贡献，其实对于成长是有帮助的。</p><p>可能有人会觉得我只是一个打工的，在规定的时间把东西做完，下班时间再去学习，其实这种方式对于大部分人来说不是特别的高效，因为学习这件事其实是反人性的，下班了也许你更多的时间会用于其他娱乐中。</p><p>再说一下对于比较闲的公司，也许很多人都想去，比如外企，相对国内的大厂来说要轻松很多，但是闲的公司很容易让人养成懒的习惯，特别是对于工作不久的，一旦养成了懒惰的习惯，就会危害自己一辈子。</p><p><strong>我希望这一点不要跟我争论，如果你希望去不忙的公司，你去就行了，也不用说服我。</strong></p><blockquote><p> 可以想想之前甲骨文裁员的时候，那些老员工的无奈。</p></blockquote><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>蘑菇街还是一家很有良心的公司，我也很感谢公司给我带来的成长，希望蘑菇街能越来越好。</p><p>这次裁员其实对于我来说影响不是特别的大，因为我其实在工作期间会偶尔出去其他公司面试，面试的目的其实不仅仅是想换份工作，另外主要也想看看自己在面试中发现自己哪些不足，然后好好的改进。</p><p> 刚好在裁员的那一周，我也过了一家杭州 1000 人左右的公司，但是觉得给的薪资不是特别满意，所以我被裁之后就安心在家复习，继续投一些大点的公司。</p><p>投递的公司有蚂蚁、滴滴、字节跳动，拼多多(已经面完，可拿 offer)，没拿到 offer 的也都在流程中(二面或者三面)，基本上还没有挂过。</p><p>后面我会将我最近的面试题总结下来，以及我是如何复习的，希望能给到正在找工作或者想找工作的人帮助。</p><blockquote><p> 我是桃翁，期待你的关注</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;被裁之后我就一直在家复习，面试，所以就一直没有写文章，没有太多心思搭理公众号，现在也拿了两个 offer 了，所以开始回到正途。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="随想" scheme="http://example.com/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>理解 JavaScript 中的执行上下文和执行栈</title>
    <link href="http://example.com/index.php/archives/315/"/>
    <id>http://example.com/index.php/archives/315/</id>
    <published>2020-04-02T08:52:06.000Z</published>
    <updated>2020-04-02T08:52:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="译者序"><a href="#译者序" class="headerlink" title="译者序"></a>译者序</h2><p>最近在研究 JavaScript 基础性的东西，但是看到对于<strong>执行上下文</strong>的解释我发现有两种，一种是执行上下文包含：scope(作用域)、variable object(变量对象)、this value(this 值)，另外一个种是包含：lexical environment(词法环境)、variable environment(变量环境)、this value(this 值)。</p><p>后面我查阅了不少博客以及 ES3 和 ES5 的规范才了解到，第一种是 ES3 的规范，经典书籍《JavaScript高级程序设计》第三版就是这样解释的，也是网上广为流传的一种，另一种是 ES5 的规范。</p><p>然后我接着又去翻了 ES2018 中的，发现又有变化了，已经增加了更多的内容了，考虑到这部分内容颇为复杂，准备后面再进行总结分享，查资料的时候看到这篇讲执行上下文(ES5 )的还不错，所以就翻译出来先分享给大家。</p><p>以后看到变量对象、活动对象知道是 ES3 里面的内容，而如果是词法环境、变量环境这种词就是 ES5 以后的内容。</p><p>以下是正文：</p><h2 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h2><p>简而言之，执行上下文是计算和执行 JavaScript 代码的环境的抽象概念。每当 Javascript 代码在运行的时候，它都是在执行上下文中运行。</p><h3 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h3><p>JavaScript 中有三种执行上下文类型。</p><ul><li><strong>全局执行上下文</strong> — 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 <code>this</code> 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。</li><li><strong>函数执行上下文</strong> — 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤。</li><li><strong>Eval 函数执行上下文</strong> — 执行在 <code>eval</code> 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 <code>eval</code>，所以在这里我不会讨论它。</li></ul><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）的数据结构，被用来存储代码运行时创建的所有执行上下文。</p><p>当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p><p>引擎会执行处于栈顶的执行上下文的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>让我们通过下面的代码示例来理解：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-title">functionfirst</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  second();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">functionsecond</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><br>first();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="http://imgs.taoweng.site/2020-03-19-145946.png"><br>上述代码的执行上下文栈。</p><p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入当前执行栈。当遇到 <code>first()</code> 函数调用时，JavaScript 引擎为该函数创建一个新的执行上下文并把它压入当前执行栈的顶部。</p><p>当从 <code>first()</code> 函数内部调用 <code>second()</code> 函数时，JavaScript 引擎为 <code>second()</code> 函数创建了一个新的执行上下文并把它压入当前执行栈的顶部。当 <code>second()</code> 函数执行完毕，它的执行上下文会从当前栈弹出，并且控制流程到达下一个执行上下文，即 <code>first()</code> 函数的执行上下文。</p><p>当 <code>first()</code> 执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p><h3 id="怎么创建执行上下文？"><a href="#怎么创建执行上下文？" class="headerlink" title="怎么创建执行上下文？"></a>怎么创建执行上下文？</h3><p>到现在，我们已经看过 JavaScript 怎样管理执行上下文了，现在让我们了解 JavaScript 引擎是怎样创建执行上下文的。</p><p>创建执行上下文有两个阶段：<strong>1) 创建阶段</strong> 和 <strong>2) 执行阶段</strong>。</p><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p><ol><li><strong>this</strong> 值的决定，即我们所熟知的 <strong>this 绑定</strong>。</li><li>创建<strong>词法环境</strong>组件。</li><li>创建<strong>变量环境</strong>组件。</li></ol><p>所以执行上下文在概念上表示如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ExecutionContext = &#123;<br>  ThisBinding = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">this</span> <span class="hljs-attr">value</span>&gt;</span>,</span><br><span class="xml">  LexicalEnvironment = &#123; ... &#125;,</span><br><span class="xml">  VariableEnvironment = &#123; ... &#125;,</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="this-绑定："><a href="#this-绑定：" class="headerlink" title="this 绑定：**"></a>this 绑定：**</h4><p>在全局执行上下文中，<code>this</code> 的值指向全局对象。(在浏览器中，<code>this</code>引用 Window 对象)。</p><p>在函数执行上下文中，<code>this</code> 的值取决于该函数是如何被调用的。如果它被一个引用对象调用，那么 <code>this</code> 会被设置成那个对象，否则 <code>this</code> 的值被设置为全局对象或者 <code>undefined</code>（在严格模式下）。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> foo = &#123;<br>  <span class="hljs-attr">baz</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>foo.baz();   <span class="hljs-comment">// &#x27;this&#x27; 引用 &#x27;foo&#x27;, 因为 &#x27;baz&#x27; 被</span><br>             <span class="hljs-comment">// 对象 &#x27;foo&#x27; 调用</span><br><br><span class="hljs-keyword">let</span> bar = foo.baz;<br><br>bar();       <span class="hljs-comment">// &#x27;this&#x27; 指向全局 window 对象，因为</span><br>             <span class="hljs-comment">// 没有指定引用对象</span><br></code></pre></td></tr></table></figure><h4 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h4><p><a href="http://ecma-international.org/ecma-262/6.0/">官方的 ES6</a> 文档把词法环境定义为</p><blockquote><p><strong>词法环境</strong>是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义<strong>标识符</strong>和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用<strong>outer</strong>词法环境的空值组成。</p></blockquote><p>简单来说<strong>词法环境</strong>是一种持有<strong>标识符—变量映射</strong>的结构。（这里的<strong>标识符</strong>指的是变量/函数的名字，而<strong>变量</strong>是对实际对象[包含函数类型对象]或原始数据的引用）。</p><p>现在，在词法环境的<strong>内部</strong>有两个组件：(1) <strong>环境记录器</strong>和 (2) 一个<strong>外部环境的引用</strong>。</p><ol><li><strong>环境记录器</strong>是存储变量和函数声明的实际位置。</li><li><strong>外部环境的引用</strong>意味着它可以访问其父级词法环境（作用域）。</li></ol><blockquote><p>译者注：外部环境已经跟 ES3 规定的作用域的作用类似</p></blockquote><p><strong>词法环境</strong>有两种类型：</p><ul><li><strong>全局环境</strong>（在全局执行上下文中）是没有外部环境引用的词法环境。全局环境的外部环境引用是 <strong>null</strong>。它拥有内建的 Object/Array/等、在环境记录器内的原型函数（关联全局对象，比如 window 对象）还有任何用户定义的全局变量，并且 <code>this</code>的值指向全局对象。</li><li>在<strong>函数环境</strong>中，函数内部用户定义的变量存储在<strong>环境记录器</strong>中。并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。</li></ul><p><strong>环境记录器</strong>也有两种类型（如上！）：</p><ol><li><strong>声明式环境记录器</strong>存储变量、函数和参数。</li><li><strong>对象环境记录器</strong>用来定义出现在<strong>全局上下文</strong>中的变量和函数的关系。</li></ol><p>简而言之，</p><ul><li>在<strong>全局环境</strong>中，环境记录器是对象环境记录器。</li><li>在<strong>函数环境</strong>中，环境记录器是声明式环境记录器。</li></ul><p><strong>注意 —</strong> 对于<strong>函数环境</strong>，<strong>声明式环境记录器</strong>还包含了一个传递给函数的 <code>arguments</code> 对象（此对象存储索引和参数的映射）和传递给函数的参数的 <strong>length</strong>。</p><p>抽象地讲，词法环境在伪代码中看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">GlobalExectionContext = &#123;<br>  <span class="hljs-attr">LexicalEnvironment</span>: &#123;<br>    <span class="hljs-attr">EnvironmentRecord</span>: &#123;<br>      <span class="hljs-attr">Type</span>: <span class="hljs-string">&quot;Object&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br>    <span class="hljs-attr">outer</span>: &lt;<span class="hljs-literal">null</span>&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  <span class="hljs-attr">LexicalEnvironment</span>: &#123;<br>    <span class="hljs-attr">EnvironmentRecord</span>: &#123;<br>      <span class="hljs-attr">Type</span>: <span class="hljs-string">&quot;Declarative&quot;</span>,<br>      <span class="hljs-comment">// 在这里绑定标识符</span><br>    &#125;<br>    <span class="hljs-attr">outer</span>: <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Global</span> <span class="hljs-attr">or</span> <span class="hljs-attr">outer</span> <span class="hljs-attr">function</span> <span class="hljs-attr">environment</span> <span class="hljs-attr">reference</span>&gt;</span></span><br><span class="xml">  &#125;</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="变量环境："><a href="#变量环境：" class="headerlink" title="变量环境："></a>变量环境：</h4><p>它同样是一个词法环境，其环境记录器持有<strong>变量声明语句</strong>在执行上下文中创建的绑定关系。</p><p>如上所述，变量环境也是一个词法环境，所以它有着上面定义的词法环境的所有属性。</p><p>在 ES6 中，<strong>词法环境</strong>组件和<strong>变量环境</strong>的一个不同就是前者被用来存储函数声明和变量（<code>let</code> 和 <code>const</code>）绑定，而后者只用来存储 <code>var</code> 变量绑定。</p><p>我们看点样例代码来理解上面的概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">const</span> b = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">var</span> c;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multiply</span>(<span class="hljs-params">e, f</span>) </span>&#123;<br> <span class="hljs-keyword">var</span> g = <span class="hljs-number">20</span>;<br> <span class="hljs-keyword">return</span> e * f * g;<br>&#125;<br><br>c = multiply(<span class="hljs-number">20</span>, <span class="hljs-number">30</span>);<br></code></pre></td></tr></table></figure><p>执行上下文看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript">GlobalExectionContext = &#123;<br><br>  <span class="hljs-attr">ThisBinding</span>: &lt;Global Object&gt;,<br><br>  LexicalEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 在这里绑定标识符<br>      a: &lt; uninitialized &gt;,<br>      b: &lt; uninitialized &gt;,<br>      multiply: &lt; func &gt;<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;,<br><br>  VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Object&quot;,<br>      // 在这里绑定标识符<br>      c: undefined,<br>    &#125;<br>    outer: &lt;null&gt;<br>  &#125;<br>&#125;<br><br>FunctionExectionContext = &#123;<br>  ThisBinding: &lt;Global Object&gt;,<br><br>  LexicalEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 在这里绑定标识符<br>      Arguments: &#123;0: 20, 1: 30, length: 2&#125;,<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;,<br><br>VariableEnvironment: &#123;<br>    EnvironmentRecord: &#123;<br>      Type: &quot;Declarative&quot;,<br>      // 在这里绑定标识符<br>      g: undefined<br>    &#125;,<br>    outer: &lt;GlobalLexicalEnvironment&gt;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong> — 只有遇到调用函数 <code>multiply</code> 时，函数执行上下文才会被创建。</p><p>可能你已经注意到 <code>let</code> 和 <code>const</code> 定义的变量并没有关联任何值，但 <code>var</code> 定义的变量被设成了 <code>undefined</code>。</p><p>这是因为在创建阶段时，引擎检查代码找出变量和函数声明，虽然函数声明完全存储在环境中，但是变量最初设置为 <code>undefined</code>（<code>var</code> 情况下），或者未初始化（<code>let</code> 和 <code>const</code> 情况下）。</p><p>这就是为什么你可以在声明之前访问 <code>var</code> 定义的变量（虽然是 <code>undefined</code>），但是在声明之前访问 <code>let</code> 和 <code>const</code> 的变量会得到一个引用错误。</p><p>这就是我们说的变量声明提升。</p><h3 id="执行阶段"><a href="#执行阶段" class="headerlink" title="执行阶段"></a>执行阶段</h3><p>这是整篇文章中最简单的部分。在此阶段，完成对所有这些变量的分配，最后执行代码。</p><p><strong>注意</strong> — 在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 <code>let</code> 变量的值，它会被赋值为 <code>undefined</code>。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们已经讨论过 JavaScript 程序内部是如何执行的。虽然要成为一名卓越的 JavaScript 开发者并不需要学会全部这些概念，但是如果对上面概念能有不错的理解将有助于你更轻松，更深入地理解其他概念，如变量声明提升，作用域和闭包。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;译者序&quot;&gt;&lt;a href=&quot;#译者序&quot; class=&quot;headerlink&quot; title=&quot;译者序&quot;&gt;&lt;/a&gt;译者序&lt;/h2&gt;&lt;p&gt;最近在研究 JavaScript 基础性的东西，但是看到对于&lt;strong&gt;执行上下文&lt;/strong&gt;的解释我发现有两种，一种是执</summary>
      
    
    
    
    <category term="笔记本" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React 代码规范</title>
    <link href="http://example.com/index.php/archives/314/"/>
    <id>http://example.com/index.php/archives/314/</id>
    <published>2020-04-02T08:51:22.000Z</published>
    <updated>2020-04-02T08:51:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a><strong>基本规范</strong></h2><ul><li>每个文件只包含的一个 React 组件：<ul><li>联系紧密的组件可以使用「命名空间」的形式；</li><li>每个文件中可包含多个纯函数组件。</li></ul></li><li>始终使用 JSX 语法，不要使用 <code>React.createElement</code> 创建 ReactElement，以提高编写速度、可读性、可维护性（没有 JSX 转换的特殊场景例外，如在 <code>console</code> 中测试组件）。</li></ul><h2 id="文件规范"><a href="#文件规范" class="headerlink" title="文件规范"></a>文件规范</h2><ul><li><p>组件文件使用一致的<code>.js</code>或 <code>.jsx</code>后缀。所有组件文件的后缀名从<code>.js</code>或<code>.jsx</code>中任选其一。不应在项目中出现部分组件为<code>.js</code>文件，部分为<code>.jsx</code>的情况。</p></li><li><p>每个存放组件的目录使用一个<code>index.js/index.jsx</code>以命名导出的形式暴露所有组件。同目录内的组件相互引用使用<code>import Foo from &#39;./Foo&#39;;</code>进行。引用其它目录的组件使用<code>import &#123;Foo&#125; from &#39;../component&#39;;</code>进行。</p></li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li><p>文件名：使用<strong>大驼峰命名法（PascalCase）</strong>，如 MyComponent.jsx；</p></li><li><p>组件命名：组件名称和文件名一致，如 MyComponent.jsx 里的组件名应该是 MyComponent；一个目录的根组件使用 index.jsx 命名，以目录名称作为组件名称；</p></li><li><p>引用命名：React 组件使用大驼峰命名法（PascalCase）；</p></li><li><p>高阶组件使用camelCase命名。高阶组件事实上并非一个组件，而是一个“生成组件类型”的函数，因此遵守JavaScript函数命名的规范，使用camelCase命名。</p></li><li><p>使用<code>onXxx</code>形式作为<code>props</code>中用于回调的属性名称。使用统一的命名规则用以区分<code>props</code>中回调和非回调部分的属性，在JSX上可以清晰地看到一个组件向上和向下的逻辑交互。</p></li><li><p>使用withXxx或xxxable形式的词作为高阶组件的名称。高阶组件是为组件添加行为和功能的函数，因此使用如上形式的词有助于对其功能进行理解。</p></li></ul><h3 id="带命名空间的组件"><a href="#带命名空间的组件" class="headerlink" title="带命名空间的组件"></a>带命名空间的组件</h3><ul><li>如果一个组件有许多关联子组件，可以以该组件作为命名空间编写、调用子组件。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Row</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Label</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Input</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;&#125;<br><br>Form.Row = Row;<br>Form.Label = Label;<br>Form.Input = Input;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Form;<br><br><span class="hljs-comment">// refence Form component</span><br><span class="hljs-keyword">import</span> Form <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Form&#x27;</span>;<br><br><span class="hljs-keyword">const</span> App = (<br>  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Form</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">Form.Row</span>&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form.Label</span> /&gt;</span></span><br><span class="xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Form.Input</span> /&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Form.Row</span>&gt;</span></span><br><span class="xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Form</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><ul><li>在组件行内设置属性（以便 propTypes 校验），不要在外部改变属性的值；</li><li>属性较多使用 <code>&#123;…this.props&#125;</code> 语法；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><br><span class="hljs-keyword">const</span> props = &#123;&#125;;<br>props.foo = x;<br>props.bar = y;<br><span class="hljs-keyword">const</span> component = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Component</span> &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>;<br></code></pre></td></tr></table></figure><ul><li>属性值明确为 <code>true</code> 时，省略值。</li></ul><h3 id="属性对齐方式"><a href="#属性对齐方式" class="headerlink" title="属性对齐方式"></a>属性对齐方式</h3><ul><li>属性较少时可以行内排列；</li><li>属性较多时每行一个属性，闭合标签单独成行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad - too long</span><br>&lt;input type=<span class="hljs-string">&quot;text&quot;</span> value=&#123;<span class="hljs-built_in">this</span>.state.newDinosaurName&#125; onChange=&#123;<span class="hljs-built_in">this</span>.inputHandler.bind(<span class="hljs-built_in">this</span>, <span class="hljs-string">&#x27;newDinosaurName&#x27;</span>)&#125; /&gt;  <br><br><span class="hljs-comment">// bad - aligning attributes after the tag</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>  </span></span><br><span class="hljs-tag"><span class="xml">       <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.newDinosaurName&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">       <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.inputHandler.bind(this,</span> &#x27;<span class="hljs-attr">newDinosaurName</span>&#x27;)&#125; /&gt;</span></span><br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>  </span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.newDinosaurName&#125;</span></span></span><br><span class="hljs-tag"><span class="xml">  <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.inputHandler.bind(this,</span> &#x27;<span class="hljs-attr">newDinosaurName</span>&#x27;)&#125;</span></span><br><span class="hljs-tag"><span class="xml"> /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="属性空格"><a href="#属性空格" class="headerlink" title="属性空格"></a>属性空格</h3><ul><li>属性 <code>=</code> 前后不要添加空格</li><li>JSX 中的花括号前后不要添加空格。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>&lt;Foo bar=&#123; baz &#125; foo = <span class="hljs-string">&quot;bar&quot;</span> /&gt;<br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> <span class="hljs-attr">bar</span>=<span class="hljs-string">&#123;baz&#125;</span> <span class="hljs-attr">foo</span>=<span class="hljs-string">&quot;bar&quot;</span> /&gt;</span></span><br><br><span class="hljs-comment">// good &#123; left: &#x27;20px&#x27; &#125; 为一个对象</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">left:</span> &#x27;<span class="hljs-attr">20px</span>&#x27; &#125;&#125; /&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="propTypes-及默认值"><a href="#propTypes-及默认值" class="headerlink" title="propTypes 及默认值"></a><code>propTypes</code> 及默认值</h3><ul><li>组件属性都应该在 <code>propTypes</code> 中声明类型；</li><li>始终明确指定非必选属性的默认值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SFC</span>(<span class="hljs-params">&#123; foo, bar, children &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><br><span class="hljs-comment">// good</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SFC</span>(<span class="hljs-params">&#123; foo, bar, children &#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;foo&#125;&#123;bar&#125;&#123;children&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br>SFC.propTypes = &#123;<br>  <span class="hljs-attr">foo</span>: PropTypes.number.isRequired,<br>  <span class="hljs-attr">bar</span>: PropTypes.string,<br>  <span class="hljs-attr">children</span>: PropTypes.node,<br>&#125;;<br><br>SFC.defaultProps = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-attr">children</span>: <span class="hljs-literal">null</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li>JSX 属性使用<strong>双引号</strong> <code>&quot;</code>；</li><li>JS 使用<strong>单引号</strong> <code>&#39;</code>；</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="() 使用"></a><code>()</code> 使用</h2><ul><li>多行的 JSX 使用 () 包裹，有组件嵌套时使用多行模式；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br> <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ComponentOne</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ComponentTwo</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">var</span> multilineJsx = (  <br>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">Nav</span> /&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></span><br> );<br><br> <span class="hljs-comment">// good</span><br> <span class="hljs-keyword">return</span> (<br>   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">ComponentOne</span> /&gt;</span></span><br><span class="xml">     <span class="hljs-tag">&lt;<span class="hljs-name">ComponentTwo</span> /&gt;</span></span><br><span class="xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><ul><li>单行 JSX 省略 ()</li></ul><h2 id="自闭合标签"><a href="#自闭合标签" class="headerlink" title="自闭合标签"></a>自闭合标签</h2><ul><li>自闭合所有没有子组件的标签；</li><li>自闭合标签 <strong><code>/</code> 前留一个空格</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>&lt;Logo&gt;&lt;/Logo&gt;<br><br><span class="hljs-comment">// very bad</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span>                 /&gt;</span></span><br><br><span class="hljs-comment">// bad</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo</span></span></span><br><span class="hljs-tag"><span class="xml"> /&gt;</span></span><br><br><span class="hljs-comment">// good</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Logo</span> /&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>事件函数用 <code>public class fields</code> 型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// good</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// bad</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  handleClick () &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123; <span class="hljs-attr">xxx</span>: aaa &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span><br><span class="xml">        Click me</span><br><span class="xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>事件处理方法以 handle 开头，如 handleClick() {}，用 on 的作为回调做区分</li></ul><h2 id="组件代码组织"><a href="#组件代码组织" class="headerlink" title="组件代码组织"></a>组件代码组织</h2><ul><li>按照生命周期顺序组织组件的属性、方法；</li><li>方法（属性）之间空一行；</li><li><code>render()</code> 方法始终放在最后；</li><li>自定义方法 React API 方法之后、<code>render()</code> 之前；</li><li><code>class extends React.Component</code> 顺序：<ol><li><code>static</code> 属性</li><li><code>static</code> 方法</li><li><code>constructor</code></li><li><code>getChildContext</code></li><li><code>componentWillMount</code></li><li><code>componentDidMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li><li><em>点击处理函数或者其他事件处理函数</em>，如 <code>onClickSubmit()</code> 或 <code>onChangeDescription()</code></li><li><em><code>render</code> 的 getter 方法</em>，如 <code>getSelectReason()</code> 或 <code>getFooterContent()</code></li><li><em>可选的 render 方法</em>，如 <code>renderNavigation()</code> 或 <code>renderProfilePicture()</code></li><li><code>render</code></li></ol></li><li>定义 propTypes, defaultProps, contextTypes</li></ul><h2 id="代码校验工具"><a href="#代码校验工具" class="headerlink" title="代码校验工具"></a><strong>代码校验工具</strong></h2><ul><li><a href="https://www.github.com/eslint/eslint">ESLint</a></li><li><a href="https://github.com/yannickcr/eslint-plugin-react">ESLint React Plugin</a></li><li><a href="https://github.com/evcohen/eslint-plugin-jsx-a11y">ESLint JSX A11Y Plugin</a></li></ul><p>参考：<a href="https://github.com/minwe/style-guide/blob/master/React.js.md">https://github.com/minwe/style-guide/blob/master/React.js.md</a></p><p>参考：<a href="https://github.com/JasonBoy/javascript/tree/master/react">JasonBoy/javascript</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;&lt;strong&gt;基本规范&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个文件只包含的一个 React 组件：&lt;ul&gt;
&lt;li&gt;联系紧密的组件可以使</summary>
      
    
    
    
    <category term="笔记本" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0%E6%9C%AC/"/>
    
    
    <category term="react" scheme="http://example.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>从两个角度看 Typescript 中的类型是什么?</title>
    <link href="http://example.com/index.php/archives/302/"/>
    <id>http://example.com/index.php/archives/302/</id>
    <published>2020-03-03T02:09:33.000Z</published>
    <updated>2020-03-03T02:10:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0-作者以及原文介绍"><a href="#0-作者以及原文介绍" class="headerlink" title="0. 作者以及原文介绍"></a>0. 作者以及原文介绍</h2><p>作者是 <strong>Dr. Axel Rauschmayer</strong>，号称”德国阮一峰“，本文原文来自于他的博客：<a href="https://2ality.com/2020/02/understanding-types-typescript.html%EF%BC%8C%E4%B8%8D%E7%86%9F%E6%82%89%E4%BB%96%E7%9A%84%E5%8F%AF%E4%BB%A5%E5%85%B3%E6%B3%A8%E4%B8%80%E4%B8%8B%E4%BB%96%E7%9A%84%E5%8D%9A%E5%AE%A2%E3%80%82">https://2ality.com/2020/02/understanding-types-typescript.html，不熟悉他的可以关注一下他的博客。</a></p><h2 id="1-每个角度都从这三个问题来解释"><a href="#1-每个角度都从这三个问题来解释" class="headerlink" title="1. 每个角度都从这三个问题来解释"></a>1. 每个角度都从这三个问题来解释</h2><p>以下三个问题对于理解类型是如何工作的非常重要，需要从这两个角度中的每一个角度来回答。</p><ol><li><code>myVariable</code> 的类型 <code>MyType</code> 意味着什么？</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> myVariable: MyType = <span class="hljs-comment">/*...*/</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li><code>Sourcetype</code> 可以分配给 <code>TargetType</code> 吗?</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> source: SourceType = <span class="hljs-comment">/*...*/</span>;<br><span class="hljs-keyword">let</span> target: TargetType = source;<br></code></pre></td></tr></table></figure><ol start="3"><li><code>TypeUnion</code> 是如何从<code> Type1</code>、 <code>Type2 </code>和  <code>Type3</code> 衍生而来的？</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> TypeUnion = Type1 | Type2 | Type3;<br></code></pre></td></tr></table></figure><h2 id="2-角度-1：-类型是一组值"><a href="#2-角度-1：-类型是一组值" class="headerlink" title="2. 角度 1： 类型是一组值"></a>2. 角度 1： 类型是一组值</h2><p>从这个角度来看，类型是一组值：</p><ol><li><p>如果 <code>myVariable</code> 具有 <code>MyType</code> 类型，这意味着可以分配给 <code>myVariable</code> 的所有值都必须是集合 <code>MyType</code> 的元素。</p></li><li><p>如果 <code>Sourcetype</code> 可以分配给 <code>TargetType</code>，那么 <code>Sourcetype</code> 是 <code>TargetType</code> 的子集。 因此，<code>TargetType</code> 也允许<code> SourceType</code> 所允许的所有值。</p></li><li><p>类型 <code>Type1</code>、 <code>Type2</code>和 <code>Type3</code>的联合类型是定义它们的集合在集合论中的并集。</p></li></ol><h2 id="3-角度2：-类型兼容关系"><a href="#3-角度2：-类型兼容关系" class="headerlink" title="3. 角度2： 类型兼容关系"></a>3. 角度2： 类型兼容关系</h2><p>从这个角度来看，我们不关心值以及它们在执行代码时如何流动。 相反，我们采取了一种更为静态的观点:</p><ul><li>源代码有个位置，每个位置都有一个静态类型。 在支持 <strong>Typescript</strong> 的编辑器中，如果我们将鼠标悬停在某个位置的上方，就可以看到该位置的静态类型。</li><li>当源位置通过赋值、函数调用等方式连接到目标位置时，源位置的类型必须与目标位置的类型兼容。 <strong>Typescript</strong> 规范通过所谓的类型关系定义类型的兼容性。</li><li>类型关系分配兼容性定义了源类型 <code>S</code> 何时可以分配给目标类型 <code>T</code>:<ul><li><code>S</code> 和 <code>T</code>  都是一样的类型</li><li><code>S</code> 或者 <code>T</code> 是 any 类型。</li><li>等等</li></ul></li></ul><p>让我们考虑以下问题：</p><ol><li>如果 <code>myVariable</code> 的静态类型可以分配给 <code>MyType</code> ，那么 <code>myVariable</code> 就具有类型 <code>MyType</code></li><li>如果 <code>SourceType</code> 和 <code>TargetType</code> 是互相兼容的，那么<code>SourceType</code>可以分配给 <code>TargetType</code></li><li>联合类型的工作方式是通过类型关系成员定义的。</li></ol><p>类型系统一个有趣的特点是，同一个变量在不同的位置可以有不同的静态类型:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [];<br><span class="hljs-comment">// %inferred-type: any[]</span><br>arr;<br><br>arr.push(<span class="hljs-number">123</span>);<br><span class="hljs-comment">// %inferred-type: number[]</span><br>arr;<br><br>arr.push(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-comment">// %inferred-type: (string | number)[]</span><br>arr;<br></code></pre></td></tr></table></figure><h2 id="4-标准类型系统和结构类型系统"><a href="#4-标准类型系统和结构类型系统" class="headerlink" title="4. 标准类型系统和结构类型系统"></a>4. 标准类型系统和结构类型系统</h2><p>静态类型系统的职责之一是确定两个静态类型是否兼容：</p><ul><li>实际参数的静态类型U（例如，通过函数调用提供）</li><li>对应形式参数的静态类型T（指定为函数定义的一部分）</li></ul><p>这通常意味着要检查 U 是否是 T 的子类型。这种检查的两种方法(大致)是:</p><ul><li><p>在标准类型中，如果两个静态类型具有相同的标识(“名称”) ，则它们是相等的。 一种类型是另一种类型的子类型，它们的子类型关系是显式声明的。</p><blockquote><p>具有标准类型的语言有 <strong>c++</strong> 、 <strong>Java</strong>、 <strong>c#</strong> 、 <strong>Swift</strong> 和 <strong>Rust</strong></p></blockquote></li><li><p>在结构类型系统中，如果两个静态类型具有相同的结构(如果它们的部分具有相同的名称和相同的类型) ，则它们是相等的。 如果 U 包含 T 的所有部分(可能还包括其他部分) ，并且 U 的每个部分都包含 T 的相应部分的子类型，那么一种类型 U 就是另一种类型 T 的子类型。</p><blockquote><p>具有结构类型的语言有 <strong>ocaml</strong>/<strong>reasonml</strong>、 <strong>Haskell</strong> 和 <strong>TypeScript</strong></p></blockquote></li></ul><p>下面的代码在标准类型系统中产生类型错误(第 A 行) ，但在 <strong>Typescript</strong> 的结构类型系统中是合法的，因为类 <code>A</code> 和类 <code>B</code> 具有相同的结构:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  name = <span class="hljs-string">&#x27;A&#x27;</span>;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>  name = <span class="hljs-string">&#x27;B&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">const</span> someVariable: A = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// (A)</span><br></code></pre></td></tr></table></figure><p><strong>Typescript</strong> 的接口在结构上也能工作——它们不需要实现来匹配:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">interface Point &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  y: number;<br>&#125;<br><span class="hljs-keyword">const</span> point: Point = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;; <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><h2 id="5-进一步阅读"><a href="#5-进一步阅读" class="headerlink" title="5. 进一步阅读"></a>5. 进一步阅读</h2><ul><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html">Chapter “Type Compatibility” in the TypeScript Handbook</a></li><li><a href="https://github.com/microsoft/TypeScript/blob/master/doc/spec.md#311-type-relationships">Section “TypeRelationships” in the TypeScript Specification</a></li></ul><blockquote><p>如果翻译得不对的地方希望您可以帮忙指出来。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0-作者以及原文介绍&quot;&gt;&lt;a href=&quot;#0-作者以及原文介绍&quot; class=&quot;headerlink&quot; title=&quot;0. 作者以及原文介绍&quot;&gt;&lt;/a&gt;0. 作者以及原文介绍&lt;/h2&gt;&lt;p&gt;作者是 &lt;strong&gt;Dr. Axel Rauschmayer&lt;/st</summary>
      
    
    
    
    <category term="译文" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/"/>
    
    <category term="前端" scheme="http://example.com/categories/%E8%AF%91%E6%96%87/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>我也想做自己喜欢做的事儿</title>
    <link href="http://example.com/index.php/archives/301/"/>
    <id>http://example.com/index.php/archives/301/</id>
    <published>2020-02-28T01:31:45.000Z</published>
    <updated>2020-02-28T01:32:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我今天看到一视频，给了我非常大感触。是 B 站上的一个视频，标题名叫：<strong>《这有可能是我最后一期视频了，再见了 B 站》，</strong> 视频链接可以点击「原文链接」得到。</p><p>这个视频大概讲的是这样：</p><p>一个富二代，大学毕业以后没有去家里帮爸妈，由于自己非常喜欢游戏，所以就想做自媒体，自己赚钱养自己，做了差不多一年半，在 B 站拥有不多不少的 25 万粉丝，由于他自己喜欢的是单机游戏，但是国内喜欢单机游戏的人太少，所以在 B 站涨粉缓慢，慢慢的，迫于生计，不得追求快速涨粉，不至于入不敷出。</p><p>所以就开始做一些自己不喜欢的视频，比如热点视频，电影娱乐等，因为这些看的人多，涨粉相对较快，但是自己并不喜欢这些视频。以前自己做的游戏视频做完之后会回味好几遍，但是现在做的这些视频自己非常不喜欢，做完之后完全没有动力去看。</p><p>突然有一天他的爸妈给他买了一套 <strong>1600 万</strong>的房子，加上装修可能 1700 万左右，但是他爸妈只付了首付(他爸妈能全款买得起)，剩下的贷款要让他自己还，目的就是要让他回去帮家里的忙，因为他做自媒体根本换不起这个贷款。</p><p>一个月贷款要还 3 万多，他做 B 站一年半才赚了 10 万，他爸妈就质问他，你觉得你做现在这个职业有前途吗？能还得起这个房贷吗？如果将来你的儿子想住这么大的房子你买得起吗？</p><p>他就开始思考当初的初心，自己做自媒体是为了赚钱，现在家里有四个厂，家里父母也 50 了，回去帮忙岂不是能花更少的时间赚更多的钱。</p><p>所以他就关了自己的工作室，不再做自己不喜欢的视频，并且回家去继承家业。</p><p>看完这段视频莫名的感到了一丝心酸和无奈。</p><p><strong>心酸</strong>的是很多做自媒体(包括我自己)的刚开始都是做自己喜欢的东西，后来慢慢的为了粉丝向营销号靠拢，远离了自己的初心，这视频作者可以回家继承家产，而剩下的那些远离了初心的人又会何去何从呢？</p><p><strong>无奈</strong>的是即使家里这么有钱，不想靠着父母打拼出一番事业，但是在房贷的压力下，以及对自己能力确实不太能够打拼出一番事业，最后只能回家靠父母的无奈。</p><p>这种富二代他们一次一次的失败之后，还是会有退路(回家继承家产)，但是对于我们普通人来说，就没有退路，只能向前冲，就得努力赚钱。</p><p>但是在自己能力还没到的时候，做自己想做的事的时候，又赚不了那么多钱，所以只能违背这自己的初心，去赚一些合法的钱。</p><p>在这种金钱和自己喜欢的东西做斗争的时候，我无法给出应该选择哪种的建议。可能站在局外人来说，当然做自己喜欢的事儿呀，把事情做好，然后赚钱是自然的。</p><p>道理谁都懂，但是我觉得这是在考验人性的时候，当这件事儿发生在你的身上可能就不一定会这么做，因为我遇到太多太多这样的人了，只有非常少数的人能坚持自己的原则，这种人往往就缺少一个贵人，等待一个爆发期，但是在爆发期来临之前，又有多少人能坚持下来呢，很难说。</p><p>最后想说的是还是想做那个最初想做的人，<strong>把这个公众号做成自己喜欢的样子</strong>，提供一些在其他地方看不到的稀缺的有价值的东西，跟我公众号的 slogon 一样：<strong>成为自己想成为的那个样子。</strong> 每天花一小时来写文章，而不是花半个小时来找一篇好的文章。</p><p>其实我很希望你们可以给我多留言，多跟我<strong>交流</strong>你们的想法，而不是向我提一些问题，让我解答，两者之间的区别在于我们两是否在同一个水平，是否双方都会受益。</p><p>所以我喜欢你在请教我一些东西的时候，你已经做好了功课，咱们在此次对话中花了这么多时间，都能得到一些价值。</p><p>虽然我不是一个大 V，但是我还是很忙，有我自己的事儿，每天向我请教的人又特别多，我目前不想专门开一个付费的知识星球来回答问题，然后出售我的时间。</p><p>如果你希望和我交流，可以在公众号后台回复「微信」，联系到我。</p><p><strong>最后如果你还愿意继续关注我的话，可以留个言，点个好看，甚至帮我多转发文章。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我今天看到一视频，给了我非常大感触。是 B 站上的一个视频，标题名叫：&lt;strong&gt;《这有可能是我最后一期视频了，再见了 B 站》，&lt;/strong&gt; 视频链接可以点击「原文链接」得到。&lt;/p&gt;
&lt;p&gt;这个视频大概讲的是这样：&lt;/p&gt;
&lt;p&gt;一个富二代，大学毕业以后没有去</summary>
      
    
    
    
    <category term="观点与感想" scheme="http://example.com/categories/%E8%A7%82%E7%82%B9%E4%B8%8E%E6%84%9F%E6%83%B3/"/>
    
    
    <category term="思考" scheme="http://example.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
